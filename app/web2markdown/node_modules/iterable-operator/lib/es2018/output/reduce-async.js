"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reduceAsync = exports.RuntimeError = void 0;
const types_1 = require("@blackglory/types");
const error_1 = require("../error");
Object.defineProperty(exports, "RuntimeError", { enumerable: true, get: function () { return error_1.RuntimeError; } });
function reduceAsync(iterable, fn, initialValue) {
    if (types_1.isUndefined(initialValue)) {
        return reduceAsyncWithoutInitialValue(iterable, fn);
    }
    else {
        return reduceAsyncWithInitialValue(iterable, fn, initialValue);
    }
}
exports.reduceAsync = reduceAsync;
function reduceAsyncWithInitialValue(iterable, fn, initialValue) {
    if (types_1.isAsyncIterable(iterable)) {
        return reduceAsyncIterable(iterable);
    }
    else {
        return reduceIterable(iterable);
    }
    async function reduceIterable(iterable) {
        let result = initialValue, index = 0;
        for (const currentValue of iterable) {
            result = await fn(result, currentValue, index++);
        }
        return result;
    }
    async function reduceAsyncIterable(iterable) {
        let result = initialValue, index = 0;
        for await (const currentValue of iterable) {
            result = await fn(result, currentValue, index++);
        }
        return result;
    }
}
function reduceAsyncWithoutInitialValue(iterable, fn) {
    if (types_1.isAsyncIterable(iterable)) {
        return reduceAsyncIterable(iterable);
    }
    else {
        return reduceIterable(iterable);
    }
    async function reduceAsyncIterable(iterable) {
        const [initialValue, iterator] = await readFirst(iterable);
        let result = initialValue, index = 1;
        while (true) {
            const current = await iterator.next();
            if (current.done)
                break;
            const currentValue = current.value;
            result = await fn(result, currentValue, index++);
        }
        return result;
        async function readFirst(iterable) {
            const [[result], iterator] = await read(iterable, 1);
            return [result, iterator];
        }
        async function read(iterable, count) {
            const iterator = iterable[Symbol.asyncIterator]();
            const result = [];
            while (count > 0) {
                const current = await iterator.next();
                if (current.done)
                    throw new error_1.RuntimeError('Reduce of empty iterable with no initial value');
                result.push(current.value);
                count--;
            }
            return [result, iterator];
        }
    }
    async function reduceIterable(iterable) {
        const [initialValue, iterator] = readFirst(iterable);
        let result = initialValue, index = 1;
        while (true) {
            const current = iterator.next();
            if (current.done)
                break;
            const currentValue = current.value;
            result = await fn(result, currentValue, index++);
        }
        return result;
        function readFirst(iterable) {
            const [[result], iterator] = read(iterable, 1);
            return [result, iterator];
        }
        function read(iterable, count) {
            const iterator = iterable[Symbol.iterator]();
            const result = [];
            while (count > 0) {
                const current = iterator.next();
                if (current.done)
                    throw new error_1.RuntimeError('Reduce of empty iterable with no initial value');
                result.push(current.value);
                count--;
            }
            return [result, iterator];
        }
    }
}
//# sourceMappingURL=reduce-async.js.map