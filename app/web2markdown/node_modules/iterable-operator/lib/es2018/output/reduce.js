"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reduce = exports.RuntimeError = void 0;
const types_1 = require("@blackglory/types");
const error_1 = require("../error");
Object.defineProperty(exports, "RuntimeError", { enumerable: true, get: function () { return error_1.RuntimeError; } });
function reduce(iterable, fn, initialValue) {
    if (types_1.isUndefined(initialValue)) {
        return reduceWithoutInitialValue(iterable, fn);
    }
    else {
        return reduceWithInitialValue(iterable, fn, initialValue);
    }
}
exports.reduce = reduce;
function reduceWithInitialValue(iterable, fn, initialValue) {
    let result = initialValue, index = 0;
    for (const currentValue of iterable) {
        result = fn(result, currentValue, index++);
    }
    return result;
}
function reduceWithoutInitialValue(iterable, fn) {
    const [initialValue, iterator] = readFirst(iterable);
    let result = initialValue, index = 1;
    while (true) {
        const current = iterator.next();
        if (current.done)
            break;
        const currentValue = current.value;
        result = fn(result, currentValue, index++);
    }
    return result;
    function readFirst(iterable) {
        const [[result], iterator] = read(iterable, 1);
        return [result, iterator];
    }
    function read(iterable, count) {
        const iterator = iterable[Symbol.iterator]();
        const result = [];
        while (count > 0) {
            const current = iterator.next();
            if (current.done)
                throw new error_1.RuntimeError('Reduce of empty iterable with no initial value');
            result.push(current.value);
            count--;
        }
        return [result, iterator];
    }
}
//# sourceMappingURL=reduce.js.map