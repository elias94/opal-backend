"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseManifest = void 0;
const query_1 = require("@blackglory/query");
const extra_promise_1 = require("extra-promise");
const iterable_operator_1 = require("iterable-operator/lib/es2015/style/chaining/iterable-operator");
const parse_html_1 = require("./utils/parse-html");
const parse_json_1 = require("./utils/parse-json");
const is_url_1 = require("./utils/is-url");
const combine_relative_urls_1 = require("./utils/combine-relative-urls");
const parse_space_separated_sizes_1 = require("./utils/parse-space-separated-sizes");
const immer_1 = require("./utils/immer");
function parseManifest(html, textFetcher) {
    return __awaiter(this, void 0, void 0, function* () {
        const document = parse_html_1.parseHTML(html);
        const manifestUrls = getManifestUrls(document);
        const results = yield extra_promise_1.map(manifestUrls, (url) => __awaiter(this, void 0, void 0, function* () {
            const text = yield fetch(url);
            if (text) {
                return getManifestIcons(text, url);
            }
            else {
                return [];
            }
        }));
        return [].concat(...results);
        function fetch(url) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield textFetcher(url);
                }
                catch (_a) {
                    return null;
                }
            });
        }
    });
}
exports.parseManifest = parseManifest;
function getManifestUrls(document) {
    const nodes = query_1.query.call(document, query_1.css `link[rel="manifest"]`);
    return new iterable_operator_1.IterableOperator(nodes)
        .map(x => x.getAttribute('href'))
        .filter(is_url_1.isUrl)
        .toArray();
}
function getManifestIcons(json, baseURI) {
    const manifest = parse_json_1.parseJSON(json);
    return manifest.icons
        .map(x => createManifestIcon(x.src, parse_space_separated_sizes_1.parseSpaceSeparatedSizes(x.sizes), x.type))
        .map(combineIconUrlWithManifestUrl);
    function combineIconUrlWithManifestUrl(icon) {
        return immer_1.produce(icon, draft => {
            draft.url = combineRelativeUrlsForManifest(baseURI, icon.url);
        });
    }
    function createManifestIcon(url, sizes, type) {
        return {
            url,
            reference: 'manifest',
            type: type !== null && type !== void 0 ? type : null,
            size: createSize()
        };
        function createSize() {
            if (sizes.length === 0)
                return null;
            if (sizes.length === 1)
                return sizes[0];
            return sizes;
        }
    }
}
function combineRelativeUrlsForManifest(baseURI, relativeUrl) {
    return combine_relative_urls_1.combineRelativeUrls(baseURI, relativeUrl);
}
//# sourceMappingURL=parse-manifest.js.map