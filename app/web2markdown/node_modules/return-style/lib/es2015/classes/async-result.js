"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _promise;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncResult = void 0;
const result_1 = require("./result");
const get_success_promise_1 = require("../functions/get-success-promise");
const get_failure_promise_1 = require("../functions/get-failure-promise");
const is_success_promise_1 = require("../functions/is-success-promise");
const is_failure_promise_1 = require("../functions/is-failure-promise");
class AsyncResult {
    constructor(promise) {
        _promise.set(this, void 0);
        __classPrivateFieldSet(this, _promise, Promise.resolve(promise));
    }
    static Ok(value) {
        return AsyncOk.of(value);
    }
    static Err(error) {
        return AsyncErr.of(error);
    }
    get then() {
        const promise = __classPrivateFieldGet(this, _promise).then(x => result_1.Result.Ok(x), x => result_1.Result.Err(x));
        return promise.then.bind(promise);
    }
    onOk(callback) {
        ;
        (() => __awaiter(this, void 0, void 0, function* () {
            const [succ, ret] = yield get_success_promise_1.getSuccessPromise(__classPrivateFieldGet(this, _promise));
            if (succ)
                callback(ret);
        }))();
        return new AsyncResult(__classPrivateFieldGet(this, _promise));
    }
    onErr(callback) {
        ;
        (() => __awaiter(this, void 0, void 0, function* () {
            const [fail, err] = yield get_failure_promise_1.getFailurePromise(__classPrivateFieldGet(this, _promise));
            if (fail)
                callback(err);
        }))();
        return new AsyncResult(__classPrivateFieldGet(this, _promise));
    }
    isOk() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield is_success_promise_1.isSuccessPromise(__classPrivateFieldGet(this, _promise));
        });
    }
    isErr() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield is_failure_promise_1.isFailurePromise(__classPrivateFieldGet(this, _promise));
        });
    }
    orElse(defaultValue) {
        return new AsyncResult((() => __awaiter(this, void 0, void 0, function* () {
            try {
                return yield __classPrivateFieldGet(this, _promise);
            }
            catch (_a) {
                return defaultValue;
            }
        }))());
    }
    map(mapper) {
        return new AsyncResult((() => __awaiter(this, void 0, void 0, function* () {
            const result = yield __classPrivateFieldGet(this, _promise);
            return mapper(result);
        }))());
    }
    get() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield __classPrivateFieldGet(this, _promise);
        });
    }
}
exports.AsyncResult = AsyncResult;
_promise = new WeakMap();
class AsyncOk extends AsyncResult {
    static of(value) {
        return new AsyncOk(value);
    }
    constructor(value) {
        super(Promise.resolve(value));
    }
}
class AsyncErr extends AsyncResult {
    static of(value) {
        return new AsyncErr(value);
    }
    constructor(err) {
        super(Promise.reject(err));
    }
}
//# sourceMappingURL=async-result.js.map