import { IResult } from './result';
export interface IAsyncResult<T, X> extends PromiseLike<IResult<T, X>> {
    onOk(callback: (val: T) => void): IAsyncResult<T, X>;
    onErr(callback: (err: X) => void): IAsyncResult<T, X>;
    isOk(): Promise<boolean>;
    isErr(): Promise<boolean>;
    orElse<U>(defaultValue: U): IAsyncResult<T | U, never>;
    map<U>(mapper: (val: T) => U): IAsyncResult<U, X>;
    get(): Promise<T>;
}
export declare class AsyncResult<T, X> implements IAsyncResult<T, X> {
    #private;
    static Ok<T>(value: T): IAsyncResult<T, never>;
    static Err<T>(error: T): IAsyncResult<never, T>;
    get then(): <TResult1 = IResult<T, X>, TResult2 = never>(onfulfilled?: ((value: IResult<T, X>) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined) => PromiseLike<TResult1 | TResult2>;
    constructor(promise: PromiseLike<T> | T);
    onOk(callback: (val: T) => void): IAsyncResult<T, X>;
    onErr(callback: (err: X) => void): IAsyncResult<T, X>;
    isOk(): Promise<boolean>;
    isErr(): Promise<boolean>;
    orElse<U>(defaultValue: U): IAsyncResult<T | U, never>;
    map<U>(mapper: (val: T) => U): IAsyncResult<U, X>;
    get(): Promise<T>;
}
