import { IOptional } from './optional';
export declare const Nil: unique symbol;
export interface IAsyncOptional<T> extends PromiseLike<IOptional<T>> {
    onSome(callback: (val: T) => void): IAsyncOptional<T>;
    onNone(callback: () => void): IAsyncOptional<T>;
    isSome(): Promise<boolean>;
    isNone(): Promise<boolean>;
    orElse<U>(defaultValue: U): IAsyncOptional<T | U>;
    map<U>(mapper: (val: T) => U): IAsyncOptional<U>;
    filter<U extends T = T>(predicate: (val: T) => boolean): IAsyncOptional<U>;
    get(): Promise<T>;
}
export declare class AsyncOptional<T> implements IAsyncOptional<T> {
    #private;
    static Some<T>(value: T): IAsyncOptional<T>;
    static None(): IAsyncOptional<never>;
    get then(): <TResult1 = IOptional<T>, TResult2 = never>(onfulfilled?: ((value: IOptional<T>) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined) => PromiseLike<TResult1 | TResult2>;
    constructor(promise: PromiseLike<T | typeof Nil> | T | typeof Nil);
    onSome(callback: (val: T) => void): IAsyncOptional<T>;
    onNone(callback: () => void): IAsyncOptional<T>;
    isSome(): Promise<boolean>;
    isNone(): Promise<boolean>;
    orElse<U>(defaultValue: U): IAsyncOptional<T | U>;
    map<U>(mapper: (val: T) => U): IAsyncOptional<U>;
    filter<U extends T = T>(predicate: (val: T) => boolean): IAsyncOptional<U>;
    get(): Promise<T>;
}
