function getErrorResult(fn) {
    try {
        const result = fn();
        return [void 0, result];
    }
    catch (e) {
        return [e, void 0];
    }
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}

function getErrorResultAsync(fn) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const result = yield fn();
            return [void 0, result];
        }
        catch (e) {
            return [e, void 0];
        }
    });
}

function getErrorResultPromise(promise) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const result = yield promise;
            return [void 0, result];
        }
        catch (e) {
            return [e, void 0];
        }
    });
}

function getResultError(fn) {
    try {
        const result = fn();
        return [result, void 0];
    }
    catch (e) {
        return [void 0, e];
    }
}

function getResultErrorAsync(fn) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const result = yield fn();
            return [result, void 0];
        }
        catch (e) {
            return [void 0, e];
        }
    });
}

function getResultErrorPromise(promise) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const result = yield promise;
            return [result, void 0];
        }
        catch (e) {
            return [void 0, e];
        }
    });
}

function getSuccess(fn) {
    try {
        const result = fn();
        return [true, result];
    }
    catch (_a) {
        return [false, void 0];
    }
}

function getSuccessAsync(fn) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const result = yield fn();
            return [true, result];
        }
        catch (_a) {
            return [false, void 0];
        }
    });
}

function getSuccessPromise(promise) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const result = yield promise;
            return [true, result];
        }
        catch (_a) {
            return [false, void 0];
        }
    });
}

function getFailure(fn) {
    try {
        fn();
        return [false, void 0];
    }
    catch (e) {
        return [true, e];
    }
}

function getFailureAsync(fn) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield fn();
            return [false, void 0];
        }
        catch (e) {
            return [true, e];
        }
    });
}

function getFailurePromise(promise) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield promise;
            return [false, void 0];
        }
        catch (e) {
            return [true, e];
        }
    });
}

function isSuccess(fn) {
    try {
        fn();
        return true;
    }
    catch (_a) {
        return false;
    }
}

function isSuccessAsync(fn) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield fn();
            return true;
        }
        catch (_a) {
            return false;
        }
    });
}

function isSuccessPromise(promise) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield promise;
            return true;
        }
        catch (_a) {
            return false;
        }
    });
}

function isFailure(fn) {
    try {
        fn();
        return false;
    }
    catch (_a) {
        return true;
    }
}

function isFailureAsync(fn) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield fn();
            return false;
        }
        catch (_a) {
            return true;
        }
    });
}

function isFailurePromise(promise) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield promise;
            return false;
        }
        catch (_a) {
            return true;
        }
    });
}

function getResult(fn) {
    try {
        return fn();
    }
    catch (_a) {
        return;
    }
}

function getResultAsync(fn) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield fn();
        }
        catch (_a) {
            return undefined;
        }
    });
}

function getResultPromise(promise) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield promise;
        }
        catch (_a) {
            return;
        }
    });
}

function getError(fn) {
    try {
        fn();
    }
    catch (syncError) {
        return syncError;
    }
    return;
}

function getErrorAsync(fn) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield fn();
        }
        catch (err) {
            return err;
        }
        return;
    });
}

function getErrorPromise(promise) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield promise;
        }
        catch (err) {
            return err;
        }
        return;
    });
}

function getErrorAsyncIterable(iterable) {
    var iterable_1, iterable_1_1;
    var e_1, _a;
    return __awaiter(this, void 0, void 0, function* () {
        try {
            try {
                for (iterable_1 = __asyncValues(iterable); iterable_1_1 = yield iterable_1.next(), !iterable_1_1.done;) {
                    const _ = iterable_1_1.value;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) yield _a.call(iterable_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        catch (promiseError) {
            return promiseError;
        }
        return;
    });
}

var _value, _value_1;
class Result {
    static Ok(value) {
        return Ok.of(value);
    }
    static Err(error) {
        return Err.of(error);
    }
}
class Ok extends Result {
    constructor(value) {
        super();
        _value.set(this, void 0);
        __classPrivateFieldSet(this, _value, value);
    }
    static of(value) {
        return new Ok(value);
    }
    isOk() {
        return true;
    }
    isErr() {
        return false;
    }
    onOk(callback) {
        callback(__classPrivateFieldGet(this, _value));
        return Ok.of(__classPrivateFieldGet(this, _value));
    }
    onErr() {
        return Ok.of(__classPrivateFieldGet(this, _value));
    }
    orElse() {
        return Ok.of(__classPrivateFieldGet(this, _value));
    }
    map(fn) {
        return Ok.of(fn(__classPrivateFieldGet(this, _value)));
    }
    get() {
        return __classPrivateFieldGet(this, _value);
    }
}
_value = new WeakMap();
class Err extends Result {
    constructor(err) {
        super();
        _value_1.set(this, void 0);
        __classPrivateFieldSet(this, _value_1, err);
    }
    static of(error) {
        return new Err(error);
    }
    isOk() {
        return false;
    }
    isErr() {
        return true;
    }
    onOk() {
        return Err.of(__classPrivateFieldGet(this, _value_1));
    }
    onErr(callback) {
        callback(__classPrivateFieldGet(this, _value_1));
        return Err.of(__classPrivateFieldGet(this, _value_1));
    }
    orElse(defaultValue) {
        return Ok.of(defaultValue);
    }
    map() {
        return Err.of(__classPrivateFieldGet(this, _value_1));
    }
    get() {
        throw __classPrivateFieldGet(this, _value_1);
    }
}
_value_1 = new WeakMap();

function toResult(fn) {
    try {
        const result = fn();
        return Result.Ok(result);
    }
    catch (e) {
        return Result.Err(e);
    }
}

var _promise;
class AsyncResult {
    constructor(promise) {
        _promise.set(this, void 0);
        __classPrivateFieldSet(this, _promise, Promise.resolve(promise));
    }
    static Ok(value) {
        return AsyncOk.of(value);
    }
    static Err(error) {
        return AsyncErr.of(error);
    }
    get then() {
        const promise = __classPrivateFieldGet(this, _promise).then(x => Result.Ok(x), x => Result.Err(x));
        return promise.then.bind(promise);
    }
    onOk(callback) {
        (() => __awaiter(this, void 0, void 0, function* () {
            const [succ, ret] = yield getSuccessPromise(__classPrivateFieldGet(this, _promise));
            if (succ)
                callback(ret);
        }))();
        return new AsyncResult(__classPrivateFieldGet(this, _promise));
    }
    onErr(callback) {
        (() => __awaiter(this, void 0, void 0, function* () {
            const [fail, err] = yield getFailurePromise(__classPrivateFieldGet(this, _promise));
            if (fail)
                callback(err);
        }))();
        return new AsyncResult(__classPrivateFieldGet(this, _promise));
    }
    isOk() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield isSuccessPromise(__classPrivateFieldGet(this, _promise));
        });
    }
    isErr() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield isFailurePromise(__classPrivateFieldGet(this, _promise));
        });
    }
    orElse(defaultValue) {
        return new AsyncResult((() => __awaiter(this, void 0, void 0, function* () {
            try {
                return yield __classPrivateFieldGet(this, _promise);
            }
            catch (_a) {
                return defaultValue;
            }
        }))());
    }
    map(mapper) {
        return new AsyncResult((() => __awaiter(this, void 0, void 0, function* () {
            const result = yield __classPrivateFieldGet(this, _promise);
            return mapper(result);
        }))());
    }
    get() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield __classPrivateFieldGet(this, _promise);
        });
    }
}
_promise = new WeakMap();
class AsyncOk extends AsyncResult {
    static of(value) {
        return new AsyncOk(value);
    }
    constructor(value) {
        super(Promise.resolve(value));
    }
}
class AsyncErr extends AsyncResult {
    static of(value) {
        return new AsyncErr(value);
    }
    constructor(err) {
        super(Promise.reject(err));
    }
}

function toResultAsync(fn) {
    try {
        const result = fn();
        return new AsyncResult(result);
    }
    catch (e) {
        return AsyncResult.Err(e);
    }
}

function toResultPromise(promise) {
    return new AsyncResult(promise);
}

var _value$1;
class Optional {
    static Some(value) {
        return Some.of(value);
    }
    static None() {
        return None.of();
    }
}
class Some extends Optional {
    constructor(value) {
        super();
        _value$1.set(this, void 0);
        __classPrivateFieldSet(this, _value$1, value);
    }
    static of(value) {
        return new Some(value);
    }
    isSome() {
        return true;
    }
    isNone() {
        return false;
    }
    onSome(callback) {
        callback(__classPrivateFieldGet(this, _value$1));
        return Some.of(__classPrivateFieldGet(this, _value$1));
    }
    onNone() {
        return Some.of(__classPrivateFieldGet(this, _value$1));
    }
    orElse() {
        return Some.of(__classPrivateFieldGet(this, _value$1));
    }
    map(mapper) {
        return Some.of(mapper(__classPrivateFieldGet(this, _value$1)));
    }
    filter(predicate) {
        if (predicate(__classPrivateFieldGet(this, _value$1))) {
            return Some.of(__classPrivateFieldGet(this, _value$1));
        }
        else {
            return None.of();
        }
    }
    get() {
        return __classPrivateFieldGet(this, _value$1);
    }
}
_value$1 = new WeakMap();
class None extends Optional {
    static of() {
        return new None();
    }
    constructor() {
        super();
    }
    isSome() {
        return false;
    }
    isNone() {
        return true;
    }
    onSome() {
        return None.of();
    }
    onNone(callback) {
        callback();
        return None.of();
    }
    orElse(defaultValue) {
        return Some.of(defaultValue);
    }
    map() {
        return None.of();
    }
    filter() {
        return None.of();
    }
    get() {
        throw new Error('Cannot get value from None');
    }
}

function toOptionalPartial(isNone) {
    return (fn) => toOptional(fn, isNone);
}
function toOptional(fn, isNone) {
    const result = fn();
    if (isNone(result)) {
        return Optional.None();
    }
    else {
        return Optional.Some(result);
    }
}

var _promise$1;
const Nil = Symbol();
class AsyncOptional {
    constructor(promise) {
        _promise$1.set(this, void 0);
        __classPrivateFieldSet(this, _promise$1, Promise.resolve(promise));
    }
    static Some(value) {
        return AsyncSome.of(value);
    }
    static None() {
        return AsyncNone.of();
    }
    get then() {
        const promise = __classPrivateFieldGet(this, _promise$1).then(x => x === Nil
            ? Optional.None()
            : Optional.Some(x));
        return promise.then.bind(promise);
    }
    onSome(callback) {
        (() => __awaiter(this, void 0, void 0, function* () {
            const result = yield __classPrivateFieldGet(this, _promise$1);
            if (result !== Nil)
                callback(result);
        }))();
        return new AsyncOptional(__classPrivateFieldGet(this, _promise$1));
    }
    onNone(callback) {
        (() => __awaiter(this, void 0, void 0, function* () {
            const result = yield __classPrivateFieldGet(this, _promise$1);
            if (result === Nil)
                callback();
        }))();
        return new AsyncOptional(__classPrivateFieldGet(this, _promise$1));
    }
    isSome() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield __classPrivateFieldGet(this, _promise$1);
            return result !== Nil;
        });
    }
    isNone() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield __classPrivateFieldGet(this, _promise$1);
            return result === Nil;
        });
    }
    orElse(defaultValue) {
        return new AsyncOptional((() => __awaiter(this, void 0, void 0, function* () {
            const result = yield __classPrivateFieldGet(this, _promise$1);
            if (result === Nil)
                return defaultValue;
            return result;
        }))());
    }
    map(mapper) {
        return new AsyncOptional((() => __awaiter(this, void 0, void 0, function* () {
            const result = yield __classPrivateFieldGet(this, _promise$1);
            if (result === Nil)
                return Nil;
            return mapper(result);
        }))());
    }
    filter(predicate) {
        return new AsyncOptional((() => __awaiter(this, void 0, void 0, function* () {
            const result = yield __classPrivateFieldGet(this, _promise$1);
            if (result === Nil)
                return Nil;
            if (predicate(result))
                return result;
            return Nil;
        }))());
    }
    get() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield __classPrivateFieldGet(this, _promise$1);
            if (result === Nil)
                throw new Error('Cannot get value from None');
            return result;
        });
    }
}
_promise$1 = new WeakMap();
class AsyncNone extends AsyncOptional {
    static of() {
        return new AsyncNone();
    }
    constructor() {
        super(Promise.resolve(Nil));
    }
}
class AsyncSome extends AsyncOptional {
    static of(value) {
        return new AsyncSome(value);
    }
    constructor(value) {
        super(Promise.resolve(value));
    }
}

function toOptionalAsyncPartial(isNone) {
    return (fn) => toOptionalAsync(fn, isNone);
}
function toOptionalAsync(fn, isNone) {
    return new AsyncOptional((() => __awaiter(this, void 0, void 0, function* () {
        const result = yield fn();
        if (isNone(result))
            return Nil;
        return result;
    }))());
}

function toOptionalPromisePartial(isNone) {
    return (promise) => toOptionalPromise(promise, isNone);
}
function toOptionalPromise(promise, isNone) {
    return new AsyncOptional((() => __awaiter(this, void 0, void 0, function* () {
        const result = yield promise;
        if (isNone(result))
            return Nil;
        return result;
    }))());
}

export { getError, getErrorAsync, getErrorAsyncIterable, getErrorPromise, getErrorResult, getErrorResultAsync, getErrorResultPromise, getFailure, getFailureAsync, getFailurePromise, getResult, getResultAsync, getResultError, getResultErrorAsync, getResultErrorPromise, getResultPromise, getSuccess, getSuccessAsync, getSuccessPromise, isFailure, isFailureAsync, isFailurePromise, isSuccess, isSuccessAsync, isSuccessPromise, toOptional, toOptionalAsync, toOptionalAsyncPartial, toOptionalPartial, toOptionalPromise, toOptionalPromisePartial, toResult, toResultAsync, toResultPromise };
//# sourceMappingURL=index.mjs.map
