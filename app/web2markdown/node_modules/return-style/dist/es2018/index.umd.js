(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReturnStyle = {}));
}(this, (function (exports) { 'use strict';

    function getErrorResult(fn) {
        try {
            const result = fn();
            return [void 0, result];
        }
        catch (e) {
            return [e, void 0];
        }
    }

    async function getErrorResultAsync(fn) {
        try {
            const result = await fn();
            return [void 0, result];
        }
        catch (e) {
            return [e, void 0];
        }
    }

    async function getErrorResultPromise(promise) {
        try {
            const result = await promise;
            return [void 0, result];
        }
        catch (e) {
            return [e, void 0];
        }
    }

    function getResultError(fn) {
        try {
            const result = fn();
            return [result, void 0];
        }
        catch (e) {
            return [void 0, e];
        }
    }

    async function getResultErrorAsync(fn) {
        try {
            const result = await fn();
            return [result, void 0];
        }
        catch (e) {
            return [void 0, e];
        }
    }

    async function getResultErrorPromise(promise) {
        try {
            const result = await promise;
            return [result, void 0];
        }
        catch (e) {
            return [void 0, e];
        }
    }

    function getSuccess(fn) {
        try {
            const result = fn();
            return [true, result];
        }
        catch (_a) {
            return [false, void 0];
        }
    }

    async function getSuccessAsync(fn) {
        try {
            const result = await fn();
            return [true, result];
        }
        catch (_a) {
            return [false, void 0];
        }
    }

    async function getSuccessPromise(promise) {
        try {
            const result = await promise;
            return [true, result];
        }
        catch (_a) {
            return [false, void 0];
        }
    }

    function getFailure(fn) {
        try {
            fn();
            return [false, void 0];
        }
        catch (e) {
            return [true, e];
        }
    }

    async function getFailureAsync(fn) {
        try {
            await fn();
            return [false, void 0];
        }
        catch (e) {
            return [true, e];
        }
    }

    async function getFailurePromise(promise) {
        try {
            await promise;
            return [false, void 0];
        }
        catch (e) {
            return [true, e];
        }
    }

    function isSuccess(fn) {
        try {
            fn();
            return true;
        }
        catch (_a) {
            return false;
        }
    }

    async function isSuccessAsync(fn) {
        try {
            await fn();
            return true;
        }
        catch (_a) {
            return false;
        }
    }

    async function isSuccessPromise(promise) {
        try {
            await promise;
            return true;
        }
        catch (_a) {
            return false;
        }
    }

    function isFailure(fn) {
        try {
            fn();
            return false;
        }
        catch (_a) {
            return true;
        }
    }

    async function isFailureAsync(fn) {
        try {
            await fn();
            return false;
        }
        catch (_a) {
            return true;
        }
    }

    async function isFailurePromise(promise) {
        try {
            await promise;
            return false;
        }
        catch (_a) {
            return true;
        }
    }

    function getResult(fn) {
        try {
            return fn();
        }
        catch (_a) {
            return;
        }
    }

    async function getResultAsync(fn) {
        try {
            return await fn();
        }
        catch (_a) {
            return undefined;
        }
    }

    async function getResultPromise(promise) {
        try {
            return await promise;
        }
        catch (_a) {
            return;
        }
    }

    function getError(fn) {
        try {
            fn();
        }
        catch (syncError) {
            return syncError;
        }
        return;
    }

    async function getErrorAsync(fn) {
        try {
            await fn();
        }
        catch (err) {
            return err;
        }
        return;
    }

    async function getErrorPromise(promise) {
        try {
            await promise;
        }
        catch (err) {
            return err;
        }
        return;
    }

    async function getErrorAsyncIterable(iterable) {
        try {
            for await (const _ of iterable) { }
        }
        catch (promiseError) {
            return promiseError;
        }
        return;
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var _value, _value_1;
    class Result {
        static Ok(value) {
            return Ok.of(value);
        }
        static Err(error) {
            return Err.of(error);
        }
    }
    class Ok extends Result {
        constructor(value) {
            super();
            _value.set(this, void 0);
            __classPrivateFieldSet(this, _value, value);
        }
        static of(value) {
            return new Ok(value);
        }
        isOk() {
            return true;
        }
        isErr() {
            return false;
        }
        onOk(callback) {
            callback(__classPrivateFieldGet(this, _value));
            return Ok.of(__classPrivateFieldGet(this, _value));
        }
        onErr() {
            return Ok.of(__classPrivateFieldGet(this, _value));
        }
        orElse() {
            return Ok.of(__classPrivateFieldGet(this, _value));
        }
        map(fn) {
            return Ok.of(fn(__classPrivateFieldGet(this, _value)));
        }
        get() {
            return __classPrivateFieldGet(this, _value);
        }
    }
    _value = new WeakMap();
    class Err extends Result {
        constructor(err) {
            super();
            _value_1.set(this, void 0);
            __classPrivateFieldSet(this, _value_1, err);
        }
        static of(error) {
            return new Err(error);
        }
        isOk() {
            return false;
        }
        isErr() {
            return true;
        }
        onOk() {
            return Err.of(__classPrivateFieldGet(this, _value_1));
        }
        onErr(callback) {
            callback(__classPrivateFieldGet(this, _value_1));
            return Err.of(__classPrivateFieldGet(this, _value_1));
        }
        orElse(defaultValue) {
            return Ok.of(defaultValue);
        }
        map() {
            return Err.of(__classPrivateFieldGet(this, _value_1));
        }
        get() {
            throw __classPrivateFieldGet(this, _value_1);
        }
    }
    _value_1 = new WeakMap();

    function toResult(fn) {
        try {
            const result = fn();
            return Result.Ok(result);
        }
        catch (e) {
            return Result.Err(e);
        }
    }

    var _promise;
    class AsyncResult {
        constructor(promise) {
            _promise.set(this, void 0);
            __classPrivateFieldSet(this, _promise, Promise.resolve(promise));
        }
        static Ok(value) {
            return AsyncOk.of(value);
        }
        static Err(error) {
            return AsyncErr.of(error);
        }
        get then() {
            const promise = __classPrivateFieldGet(this, _promise).then(x => Result.Ok(x), x => Result.Err(x));
            return promise.then.bind(promise);
        }
        onOk(callback) {
            (async () => {
                const [succ, ret] = await getSuccessPromise(__classPrivateFieldGet(this, _promise));
                if (succ)
                    callback(ret);
            })();
            return new AsyncResult(__classPrivateFieldGet(this, _promise));
        }
        onErr(callback) {
            (async () => {
                const [fail, err] = await getFailurePromise(__classPrivateFieldGet(this, _promise));
                if (fail)
                    callback(err);
            })();
            return new AsyncResult(__classPrivateFieldGet(this, _promise));
        }
        async isOk() {
            return await isSuccessPromise(__classPrivateFieldGet(this, _promise));
        }
        async isErr() {
            return await isFailurePromise(__classPrivateFieldGet(this, _promise));
        }
        orElse(defaultValue) {
            return new AsyncResult((async () => {
                try {
                    return await __classPrivateFieldGet(this, _promise);
                }
                catch (_a) {
                    return defaultValue;
                }
            })());
        }
        map(mapper) {
            return new AsyncResult((async () => {
                const result = await __classPrivateFieldGet(this, _promise);
                return mapper(result);
            })());
        }
        async get() {
            return await __classPrivateFieldGet(this, _promise);
        }
    }
    _promise = new WeakMap();
    class AsyncOk extends AsyncResult {
        static of(value) {
            return new AsyncOk(value);
        }
        constructor(value) {
            super(Promise.resolve(value));
        }
    }
    class AsyncErr extends AsyncResult {
        static of(value) {
            return new AsyncErr(value);
        }
        constructor(err) {
            super(Promise.reject(err));
        }
    }

    function toResultAsync(fn) {
        try {
            const result = fn();
            return new AsyncResult(result);
        }
        catch (e) {
            return AsyncResult.Err(e);
        }
    }

    function toResultPromise(promise) {
        return new AsyncResult(promise);
    }

    var _value$1;
    class Optional {
        static Some(value) {
            return Some.of(value);
        }
        static None() {
            return None.of();
        }
    }
    class Some extends Optional {
        constructor(value) {
            super();
            _value$1.set(this, void 0);
            __classPrivateFieldSet(this, _value$1, value);
        }
        static of(value) {
            return new Some(value);
        }
        isSome() {
            return true;
        }
        isNone() {
            return false;
        }
        onSome(callback) {
            callback(__classPrivateFieldGet(this, _value$1));
            return Some.of(__classPrivateFieldGet(this, _value$1));
        }
        onNone() {
            return Some.of(__classPrivateFieldGet(this, _value$1));
        }
        orElse() {
            return Some.of(__classPrivateFieldGet(this, _value$1));
        }
        map(mapper) {
            return Some.of(mapper(__classPrivateFieldGet(this, _value$1)));
        }
        filter(predicate) {
            if (predicate(__classPrivateFieldGet(this, _value$1))) {
                return Some.of(__classPrivateFieldGet(this, _value$1));
            }
            else {
                return None.of();
            }
        }
        get() {
            return __classPrivateFieldGet(this, _value$1);
        }
    }
    _value$1 = new WeakMap();
    class None extends Optional {
        static of() {
            return new None();
        }
        constructor() {
            super();
        }
        isSome() {
            return false;
        }
        isNone() {
            return true;
        }
        onSome() {
            return None.of();
        }
        onNone(callback) {
            callback();
            return None.of();
        }
        orElse(defaultValue) {
            return Some.of(defaultValue);
        }
        map() {
            return None.of();
        }
        filter() {
            return None.of();
        }
        get() {
            throw new Error('Cannot get value from None');
        }
    }

    function toOptionalPartial(isNone) {
        return (fn) => toOptional(fn, isNone);
    }
    function toOptional(fn, isNone) {
        const result = fn();
        if (isNone(result)) {
            return Optional.None();
        }
        else {
            return Optional.Some(result);
        }
    }

    var _promise$1;
    const Nil = Symbol();
    class AsyncOptional {
        constructor(promise) {
            _promise$1.set(this, void 0);
            __classPrivateFieldSet(this, _promise$1, Promise.resolve(promise));
        }
        static Some(value) {
            return AsyncSome.of(value);
        }
        static None() {
            return AsyncNone.of();
        }
        get then() {
            const promise = __classPrivateFieldGet(this, _promise$1).then(x => x === Nil
                ? Optional.None()
                : Optional.Some(x));
            return promise.then.bind(promise);
        }
        onSome(callback) {
            (async () => {
                const result = await __classPrivateFieldGet(this, _promise$1);
                if (result !== Nil)
                    callback(result);
            })();
            return new AsyncOptional(__classPrivateFieldGet(this, _promise$1));
        }
        onNone(callback) {
            (async () => {
                const result = await __classPrivateFieldGet(this, _promise$1);
                if (result === Nil)
                    callback();
            })();
            return new AsyncOptional(__classPrivateFieldGet(this, _promise$1));
        }
        async isSome() {
            const result = await __classPrivateFieldGet(this, _promise$1);
            return result !== Nil;
        }
        async isNone() {
            const result = await __classPrivateFieldGet(this, _promise$1);
            return result === Nil;
        }
        orElse(defaultValue) {
            return new AsyncOptional((async () => {
                const result = await __classPrivateFieldGet(this, _promise$1);
                if (result === Nil)
                    return defaultValue;
                return result;
            })());
        }
        map(mapper) {
            return new AsyncOptional((async () => {
                const result = await __classPrivateFieldGet(this, _promise$1);
                if (result === Nil)
                    return Nil;
                return mapper(result);
            })());
        }
        filter(predicate) {
            return new AsyncOptional((async () => {
                const result = await __classPrivateFieldGet(this, _promise$1);
                if (result === Nil)
                    return Nil;
                if (predicate(result))
                    return result;
                return Nil;
            })());
        }
        async get() {
            const result = await __classPrivateFieldGet(this, _promise$1);
            if (result === Nil)
                throw new Error('Cannot get value from None');
            return result;
        }
    }
    _promise$1 = new WeakMap();
    class AsyncNone extends AsyncOptional {
        static of() {
            return new AsyncNone();
        }
        constructor() {
            super(Promise.resolve(Nil));
        }
    }
    class AsyncSome extends AsyncOptional {
        static of(value) {
            return new AsyncSome(value);
        }
        constructor(value) {
            super(Promise.resolve(value));
        }
    }

    function toOptionalAsyncPartial(isNone) {
        return (fn) => toOptionalAsync(fn, isNone);
    }
    function toOptionalAsync(fn, isNone) {
        return new AsyncOptional((async () => {
            const result = await fn();
            if (isNone(result))
                return Nil;
            return result;
        })());
    }

    function toOptionalPromisePartial(isNone) {
        return (promise) => toOptionalPromise(promise, isNone);
    }
    function toOptionalPromise(promise, isNone) {
        return new AsyncOptional((async () => {
            const result = await promise;
            if (isNone(result))
                return Nil;
            return result;
        })());
    }

    exports.getError = getError;
    exports.getErrorAsync = getErrorAsync;
    exports.getErrorAsyncIterable = getErrorAsyncIterable;
    exports.getErrorPromise = getErrorPromise;
    exports.getErrorResult = getErrorResult;
    exports.getErrorResultAsync = getErrorResultAsync;
    exports.getErrorResultPromise = getErrorResultPromise;
    exports.getFailure = getFailure;
    exports.getFailureAsync = getFailureAsync;
    exports.getFailurePromise = getFailurePromise;
    exports.getResult = getResult;
    exports.getResultAsync = getResultAsync;
    exports.getResultError = getResultError;
    exports.getResultErrorAsync = getResultErrorAsync;
    exports.getResultErrorPromise = getResultErrorPromise;
    exports.getResultPromise = getResultPromise;
    exports.getSuccess = getSuccess;
    exports.getSuccessAsync = getSuccessAsync;
    exports.getSuccessPromise = getSuccessPromise;
    exports.isFailure = isFailure;
    exports.isFailureAsync = isFailureAsync;
    exports.isFailurePromise = isFailurePromise;
    exports.isSuccess = isSuccess;
    exports.isSuccessAsync = isSuccessAsync;
    exports.isSuccessPromise = isSuccessPromise;
    exports.toOptional = toOptional;
    exports.toOptionalAsync = toOptionalAsync;
    exports.toOptionalAsyncPartial = toOptionalAsyncPartial;
    exports.toOptionalPartial = toOptionalPartial;
    exports.toOptionalPromise = toOptionalPromise;
    exports.toOptionalPromisePartial = toOptionalPromisePartial;
    exports.toResult = toResult;
    exports.toResultAsync = toResultAsync;
    exports.toResultPromise = toResultPromise;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
