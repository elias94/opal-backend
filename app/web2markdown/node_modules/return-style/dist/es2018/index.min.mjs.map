{"version":3,"file":"index.min.mjs","sources":["../../src/functions/get-error-result.ts","../../src/functions/get-error-result-async.ts","../../src/functions/get-error-result-promise.ts","../../src/functions/get-result-error.ts","../../src/functions/get-result-error-async.ts","../../src/functions/get-result-error-promise.ts","../../src/functions/get-success.ts","../../src/functions/get-success-async.ts","../../src/functions/get-success-promise.ts","../../src/functions/get-failure.ts","../../src/functions/get-failure-async.ts","../../src/functions/get-failure-promise.ts","../../src/functions/is-success.ts","../../src/functions/is-success-async.ts","../../src/functions/is-success-promise.ts","../../src/functions/is-failure.ts","../../src/functions/is-failure-async.ts","../../src/functions/is-failure-promise.ts","../../src/functions/get-result.ts","../../src/functions/get-result-async.ts","../../src/functions/get-result-promise.ts","../../src/functions/get-error.ts","../../src/functions/get-error-async.ts","../../src/functions/get-error-promise.ts","../../src/functions/get-error-async-iterable.ts","../../node_modules/tslib/tslib.es6.js","../../src/classes/result.ts","../../src/functions/to-result.ts","../../src/classes/async-result.ts","../../src/functions/to-result-async.ts","../../src/functions/to-result-promise.ts","../../src/classes/optional.ts","../../src/functions/to-optional.ts","../../src/classes/async-optional.ts","../../src/functions/to-optional-async.ts","../../src/functions/to-optional-promise.ts"],"sourcesContent":["export function getErrorResult<X = Error, T = unknown>(fn: () => T): [undefined, T] | [X, undefined] {\n  try {\n    const result = fn()\n    return [void 0, result]\n  } catch (e) {\n    return [e, void 0]\n  }\n}\n","export async function getErrorResultAsync<X = Error, T = unknown>(fn: () => PromiseLike<T> | T): Promise<[undefined, T] | [X, undefined]> {\n  try {\n    const result = await fn()\n    return [void 0, result]\n  } catch (e) {\n    return [e, void 0]\n  }\n}\n","export async function getErrorResultPromise<X = Error, T = unknown>(promise: PromiseLike<T>): Promise<[undefined, T] | [X, undefined]> {\n  try {\n    const result = await promise\n    return [void 0, result]\n  } catch (e) {\n    return [e, void 0]\n  }\n}\n","export function getResultError<X = Error, T = unknown>(fn: () => T): [T, undefined] | [undefined, X] {\n  try {\n    const result = fn()\n    return [result, void 0]\n  } catch (e) {\n    return [void 0, e]\n  }\n}\n","export async function getResultErrorAsync<X = Error, T = unknown>(fn: () => PromiseLike<T> | T): Promise<[T, undefined] | [undefined, X]> {\n  try {\n    const result = await fn()\n    return [result, void 0]\n  } catch (e) {\n    return [void 0, e]\n  }\n}\n","export async function getResultErrorPromise<X = Error, T = unknown>(promise: PromiseLike<T>): Promise<[T, undefined] | [undefined, X]> {\n  try {\n    const result = await promise\n    return [result, void 0]\n  } catch (e) {\n    return [void 0, e]\n  }\n}\n","export function getSuccess<T>(fn: () => T): [true, T] | [false, undefined] {\n  try {\n    const result = fn()\n    return [true, result]\n  } catch {\n    return [false, void 0]\n  }\n}\n","export async function getSuccessAsync<T>(fn: () => PromiseLike<T> | T): Promise<[true, T] | [false, undefined]> {\n  try {\n    const result = await fn()\n    return [true, result]\n  } catch {\n    return [false, void 0]\n  }\n}\n","export async function getSuccessPromise<T>(promise: PromiseLike<T>): Promise<[true, T] | [false, undefined]> {\n  try {\n    const result = await promise\n    return [true, result]\n  } catch {\n    return [false, void 0]\n  }\n}\n","export function getFailure<X = Error>(fn: () => unknown): [true, X] | [false, undefined] {\n  try {\n    fn()\n    return [false, void 0]\n  } catch (e) {\n    return [true, e]\n  }\n}\n","export async function getFailureAsync<X = Error>(fn: () => PromiseLike<unknown> | unknown): Promise<[true, X] | [false, undefined]> {\n  try {\n    await fn()\n    return [false, void 0]\n  } catch (e) {\n    return [true, e]\n  }\n}\n","export async function getFailurePromise<X = Error>(promise: PromiseLike<unknown>): Promise<[true, X] | [false, undefined]> {\n  try {\n    await promise\n    return [false, void 0]\n  } catch (e) {\n    return [true, e]\n  }\n}\n","export function isSuccess(fn: () => unknown): boolean {\n  try {\n    fn()\n    return true\n  } catch {\n    return false\n  }\n}\n","export async function isSuccessAsync(fn: () => PromiseLike<unknown> | unknown): Promise<boolean> {\n  try {\n    await fn()\n    return true\n  } catch {\n    return false\n  }\n}\n","export async function isSuccessPromise(promise: PromiseLike<unknown>): Promise<boolean> {\n  try {\n    await promise\n    return true\n  } catch {\n    return false\n  }\n}\n","export function isFailure(fn: () => unknown): boolean {\n  try {\n    fn()\n    return false\n  } catch {\n    return true\n  }\n}\n","export async function isFailureAsync(fn: () => Promise<unknown> | unknown): Promise<boolean> {\n  try {\n    await fn()\n    return false\n  } catch {\n    return true\n  }\n}\n","export async function isFailurePromise(promise: PromiseLike<unknown>): Promise<boolean> {\n  try {\n    await promise\n    return false\n  } catch {\n    return true\n  }\n}\n","export function getResult<T>(fn: () => T): T | undefined {\n  try {\n    return fn()\n  } catch {\n    return\n  }\n}\n","export async function getResultAsync<T>(fn: () => PromiseLike<T> | T): Promise<T | undefined> {\n  try {\n    return await fn()\n  } catch {\n    return undefined\n  }\n}\n","export async function getResultPromise<T>(promise: PromiseLike<T>): Promise<T | undefined> {\n  try {\n    return await promise\n  } catch {\n    return\n  }\n}\n","export function getError<X = Error>(fn: () => unknown): X | undefined {\n  try {\n    fn()\n  } catch (syncError) {\n    return syncError\n  }\n  return\n}\n","export async function getErrorAsync<X = Error>(fn: () => PromiseLike<unknown> | unknown): Promise<X | undefined> {\n  try {\n    await fn()\n  } catch (err) {\n    return err\n  }\n  return\n}\n","export async function getErrorPromise<X = Error>(promise: PromiseLike<unknown>): Promise<X | undefined> {\n  try {\n    await promise\n  } catch (err) {\n    return err\n  }\n  return\n}\n","export async function getErrorAsyncIterable<X = Error>(iterable: AsyncIterable<unknown>): Promise<X | undefined> {\n  try {\n    for await (const _ of iterable) {}\n  } catch (promiseError) {\n    return promiseError\n  }\n  return\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","export interface IResult<T, X> {\n  isOk(): boolean\n  isErr(): boolean\n\n  onOk(callback: (val: T) => void): IResult<T, X>\n  onErr(callback: (err: X) => void): IResult<T, X>\n\n  orElse<U>(defaultValue: U): IResult<T, never> | IResult<U, never>\n  map<U>(mapper: (val: T) => U): IResult<U, X>\n\n  get(): T\n}\n\nexport abstract class Result {\n  static Ok<T>(value: T): IResult<T, never> {\n    return Ok.of(value)\n  }\n\n  static Err<T>(error: T): IResult<never, T> {\n    return Err.of(error)\n  }\n}\n\nclass Ok<T> extends Result implements IResult<T, never> {\n  static of<T>(value: T): IResult<T, never> {\n    return new Ok(value)\n  }\n\n  #value: T\n\n  private constructor(value: T) {\n    super()\n    this.#value = value\n  }\n\n  isOk() {\n    return true\n  }\n\n  isErr() {\n    return false\n  }\n\n  onOk(callback: (val: T) => void) {\n    callback(this.#value)\n    return Ok.of(this.#value)\n  }\n\n  onErr() {\n    return Ok.of(this.#value)\n  }\n\n  orElse() {\n    return Ok.of(this.#value)\n  }\n\n  map<U>(fn: (val: T) => U) {\n    return Ok.of(fn(this.#value))\n  }\n\n  get(): T {\n    return this.#value\n  }\n}\n\nclass Err<T> extends Result implements IResult<never, T> {\n  static of<T>(error: T): IResult<never, T> {\n    return new Err(error)\n  }\n\n  #value: T\n\n  private constructor(err: T) {\n    super()\n    this.#value = err\n  }\n\n  isOk() {\n    return false\n  }\n\n  isErr() {\n    return true\n  }\n\n  onOk(): IResult<never, T> {\n    return Err.of(this.#value)\n  }\n\n  onErr(callback: (err: T) => void) {\n    callback(this.#value)\n    return Err.of(this.#value)\n  }\n\n  orElse<U>(defaultValue: U) {\n    return Ok.of(defaultValue)\n  }\n\n  map(): IResult<never, T> {\n    return Err.of(this.#value)\n  }\n\n  get(): never {\n    throw this.#value\n  }\n}\n","import { Result, IResult } from '@classes/result'\n\nexport function toResult<X = Error, T = unknown>(fn: () => T): IResult<T, X> {\n  try {\n    const result = fn()\n    return Result.Ok(result)\n  } catch (e) {\n    return Result.Err(e)\n  }\n}\n","import { IResult, Result } from './result'\nimport { getSuccessPromise } from '@functions/get-success-promise'\nimport { getFailurePromise } from '@functions/get-failure-promise'\nimport { isSuccessPromise } from '@functions/is-success-promise'\nimport { isFailurePromise } from '@functions/is-failure-promise'\n\nexport interface IAsyncResult<T, X> extends PromiseLike<IResult<T, X>> {\n  onOk(callback: (val: T) => void): IAsyncResult<T, X>\n  onErr(callback: (err: X) => void): IAsyncResult<T, X>\n\n  isOk(): Promise<boolean>\n  isErr(): Promise<boolean>\n\n  orElse<U>(defaultValue: U): IAsyncResult<T | U, never>\n  map<U>(mapper: (val: T) => U): IAsyncResult<U, X>\n\n  get(): Promise<T>\n}\n\nexport class AsyncResult<T, X> implements IAsyncResult<T, X> {\n  static Ok<T>(value: T): IAsyncResult<T, never> {\n    return AsyncOk.of(value)\n  }\n\n  static Err<T>(error: T): IAsyncResult<never, T> {\n    return AsyncErr.of(error)\n  }\n\n  #promise: PromiseLike<T>\n\n  get then() {\n    const promise = this.#promise.then(\n      x => Result.Ok(x)\n    , x => Result.Err(x)\n    ) as PromiseLike<IResult<T, X>>\n\n    return promise.then.bind(promise)\n  }\n\n  constructor(promise: PromiseLike<T> | T) {\n    this.#promise = Promise.resolve(promise)\n  }\n\n  onOk(callback: (val: T) => void): IAsyncResult<T, X> {\n    ;(async () => {\n      const [succ, ret] = await getSuccessPromise<T>(this.#promise)\n      if (succ) callback(ret as T)\n    })()\n    return new AsyncResult(this.#promise)\n  }\n\n  onErr(callback: (err: X) => void): IAsyncResult<T, X> {\n    ;(async () => {\n      const [fail, err] = await getFailurePromise<X>(this.#promise)\n      if (fail) callback(err as X)\n    })()\n    return new AsyncResult(this.#promise)\n  }\n\n  async isOk(): Promise<boolean> {\n    return await isSuccessPromise(this.#promise)\n  }\n\n  async isErr(): Promise<boolean> {\n    return await isFailurePromise(this.#promise)\n  }\n\n  orElse<U>(defaultValue: U): IAsyncResult<T | U, never> {\n    return new AsyncResult((async () => {\n      try {\n        return await this.#promise\n      } catch {\n        return defaultValue\n      }\n    })())\n  }\n\n  map<U>(mapper: (val: T) => U): IAsyncResult<U, X> {\n    return new AsyncResult((async () => {\n      const result = await this.#promise\n      return mapper(result as T)\n    })())\n  }\n\n  async get(): Promise<T> {\n    return await this.#promise\n  }\n}\n\nclass AsyncOk<T> extends AsyncResult<T, never> implements IAsyncResult<T, never> {\n  static of<T>(value: T): IAsyncResult<T, never> {\n    return new AsyncOk(value)\n  }\n\n  private constructor(value: T) {\n    super(Promise.resolve(value))\n  }\n}\n\nclass AsyncErr<T> extends AsyncResult<never, T> implements IAsyncResult<never, T> {\n  static of<T>(value: T): IAsyncResult<never, T> {\n    return new AsyncErr(value)\n  }\n\n  private constructor(err: T) {\n    super(Promise.reject(err))\n  }\n}\n","import { AsyncResult, IAsyncResult } from '@classes/async-result'\n\nexport function toResultAsync<X = Error, T = unknown>(fn: () => PromiseLike<T> | T): IAsyncResult<T, X> {\n  try {\n    const result = fn()\n    return new AsyncResult(result)\n  } catch (e) {\n    return AsyncResult.Err(e)\n  }\n}\n","import { AsyncResult, IAsyncResult } from '@classes/async-result'\n\nexport function toResultPromise<X = Error, T = unknown>(promise: PromiseLike<T>): IAsyncResult<T, X> {\n  return new AsyncResult<T, X>(promise)\n}\n","export interface IOptional<T> {\n  isSome(): boolean\n  isNone(): boolean\n\n  onSome(callback: (val: T) => void): IOptional<T>\n  onNone(callback: () => void): IOptional<T>\n\n  orElse<U>(defaultValue: U): IOptional<T | U>\n  map<U>(mapper: (val: T) => U): IOptional<U>\n  filter<U extends T = T>(predicate: (val: T) => boolean): IOptional<U>\n\n  get(): T\n}\n\nexport abstract class Optional {\n  static Some<T>(value: T): IOptional<T> {\n    return Some.of(value)\n  }\n\n  static None(): IOptional<never> {\n    return None.of()\n  }\n}\n\nclass Some<T> extends Optional implements IOptional<T> {\n  static of<T>(value: T): IOptional<T> {\n    return new Some(value)\n  }\n\n  #value: T\n\n  private constructor(value: T) {\n    super()\n    this.#value = value\n  }\n\n  isSome(): this is Some<T> {\n    return true\n  }\n\n  isNone() {\n    return false\n  }\n\n  onSome(callback: (val: T) => void) {\n    callback(this.#value)\n    return Some.of(this.#value)\n  }\n\n  onNone() {\n    return Some.of(this.#value)\n  }\n\n  orElse() {\n    return Some.of(this.#value)\n  }\n\n  map<U>(mapper: (val: T) => U) {\n    return Some.of(mapper(this.#value))\n  }\n\n  filter<U extends T = T>(predicate: (val: T) => boolean) {\n    if (predicate(this.#value)) {\n      return Some.of(this.#value) as IOptional<U>\n    } else {\n      return None.of()\n    }\n  }\n\n  get() {\n    return this.#value\n  }\n}\n\nclass None extends Optional implements IOptional<never> {\n  static of(): IOptional<never> {\n    return new None()\n  }\n\n  private constructor() {\n    super()\n  }\n\n  isSome() {\n    return false\n  }\n\n  isNone() {\n    return true\n  }\n\n  onSome() {\n    return None.of()\n  }\n\n  onNone(callback: () => void) {\n    callback()\n    return None.of()\n  }\n\n  orElse<T>(defaultValue: T) {\n    return Some.of(defaultValue)\n  }\n\n  map() {\n    return None.of()\n  }\n\n  filter() {\n    return None.of()\n  }\n\n  get(): never {\n    throw new Error('Cannot get value from None')\n  }\n}\n","import { Optional, IOptional } from '@classes/optional'\n\nexport function toOptionalPartial<T>(isNone: (val: T) => boolean): (fn: () => T) => IOptional<T> {\n  return (fn: () => T) => toOptional(fn, isNone)\n}\n\nexport function toOptional<T = unknown>(fn: () => T, isNone: (val: T) => boolean): IOptional<T> {\n  const result = fn()\n  if (isNone(result)) {\n    return Optional.None()\n  } else {\n    return Optional.Some(result)\n  }\n}\n","import { IOptional, Optional } from './optional'\n\nexport const Nil = Symbol()\n\nexport interface IAsyncOptional<T> extends PromiseLike<IOptional<T>> {\n  onSome(callback: (val: T) => void): IAsyncOptional<T>\n  onNone(callback: () => void): IAsyncOptional<T>\n\n  isSome(): Promise<boolean>\n  isNone(): Promise<boolean>\n\n  orElse<U>(defaultValue: U): IAsyncOptional<T | U>\n  map<U>(mapper: (val: T) => U): IAsyncOptional<U>\n  filter<U extends T = T>(predicate: (val: T) => boolean): IAsyncOptional<U>\n\n  get(): Promise<T>\n}\n\nexport class AsyncOptional<T> implements IAsyncOptional<T> {\n  static Some<T>(value: T): IAsyncOptional<T> {\n    return AsyncSome.of(value)\n  }\n\n  static None(): IAsyncOptional<never> {\n    return AsyncNone.of()\n  }\n\n  #promise: PromiseLike<T | typeof Nil>\n\n  get then() {\n    const promise = this.#promise.then(x =>\n      x === Nil\n      ? Optional.None()\n      : Optional.Some(x)\n    ) as PromiseLike<IOptional<T>>\n\n    return promise.then.bind(promise)\n  }\n\n  constructor(promise: PromiseLike<T | typeof Nil> | T | typeof Nil) {\n    this.#promise = Promise.resolve(promise)\n  }\n\n  onSome(callback: (val: T) => void): IAsyncOptional<T> {\n    ;(async () => {\n      const result = await this.#promise\n      if (result !== Nil) callback(result)\n    })()\n    return new AsyncOptional(this.#promise)\n  }\n\n  onNone(callback: () => void): IAsyncOptional<T> {\n    ;(async () => {\n      const result = await this.#promise\n      if (result === Nil) callback()\n    })()\n    return new AsyncOptional(this.#promise)\n  }\n\n  async isSome(): Promise<boolean> {\n    const result = await this.#promise\n    return result !== Nil\n  }\n\n  async isNone(): Promise<boolean> {\n    const result = await this.#promise\n    return result === Nil\n  }\n\n  orElse<U>(defaultValue: U): IAsyncOptional<T | U> {\n    return new AsyncOptional<T | U>((async () => {\n      const result = await this.#promise\n      if (result === Nil) return defaultValue\n      return result\n    })())\n  }\n\n  map<U>(mapper: (val: T) => U): IAsyncOptional<U> {\n    return new AsyncOptional<U>((async () => {\n      const result = await this.#promise\n      if (result === Nil) return Nil\n      return mapper(result)\n    })())\n  }\n\n  filter<U extends T = T>(predicate: (val: T) => boolean): IAsyncOptional<U> {\n    return new AsyncOptional<U>((async () => {\n      const result = await this.#promise\n      if (result === Nil) return Nil\n      if (predicate(result)) return result as U\n      return Nil\n    })())\n  }\n\n  async get(): Promise<T> {\n    const result = await this.#promise\n    if (result === Nil) throw new Error('Cannot get value from None')\n    return result\n  }\n}\n\nclass AsyncNone extends AsyncOptional<never> implements IAsyncOptional<never> {\n  static of(): IAsyncOptional<never> {\n    return new AsyncNone()\n  }\n\n  private constructor() {\n    super(Promise.resolve(Nil))\n  }\n}\n\nclass AsyncSome<T> extends AsyncOptional<T> implements IAsyncOptional<T> {\n  static of<T>(value: T): IAsyncOptional<T> {\n    return new AsyncSome(value)\n  }\n\n  private constructor(value: T) {\n    super(Promise.resolve(value))\n  }\n}\n","import { AsyncOptional, IAsyncOptional, Nil } from '@classes/async-optional'\n\nexport function toOptionalAsyncPartial<T>(isNone: (val: T) => boolean): (fn: () => PromiseLike<T> | T) => IAsyncOptional<T> {\n  return (fn: () => PromiseLike<T> | T) => toOptionalAsync(fn, isNone)\n}\n\nexport function toOptionalAsync<T>(fn: () => PromiseLike<T> | T, isNone: (val: T) => boolean): IAsyncOptional<T> {\n  return new AsyncOptional<T>((async () => {\n    const result = await fn()\n    if (isNone(result)) return Nil\n    return result\n  })())\n}\n","import { AsyncOptional, IAsyncOptional, Nil } from '@classes/async-optional'\n\nexport function toOptionalPromisePartial<T>(isNone: (val: T) => boolean): (promise: PromiseLike<T>) => IAsyncOptional<T> {\n  return (promise: PromiseLike<T>) => toOptionalPromise(promise, isNone)\n}\n\nexport function toOptionalPromise<T>(promise: PromiseLike<T>, isNone: (val: T) => boolean): IAsyncOptional<T> {\n  return new AsyncOptional<T>((async () => {\n    const result = await promise\n    if (isNone(result)) return Nil\n    return result\n  })())\n}\n"],"names":["getErrorResult","fn","e","async","getErrorResultAsync","getErrorResultPromise","promise","getResultError","getResultErrorAsync","getResultErrorPromise","getSuccess","getSuccessAsync","getSuccessPromise","getFailure","getFailureAsync","getFailurePromise","isSuccess","isSuccessAsync","isSuccessPromise","isFailure","isFailureAsync","isFailurePromise","getResult","getResultAsync","getResultPromise","getError","syncError","getErrorAsync","err","getErrorPromise","getErrorAsyncIterable","iterable","_","promiseError","__classPrivateFieldGet","receiver","privateMap","has","TypeError","get","__classPrivateFieldSet","value","set","Result","[object Object]","Ok","of","error","Err","super","_value","this","callback","_value_1","defaultValue","toResult","result","AsyncResult","_promise","Promise","resolve","AsyncOk","AsyncErr","then","x","bind","succ","ret","fail","mapper","reject","toResultAsync","toResultPromise","Optional","Some","None","predicate","Error","toOptionalPartial","isNone","toOptional","Nil","Symbol","AsyncOptional","AsyncSome","AsyncNone","toOptionalAsyncPartial","toOptionalAsync","toOptionalPromisePartial","toOptionalPromise"],"mappings":"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"}