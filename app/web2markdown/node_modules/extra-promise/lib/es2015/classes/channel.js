"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelClosedError = exports.Channel = void 0;
const return_style_1 = require("return-style");
const signal_1 = require("./signal");
const signal_group_1 = require("./signal-group");
const _error_1 = require("../shared/error");
const mutex_1 = require("./mutex");
class Channel {
    constructor() {
        this.isClosed = false;
        this.writeLock = new mutex_1.Mutex();
        this.writeSignalGroup = new signal_group_1.SignalGroup();
        this.readSignalGroup = new signal_group_1.SignalGroup();
        this.box = [];
    }
    send(value) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isClosed)
                throw new _error_1.ChannelClosedError();
            const release = yield this.writeLock.acquire();
            const readSignal = new signal_1.Signal();
            this.readSignalGroup.add(readSignal);
            try {
                if (this.isClosed)
                    throw new _error_1.ChannelClosedError();
                this.box.push(value);
                this.writeSignalGroup.emitAll();
                if (yield return_style_1.isFailurePromise(readSignal)) {
                    this.box.pop();
                    throw new _error_1.ChannelClosedError();
                }
            }
            finally {
                this.readSignalGroup.remove(readSignal);
                release();
            }
        });
    }
    receive() {
        return {
            [Symbol.asyncIterator]: () => {
                return {
                    next: () => __awaiter(this, void 0, void 0, function* () {
                        while (this.box.length === 0) {
                            if (this.isClosed)
                                return { done: true, value: undefined };
                            const writeSignal = new signal_1.Signal();
                            this.writeSignalGroup.add(writeSignal);
                            try {
                                if (yield return_style_1.isFailurePromise(writeSignal))
                                    return { done: true, value: undefined };
                            }
                            finally {
                                this.writeSignalGroup.remove(writeSignal);
                            }
                        }
                        const value = this.box.pop();
                        this.readSignalGroup.emitAll();
                        return { done: false, value };
                    })
                };
            }
        };
    }
    close() {
        if (!this.isClosed) {
            this.isClosed = true;
            this.writeSignalGroup.discardAll();
            this.readSignalGroup.discardAll();
        }
    }
}
exports.Channel = Channel;
var _error_2 = require("../shared/error");
Object.defineProperty(exports, "ChannelClosedError", { enumerable: true, get: function () { return _error_2.ChannelClosedError; } });
//# sourceMappingURL=channel.js.map