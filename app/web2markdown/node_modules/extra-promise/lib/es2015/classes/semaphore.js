"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _locked, _count, _awaiting;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Semaphore = void 0;
const signal_1 = require("./signal");
const types_1 = require("@blackglory/types");
const signal_group_1 = require("./signal-group");
class Semaphore {
    constructor(count) {
        _locked.set(this, 0);
        _count.set(this, void 0);
        _awaiting.set(this, new signal_group_1.SignalGroup());
        __classPrivateFieldSet(this, _count, count);
    }
    acquire(handler) {
        if (types_1.isFunction(handler)) {
            (() => __awaiter(this, void 0, void 0, function* () {
                yield this.lock();
                yield handler();
                this.unlock();
            }))();
        }
        else {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                yield this.lock();
                resolve(oneShot(() => this.unlock()));
            }));
        }
    }
    lock() {
        return __awaiter(this, void 0, void 0, function* () {
            while (this.isLocked()) {
                const unlockSignal = new signal_1.Signal();
                __classPrivateFieldGet(this, _awaiting).add(unlockSignal);
                yield unlockSignal;
                __classPrivateFieldGet(this, _awaiting).remove(unlockSignal);
            }
            __classPrivateFieldSet(this, _locked, +__classPrivateFieldGet(this, _locked) + 1);
        });
    }
    unlock() {
        __classPrivateFieldSet(this, _locked, +__classPrivateFieldGet(this, _locked) - 1);
        __classPrivateFieldGet(this, _awaiting).emitAll();
    }
    isLocked() {
        return __classPrivateFieldGet(this, _count) - __classPrivateFieldGet(this, _locked) === 0;
    }
}
exports.Semaphore = Semaphore;
_locked = new WeakMap(), _count = new WeakMap(), _awaiting = new WeakMap();
function oneShot(fn) {
    let used = false;
    return () => {
        if (!used) {
            used = true;
            fn();
        }
    };
}
//# sourceMappingURL=semaphore.js.map