"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelClosedError = exports.BufferedChannel = void 0;
const return_style_1 = require("return-style");
const signal_1 = require("./signal");
const signal_group_1 = require("./signal-group");
const structures_1 = require("@blackglory/structures");
const _error_1 = require("../shared/error");
Object.defineProperty(exports, "ChannelClosedError", { enumerable: true, get: function () { return _error_1.ChannelClosedError; } });
class BufferedChannel {
    constructor(bufferSize) {
        this.bufferSize = bufferSize;
        this.isClosed = false;
        this.enqueueSingalGroup = new signal_group_1.SignalGroup();
        this.dequeueSignalGroup = new signal_group_1.SignalGroup();
        this.buffer = new structures_1.Queue();
    }
    async send(value) {
        if (this.isClosed)
            throw new _error_1.ChannelClosedError();
        while (this.buffer.size === this.bufferSize) {
            const dequeueSignal = new signal_1.Signal();
            this.dequeueSignalGroup.add(dequeueSignal);
            try {
                if (await return_style_1.isFailurePromise(dequeueSignal))
                    throw new _error_1.ChannelClosedError();
            }
            finally {
                this.dequeueSignalGroup.remove(dequeueSignal);
            }
            if (this.isClosed)
                throw new _error_1.ChannelClosedError();
        }
        this.buffer.enqueue(value);
        this.enqueueSingalGroup.emitAll();
    }
    receive() {
        return {
            [Symbol.asyncIterator]: () => {
                return {
                    next: async () => {
                        while (this.buffer.size === 0) {
                            if (this.isClosed)
                                return { done: true, value: undefined };
                            const enqueueSignal = new signal_1.Signal();
                            this.enqueueSingalGroup.add(enqueueSignal);
                            try {
                                if (await return_style_1.isFailurePromise(enqueueSignal))
                                    return { done: true, value: undefined };
                            }
                            finally {
                                this.enqueueSingalGroup.remove(enqueueSignal);
                            }
                        }
                        const value = this.buffer.dequeue();
                        this.dequeueSignalGroup.emitAll();
                        return { done: false, value };
                    }
                };
            }
        };
    }
    close() {
        if (!this.isClosed) {
            this.isClosed = true;
            this.enqueueSingalGroup.discardAll();
            this.dequeueSignalGroup.discardAll();
        }
    }
}
exports.BufferedChannel = BufferedChannel;
//# sourceMappingURL=buffered-channel.js.map