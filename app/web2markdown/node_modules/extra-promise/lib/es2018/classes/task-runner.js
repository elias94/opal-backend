"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var _internalEvents, _queue, _pending, _concurrency, _running, _debounceMicrotask;
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidArgumentError = exports.TaskRunner = void 0;
const debounce_microtask_1 = require("./debounce-microtask");
const structures_1 = require("@blackglory/structures");
const check_concurrency_1 = require("../shared/check-concurrency");
Object.defineProperty(exports, "InvalidArgumentError", { enumerable: true, get: function () { return check_concurrency_1.InvalidArgumentError; } });
const eventemitter3_1 = require("eventemitter3");
const return_style_1 = require("return-style");
class TaskRunner extends eventemitter3_1.EventEmitter {
    constructor(concurrency = Infinity) {
        super();
        _internalEvents.set(this, new eventemitter3_1.EventEmitter());
        _queue.set(this, new structures_1.Queue());
        _pending.set(this, 0);
        _concurrency.set(this, void 0);
        _running.set(this, true);
        _debounceMicrotask.set(this, new debounce_microtask_1.DebounceMicrotask());
        this.setConcurrency(concurrency);
        const consume = () => {
            if (!__classPrivateFieldGet(this, _running))
                return;
            while (__classPrivateFieldGet(this, _pending) < __classPrivateFieldGet(this, _concurrency) && __classPrivateFieldGet(this, _queue).size > 0) {
                const task = __classPrivateFieldGet(this, _queue).dequeue();
                this.run(task);
            }
        };
        __classPrivateFieldGet(this, _internalEvents).on('update', () => {
            if (__classPrivateFieldGet(this, _running))
                __classPrivateFieldGet(this, _debounceMicrotask).queue(consume);
        });
        __classPrivateFieldGet(this, _internalEvents).on('start', (task) => {
            this.emit('started', task);
        });
        __classPrivateFieldGet(this, _internalEvents).on('resolve', (task, result) => {
            this.emit('resolved', task, result);
            if (__classPrivateFieldGet(this, _running))
                __classPrivateFieldGet(this, _debounceMicrotask).queue(consume);
        });
        __classPrivateFieldGet(this, _internalEvents).on('reject', (task, reason) => {
            __classPrivateFieldGet(this, _internalEvents).emit('pause');
            this.emit('rejected', task, reason);
        });
        __classPrivateFieldGet(this, _internalEvents).on('pause', () => {
            __classPrivateFieldSet(this, _running, false);
            __classPrivateFieldGet(this, _debounceMicrotask).cancel(consume);
        });
        __classPrivateFieldGet(this, _internalEvents).on('resume', () => {
            if (!__classPrivateFieldGet(this, _running)) {
                __classPrivateFieldSet(this, _running, true);
                __classPrivateFieldGet(this, _debounceMicrotask).queue(consume);
            }
        });
    }
    setConcurrency(concurrency) {
        check_concurrency_1.checkConcurrency('concurrency', concurrency);
        __classPrivateFieldSet(this, _concurrency, concurrency);
        __classPrivateFieldGet(this, _internalEvents).emit('update');
    }
    push(...tasks) {
        __classPrivateFieldGet(this, _queue).enqueue(...tasks);
        __classPrivateFieldGet(this, _internalEvents).emit('update');
    }
    pause() {
        __classPrivateFieldGet(this, _internalEvents).emit('pause');
    }
    resume() {
        __classPrivateFieldGet(this, _internalEvents).emit('resume');
    }
    clear() {
        __classPrivateFieldGet(this, _queue).empty();
    }
    async run(task) {
        __classPrivateFieldSet(this, _pending, +__classPrivateFieldGet(this, _pending) + 1);
        __classPrivateFieldGet(this, _internalEvents).emit('start', task);
        const result = await return_style_1.toResultAsync(task);
        __classPrivateFieldSet(this, _pending, +__classPrivateFieldGet(this, _pending) - 1);
        if (result.isOk()) {
            __classPrivateFieldGet(this, _internalEvents).emit('resolve', task, result.get());
        }
        else {
            __classPrivateFieldGet(this, _internalEvents).emit('reject', task, return_style_1.getError(() => result.get()));
        }
    }
}
exports.TaskRunner = TaskRunner;
_internalEvents = new WeakMap(), _queue = new WeakMap(), _pending = new WeakMap(), _concurrency = new WeakMap(), _running = new WeakMap(), _debounceMicrotask = new WeakMap();
//# sourceMappingURL=task-runner.js.map