"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _locked, _count, _awaiting;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Semaphore = void 0;
const signal_1 = require("./signal");
const types_1 = require("@blackglory/types");
const signal_group_1 = require("./signal-group");
class Semaphore {
    constructor(count) {
        _locked.set(this, 0);
        _count.set(this, void 0);
        _awaiting.set(this, new signal_group_1.SignalGroup());
        __classPrivateFieldSet(this, _count, count);
    }
    acquire(handler) {
        if (types_1.isFunction(handler)) {
            (async () => {
                await this.lock();
                await handler();
                this.unlock();
            })();
        }
        else {
            return new Promise(async (resolve) => {
                await this.lock();
                resolve(oneShot(() => this.unlock()));
            });
        }
    }
    async lock() {
        while (this.isLocked()) {
            const unlockSignal = new signal_1.Signal();
            __classPrivateFieldGet(this, _awaiting).add(unlockSignal);
            await unlockSignal;
            __classPrivateFieldGet(this, _awaiting).remove(unlockSignal);
        }
        __classPrivateFieldSet(this, _locked, +__classPrivateFieldGet(this, _locked) + 1);
    }
    unlock() {
        __classPrivateFieldSet(this, _locked, +__classPrivateFieldGet(this, _locked) - 1);
        __classPrivateFieldGet(this, _awaiting).emitAll();
    }
    isLocked() {
        return __classPrivateFieldGet(this, _count) - __classPrivateFieldGet(this, _locked) === 0;
    }
}
exports.Semaphore = Semaphore;
_locked = new WeakMap(), _count = new WeakMap(), _awaiting = new WeakMap();
function oneShot(fn) {
    let used = false;
    return () => {
        if (!used) {
            used = true;
            fn();
        }
    };
}
//# sourceMappingURL=semaphore.js.map