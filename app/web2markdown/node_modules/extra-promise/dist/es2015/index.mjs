/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}

var _resolve, _reject, _promise$1;
class Deferred {
    constructor() {
        _resolve.set(this, void 0);
        _reject.set(this, void 0);
        _promise$1.set(this, void 0);
        __classPrivateFieldSet(this, _promise$1, new Promise((resolve, reject) => {
            __classPrivateFieldSet(this, _resolve, resolve);
            __classPrivateFieldSet(this, _reject, reject);
        }));
    }
    get then() {
        return __classPrivateFieldGet(this, _promise$1).then.bind(__classPrivateFieldGet(this, _promise$1));
    }
    resolve(value) {
        __classPrivateFieldGet(this, _resolve).call(this, value);
    }
    reject(reason) {
        __classPrivateFieldGet(this, _reject).call(this, reason);
    }
}
_resolve = new WeakMap(), _reject = new WeakMap(), _promise$1 = new WeakMap();

var _promise, _executor;
class LazyPromise {
    constructor(executor) {
        _promise.set(this, void 0);
        _executor.set(this, void 0);
        __classPrivateFieldSet(this, _executor, executor);
    }
    get then() {
        if (!__classPrivateFieldGet(this, _promise))
            __classPrivateFieldSet(this, _promise, new Promise(__classPrivateFieldGet(this, _executor)));
        return __classPrivateFieldGet(this, _promise).then.bind(__classPrivateFieldGet(this, _promise));
    }
}
_promise = new WeakMap(), _executor = new WeakMap();

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

var customError = createCommonjsModule(function (module, exports) {
exports.CustomError = void 0;
class CustomError extends Error {
    get name() {
        return this.constructor.name;
    }
}
exports.CustomError = CustomError;

});

var expectedError = createCommonjsModule(function (module, exports) {
exports.ExpectedError = void 0;

class ExpectedError extends customError.CustomError {
}
exports.ExpectedError = ExpectedError;

});

var assertionError = createCommonjsModule(function (module, exports) {
exports.AssertionError = void 0;

class AssertionError extends customError.CustomError {
}
exports.AssertionError = AssertionError;

});

var normalize_1 = createCommonjsModule(function (module, exports) {
exports.normalize = void 0;
function normalize(err) {
    var _a;
    return {
        name: err.name,
        message: err.message,
        stack: (_a = err.stack) !== null && _a !== void 0 ? _a : null
    };
}
exports.normalize = normalize;

});

var refute_1 = createCommonjsModule(function (module, exports) {
exports.refute = void 0;

function refute(condition, message) {
    if (condition)
        throw new expectedError.ExpectedError(message);
}
exports.refute = refute;

});

var assert_1 = createCommonjsModule(function (module, exports) {
exports.assert = void 0;

function assert(condition, message) {
    if (!condition)
        throw new assertionError.AssertionError(message);
}
exports.assert = assert;

});

var es2018$5 = createCommonjsModule(function (module, exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};__exportStar(customError, exports);
__exportStar(expectedError, exports);
__exportStar(assertionError, exports);
__exportStar(normalize_1, exports);
__exportStar(refute_1, exports);
__exportStar(assert_1, exports);

});

var _deferred;
class Signal {
    constructor() {
        _deferred.set(this, new Deferred());
    }
    get then() {
        return __classPrivateFieldGet(this, _deferred).then.bind(__classPrivateFieldGet(this, _deferred));
    }
    emit() {
        __classPrivateFieldGet(this, _deferred).resolve();
    }
    discard() {
        Promise.resolve(__classPrivateFieldGet(this, _deferred)).catch(() => { });
        __classPrivateFieldGet(this, _deferred).reject(new SignalDiscarded());
    }
}
_deferred = new WeakMap();
class SignalDiscarded extends es2018$5.CustomError {
}

var _group;
class SignalGroup {
    constructor() {
        _group.set(this, new Set());
    }
    add(signal) {
        __classPrivateFieldGet(this, _group).add(signal);
    }
    remove(signal) {
        __classPrivateFieldGet(this, _group).delete(signal);
    }
    emitAll() {
        for (const signal of __classPrivateFieldGet(this, _group)) {
            signal.emit();
        }
    }
    discardAll() {
        for (const signal of __classPrivateFieldGet(this, _group)) {
            signal.discard();
        }
    }
}
_group = new WeakMap();

var _null = createCommonjsModule(function (module, exports) {
exports.isntNull = exports.isNull = void 0;
function isNull(val) {
    return val === null;
}
exports.isNull = isNull;
function isntNull(val) {
    return !isNull(val);
}
exports.isntNull = isntNull;

});

var _undefined = createCommonjsModule(function (module, exports) {
exports.isntUndefined = exports.isUndefined = void 0;
function isUndefined(val) {
    return val === undefined;
}
exports.isUndefined = isUndefined;
function isntUndefined(val) {
    return !isUndefined(val);
}
exports.isntUndefined = isntUndefined;

});

var asyncIterable = createCommonjsModule(function (module, exports) {
exports.isntAsyncIterable = exports.isAsyncIterable = void 0;


function isAsyncIterable(val) {
    return _null.isntNull(val)
        && _undefined.isntUndefined(val)
        && typeof val[Symbol.asyncIterator] === 'function';
}
exports.isAsyncIterable = isAsyncIterable;
function isntAsyncIterable(val) {
    return !isAsyncIterable(val);
}
exports.isntAsyncIterable = isntAsyncIterable;

});

var string = createCommonjsModule(function (module, exports) {
exports.isntStringObject = exports.isStringObject = exports.isntStringPrimitive = exports.isStringPrimitive = exports.isntString = exports.isString = void 0;
function isString(val) {
    return isStringPrimitive(val) || isStringObject(val);
}
exports.isString = isString;
function isntString(val) {
    return !isString(val);
}
exports.isntString = isntString;
function isStringPrimitive(val) {
    return typeof val === 'string';
}
exports.isStringPrimitive = isStringPrimitive;
function isntStringPrimitive(val) {
    return !isStringPrimitive(val);
}
exports.isntStringPrimitive = isntStringPrimitive;
function isStringObject(val) {
    return typeof val === 'object' && val instanceof String;
}
exports.isStringObject = isStringObject;
function isntStringObject(val) {
    return !isStringObject(val);
}
exports.isntStringObject = isntStringObject;

});

var char$1 = createCommonjsModule(function (module, exports) {
exports.isntCharObject = exports.isCharObject = exports.isntCharPrimitive = exports.isCharPrimitive = exports.isntChar = exports.isChar = void 0;

function isChar(val) {
    return (string.isString(val) || string.isStringObject(val))
        && val.length === 1;
}
exports.isChar = isChar;
function isntChar(val) {
    return !isChar(val);
}
exports.isntChar = isntChar;
function isCharPrimitive(val) {
    return string.isString(val)
        && val.length === 1;
}
exports.isCharPrimitive = isCharPrimitive;
function isntCharPrimitive(val) {
    return !isCharPrimitive(val);
}
exports.isntCharPrimitive = isntCharPrimitive;
function isCharObject(val) {
    return string.isStringObject(val)
        && val.length === 1;
}
exports.isCharObject = isCharObject;
function isntCharObject(val) {
    return !isCharObject(val);
}
exports.isntCharObject = isntCharObject;

});

var falsy$1 = createCommonjsModule(function (module, exports) {
exports.isntFalsy = exports.isFalsy = void 0;
function isFalsy(val) {
    return !val;
}
exports.isFalsy = isFalsy;
function isntFalsy(val) {
    return !isFalsy(val);
}
exports.isntFalsy = isntFalsy;

});

var _function$1 = createCommonjsModule(function (module, exports) {
exports.isntFunction = exports.isFunction = void 0;
function isFunction(val) {
    return typeof val === 'function';
}
exports.isFunction = isFunction;
function isntFunction(val) {
    return !isFunction(val);
}
exports.isntFunction = isntFunction;

});

var iterable = createCommonjsModule(function (module, exports) {
exports.isntIterable = exports.isIterable = void 0;


function isIterable(val) {
    return _null.isntNull(val)
        && _undefined.isntUndefined(val)
        && typeof val[Symbol.iterator] === 'function';
}
exports.isIterable = isIterable;
function isntIterable(val) {
    return !isIterable(val);
}
exports.isntIterable = isntIterable;

});

var rules = createCommonjsModule(function (module, exports) {
exports.getRules = exports.isJSONType = void 0;
const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes = new Set(_jsonTypes);
function isJSONType(x) {
    return typeof x == "string" && jsonTypes.has(x);
}
exports.isJSONType = isJSONType;
function getRules() {
    const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] },
    };
    return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {},
    };
}
exports.getRules = getRules;

});

var applicability = createCommonjsModule(function (module, exports) {
exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
function schemaHasRulesForType({ schema, self }, type) {
    const group = self.RULES.types[type];
    return group && group !== true && shouldUseGroup(schema, group);
}
exports.schemaHasRulesForType = schemaHasRulesForType;
function shouldUseGroup(schema, group) {
    return group.rules.some((rule) => shouldUseRule(schema, rule));
}
exports.shouldUseGroup = shouldUseGroup;
function shouldUseRule(schema, rule) {
    var _a;
    return (schema[rule.keyword] !== undefined || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));
}
exports.shouldUseRule = shouldUseRule;

});

var code$1 = createCommonjsModule(function (module, exports) {
exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
class _CodeOrName {
}
exports._CodeOrName = _CodeOrName;
exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
class Name extends _CodeOrName {
    constructor(s) {
        super();
        if (!exports.IDENTIFIER.test(s))
            throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
    }
    toString() {
        return this.str;
    }
    emptyStr() {
        return false;
    }
    get names() {
        return { [this.str]: 1 };
    }
}
exports.Name = Name;
class _Code extends _CodeOrName {
    constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
    }
    toString() {
        return this.str;
    }
    emptyStr() {
        if (this._items.length > 1)
            return false;
        const item = this._items[0];
        return item === "" || item === '""';
    }
    get str() {
        var _a;
        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, "")));
    }
    get names() {
        var _a;
        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {
            if (c instanceof Name)
                names[c.str] = (names[c.str] || 0) + 1;
            return names;
        }, {})));
    }
}
exports._Code = _Code;
exports.nil = new _Code("");
function _(strs, ...args) {
    const code = [strs[0]];
    let i = 0;
    while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
    }
    return new _Code(code);
}
exports._ = _;
const plus = new _Code("+");
function str(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i = 0;
    while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
    }
    optimize(expr);
    return new _Code(expr);
}
exports.str = str;
function addCodeArg(code, arg) {
    if (arg instanceof _Code)
        code.push(...arg._items);
    else if (arg instanceof Name)
        code.push(arg);
    else
        code.push(interpolate(arg));
}
exports.addCodeArg = addCodeArg;
function optimize(expr) {
    let i = 1;
    while (i < expr.length - 1) {
        if (expr[i] === plus) {
            const res = mergeExprItems(expr[i - 1], expr[i + 1]);
            if (res !== undefined) {
                expr.splice(i - 1, 3, res);
                continue;
            }
            expr[i++] = "+";
        }
        i++;
    }
}
function mergeExprItems(a, b) {
    if (b === '""')
        return a;
    if (a === '""')
        return b;
    if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
            return;
        if (typeof b != "string")
            return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
            return a.slice(0, -1) + b.slice(1);
        return;
    }
    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
    return;
}
function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;
}
exports.strConcat = strConcat;
// TODO do not allow arrays here
function interpolate(x) {
    return typeof x == "number" || typeof x == "boolean" || x === null
        ? x
        : safeStringify(Array.isArray(x) ? x.join(",") : x);
}
function stringify(x) {
    return new _Code(safeStringify(x));
}
exports.stringify = stringify;
function safeStringify(x) {
    return JSON.stringify(x)
        .replace(/\u2028/g, "\\u2028")
        .replace(/\u2029/g, "\\u2029");
}
exports.safeStringify = safeStringify;
function getProperty(key) {
    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;
}
exports.getProperty = getProperty;

});

var scope = createCommonjsModule(function (module, exports) {
exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;

class ValueError extends Error {
    constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
    }
}
var UsedValueState;
(function (UsedValueState) {
    UsedValueState[UsedValueState["Started"] = 0] = "Started";
    UsedValueState[UsedValueState["Completed"] = 1] = "Completed";
})(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));
exports.varKinds = {
    const: new code$1.Name("const"),
    let: new code$1.Name("let"),
    var: new code$1.Name("var"),
};
class Scope {
    constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
    }
    toName(nameOrPrefix) {
        return nameOrPrefix instanceof code$1.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
        return new code$1.Name(this._newName(prefix));
    }
    _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
        var _a, _b;
        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {
            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return (this._names[prefix] = { prefix, index: 0 });
    }
}
exports.Scope = Scope;
class ValueScopeName extends code$1.Name {
    constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = code$1._ `.${new code$1.Name(property)}[${itemIndex}]`;
    }
}
exports.ValueScopeName = ValueScopeName;
const line = code$1._ `\n`;
class ValueScope extends Scope {
    constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code$1.nil };
    }
    get() {
        return this._scope;
    }
    name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
        var _a;
        if (value.ref === undefined)
            throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
            const _name = vs.get(valueKey);
            if (_name)
                return _name;
        }
        else {
            vs = this._values[prefix] = new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
    }
    getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
            return;
        return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
            if (name.scopePath === undefined)
                throw new Error(`CodeGen: name "${name}" has no value`);
            return code$1._ `${scopeName}${name.scopePath}`;
        });
    }
    scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
            if (name.value === undefined)
                throw new Error(`CodeGen: name "${name}" has no value`);
            return name.value.code;
        }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code$1.nil;
        for (const prefix in values) {
            const vs = values[prefix];
            if (!vs)
                continue;
            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());
            vs.forEach((name) => {
                if (nameSet.has(name))
                    return;
                nameSet.set(name, UsedValueState.Started);
                let c = valueCode(name);
                if (c) {
                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
                    code = code$1._ `${code}${def} ${name} = ${c};${this.opts._n}`;
                }
                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {
                    code = code$1._ `${code}${c}${this.opts._n}`;
                }
                else {
                    throw new ValueError(name);
                }
                nameSet.set(name, UsedValueState.Completed);
            });
        }
        return code;
    }
}
exports.ValueScope = ValueScope;

});

var codegen = createCommonjsModule(function (module, exports) {
exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;


var code_2 = code$1;
Object.defineProperty(exports, "_", { enumerable: true, get: function () { return code_2._; } });
Object.defineProperty(exports, "str", { enumerable: true, get: function () { return code_2.str; } });
Object.defineProperty(exports, "strConcat", { enumerable: true, get: function () { return code_2.strConcat; } });
Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return code_2.nil; } });
Object.defineProperty(exports, "getProperty", { enumerable: true, get: function () { return code_2.getProperty; } });
Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return code_2.stringify; } });
Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return code_2.Name; } });
var scope_2 = scope;
Object.defineProperty(exports, "Scope", { enumerable: true, get: function () { return scope_2.Scope; } });
Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function () { return scope_2.ValueScope; } });
Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function () { return scope_2.ValueScopeName; } });
Object.defineProperty(exports, "varKinds", { enumerable: true, get: function () { return scope_2.varKinds; } });
exports.operators = {
    GT: new code$1._Code(">"),
    GTE: new code$1._Code(">="),
    LT: new code$1._Code("<"),
    LTE: new code$1._Code("<="),
    EQ: new code$1._Code("==="),
    NEQ: new code$1._Code("!=="),
    NOT: new code$1._Code("!"),
    OR: new code$1._Code("||"),
    AND: new code$1._Code("&&"),
};
class Node {
    optimizeNodes() {
        return this;
    }
    optimizeNames(_names, _constants) {
        return this;
    }
}
class Def extends Node {
    constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
    }
    render({ es5, _n }) {
        const varKind = es5 ? scope.varKinds.var : this.varKind;
        const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
    }
    optimizeNames(names, constants) {
        if (!names[this.name.str])
            return;
        if (this.rhs)
            this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
    }
    get names() {
        return this.rhs instanceof code$1._CodeOrName ? this.rhs.names : {};
    }
}
class Assign extends Node {
    constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
    }
    render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
    }
    optimizeNames(names, constants) {
        if (this.lhs instanceof code$1.Name && !names[this.lhs.str] && !this.sideEffects)
            return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
    }
    get names() {
        const names = this.lhs instanceof code$1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
    }
}
class Label extends Node {
    constructor(label) {
        super();
        this.label = label;
        this.names = {};
    }
    render({ _n }) {
        return `${this.label}:` + _n;
    }
}
class Break extends Node {
    constructor(label) {
        super();
        this.label = label;
        this.names = {};
    }
    render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
    }
}
class Throw extends Node {
    constructor(error) {
        super();
        this.error = error;
    }
    render({ _n }) {
        return `throw ${this.error};` + _n;
    }
    get names() {
        return this.error.names;
    }
}
class AnyCode extends Node {
    constructor(code) {
        super();
        this.code = code;
    }
    render({ _n }) {
        return `${this.code};` + _n;
    }
    optimizeNodes() {
        return `${this.code}` ? this : undefined;
    }
    optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
    }
    get names() {
        return this.code instanceof code$1._CodeOrName ? this.code.names : {};
    }
}
class ParentNode extends Node {
    constructor(nodes = []) {
        super();
        this.nodes = nodes;
    }
    render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
    }
    optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
            const n = nodes[i].optimizeNodes();
            if (Array.isArray(n))
                nodes.splice(i, 1, ...n);
            else if (n)
                nodes[i] = n;
            else
                nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : undefined;
    }
    optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
            // iterating backwards improves 1-pass optimization
            const n = nodes[i];
            if (n.optimizeNames(names, constants))
                continue;
            subtractNames(names, n.names);
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : undefined;
    }
    get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
    }
}
class BlockNode extends ParentNode {
    render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
    }
}
class Root extends ParentNode {
}
class Else extends BlockNode {
}
Else.kind = "else";
class If extends BlockNode {
    constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
    }
    render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
            code += "else " + this.else.render(opts);
        return code;
    }
    optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
            return this.nodes; // else is ignored here
        let e = this.else;
        if (e) {
            const ns = e.optimizeNodes();
            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
            if (cond === false)
                return e instanceof If ? e : e.nodes;
            if (this.nodes.length)
                return this;
            return new If(not(cond), e instanceof If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
            return undefined;
        return this;
    }
    optimizeNames(names, constants) {
        var _a;
        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
            return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
    }
    get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
            addNames(names, this.else.names);
        return names;
    }
}
If.kind = "if";
class For extends BlockNode {
}
For.kind = "for";
class ForLoop extends For {
    constructor(iteration) {
        super();
        this.iteration = iteration;
    }
    render(opts) {
        return `for(${this.iteration})` + super.render(opts);
    }
    optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
            return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
    }
    get names() {
        return addNames(super.names, this.iteration.names);
    }
}
class ForRange extends For {
    constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
    }
    render(opts) {
        const varKind = opts.es5 ? scope.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
    }
    get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
    }
}
class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
    }
    render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
    }
    optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
            return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
    }
    get names() {
        return addNames(super.names, this.iterable.names);
    }
}
class Func extends BlockNode {
    constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
    }
    render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
    }
}
Func.kind = "func";
class Return extends ParentNode {
    render(opts) {
        return "return " + super.render(opts);
    }
}
Return.kind = "return";
class Try extends BlockNode {
    render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
            code += this.catch.render(opts);
        if (this.finally)
            code += this.finally.render(opts);
        return code;
    }
    optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
    }
    optimizeNames(names, constants) {
        var _a, _b;
        super.optimizeNames(names, constants);
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
    }
    get names() {
        const names = super.names;
        if (this.catch)
            addNames(names, this.catch.names);
        if (this.finally)
            addNames(names, this.finally.names);
        return names;
    }
}
class Catch extends BlockNode {
    constructor(error) {
        super();
        this.error = error;
    }
    render(opts) {
        return `catch(${this.error})` + super.render(opts);
    }
}
Catch.kind = "catch";
class Finally extends BlockNode {
    render(opts) {
        return "finally" + super.render(opts);
    }
}
Finally.kind = "finally";
class CodeGen {
    constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope.Scope({ parent: extScope });
        this._nodes = [new Root()];
    }
    toString() {
        return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(prefix) {
        return this._scope.name(prefix);
    }
    // reserves unique name in the external scope
    scopeName(prefix) {
        return this._extScope.name(prefix);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
        vs.add(name);
        return name;
    }
    getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
        return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== undefined && constant)
            this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
    }
    // `const` declaration (`var` in es5 mode)
    const(nameOrPrefix, rhs, _constant) {
        return this._def(scope.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(nameOrPrefix, rhs, _constant) {
        return this._def(scope.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    // `var` declaration with optional assignment
    var(nameOrPrefix, rhs, _constant) {
        return this._def(scope.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    // assignment code
    assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    // appends passed SafeExpr to code or executes Block
    code(c) {
        if (typeof c == "function")
            c();
        else if (c !== code$1.nil)
            this._leafNode(new AnyCode(c));
        return this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
            if (code.length > 1)
                code.push(",");
            code.push(key);
            if (key !== value || this.opts.es5) {
                code.push(":");
                code$1.addCodeArg(code, value);
            }
        }
        code.push("}");
        return new code$1._Code(code);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
            this.code(thenBody).else().code(elseBody).endIf();
        }
        else if (thenBody) {
            this.code(thenBody).endIf();
        }
        else if (elseBody) {
            throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(condition) {
        return this._elseNode(new If(condition));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
        return this._elseNode(new Else());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
        return this._endBlockNode(If, Else);
    }
    _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
            this.code(forBody).endFor();
        return this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
    }
    // `for` statement for a range of values
    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope.varKinds.var : scope.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(nameOrPrefix, iterable, forBody, varKind = scope.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
            const arr = iterable instanceof code$1.Name ? iterable : this.var("_arr", iterable);
            return this.forRange("_i", 0, code$1._ `${arr}.length`, (i) => {
                this.var(name, code$1._ `${arr}[${i}]`);
                forBody(name);
            });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope.varKinds.var : scope.varKinds.const) {
        if (this.opts.ownProperties) {
            return this.forOf(nameOrPrefix, code$1._ `Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    // end `for` loop
    endFor() {
        return this._endBlockNode(For);
    }
    // `label` statement
    label(label) {
        return this._leafNode(new Label(label));
    }
    // `break` statement
    break(label) {
        return this._leafNode(new Break(label));
    }
    // `return` statement
    return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
            throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
    }
    // `try` statement
    try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
            throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
            const error = this.name("e");
            this._currNode = node.catch = new Catch(error);
            catchCode(error);
        }
        if (finallyCode) {
            this._currNode = node.finally = new Finally();
            this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
    }
    // `throw` statement
    throw(error) {
        return this._leafNode(new Throw(error));
    }
    // start self-balancing block
    block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
            this.code(body).endBlock(nodeCount);
        return this;
    }
    // end the current self-balancing block
    endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === undefined)
            throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {
            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(name, args = code$1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
            this.code(funcBody).endFunc();
        return this;
    }
    // end function definition
    endFunc() {
        return this._endBlockNode(Func);
    }
    optimize(n = 1) {
        while (n-- > 0) {
            this._root.optimizeNodes();
            this._root.optimizeNames(this._root.names, this._constants);
        }
    }
    _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
    }
    _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
    }
    _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || (N2 && n instanceof N2)) {
            this._nodes.pop();
            return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
            throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
    }
    get _root() {
        return this._nodes[0];
    }
    get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
    }
    set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
    }
}
exports.CodeGen = CodeGen;
function addNames(names, from) {
    for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
    return names;
}
function addExprNames(names, from) {
    return from instanceof code$1._CodeOrName ? addNames(names, from.names) : names;
}
function optimizeExpr(expr, names, constants) {
    if (expr instanceof code$1.Name)
        return replaceName(expr);
    if (!canOptimize(expr))
        return expr;
    return new code$1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code$1.Name)
            c = replaceName(c);
        if (c instanceof code$1._Code)
            items.push(...c._items);
        else
            items.push(c);
        return items;
    }, []));
    function replaceName(n) {
        const c = constants[n.str];
        if (c === undefined || names[n.str] !== 1)
            return n;
        delete names[n.str];
        return c;
    }
    function canOptimize(e) {
        return (e instanceof code$1._Code &&
            e._items.some((c) => c instanceof code$1.Name && names[c.str] === 1 && constants[c.str] !== undefined));
    }
}
function subtractNames(names, from) {
    for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
}
function not(x) {
    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : code$1._ `!${par(x)}`;
}
exports.not = not;
const andCode = mappend(exports.operators.AND);
// boolean AND (&&) expression with the passed arguments
function and(...args) {
    return args.reduce(andCode);
}
exports.and = and;
const orCode = mappend(exports.operators.OR);
// boolean OR (||) expression with the passed arguments
function or(...args) {
    return args.reduce(orCode);
}
exports.or = or;
function mappend(op) {
    return (x, y) => (x === code$1.nil ? y : y === code$1.nil ? x : code$1._ `${par(x)} ${op} ${par(y)}`);
}
function par(x) {
    return x instanceof code$1.Name ? x : code$1._ `(${x})`;
}

});

const names = {
    // validation function arguments
    data: new codegen.Name("data"),
    // args passed from referencing schema
    valCxt: new codegen.Name("valCxt"),
    dataPath: new codegen.Name("dataPath"),
    parentData: new codegen.Name("parentData"),
    parentDataProperty: new codegen.Name("parentDataProperty"),
    rootData: new codegen.Name("rootData"),
    dynamicAnchors: new codegen.Name("dynamicAnchors"),
    // function scoped variables
    vErrors: new codegen.Name("vErrors"),
    errors: new codegen.Name("errors"),
    this: new codegen.Name("this"),
    // "globals"
    self: new codegen.Name("self"),
    scope: new codegen.Name("scope"),
};
var _default$v = names;


var names_1 = {
	default: _default$v
};

var errors = createCommonjsModule(function (module, exports) {
exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;


exports.keywordError = {
    message: ({ keyword }) => codegen.str `should pass "${keyword}" keyword validation`,
};
exports.keyword$DataError = {
    message: ({ keyword, schemaType }) => schemaType
        ? codegen.str `"${keyword}" keyword must be ${schemaType} ($data)`
        : codegen.str `"${keyword}" keyword is invalid ($data)`,
};
function reportError(cxt, error = exports.keywordError, overrideAllErrors) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error);
    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {
        addError(gen, errObj);
    }
    else {
        returnErrors(it, codegen._ `[${errObj}]`);
    }
}
exports.reportError = reportError;
function reportExtraError(cxt, error = exports.keywordError) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
    }
}
exports.reportExtraError = reportExtraError;
function resetErrorsCount(gen, errsCount) {
    gen.assign(names_1.default.errors, errsCount);
    gen.if(codegen._ `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign(codegen._ `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
}
exports.resetErrorsCount = resetErrorsCount;
function extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {
    /* istanbul ignore if */
    if (errsCount === undefined)
        throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, codegen._ `${names_1.default.vErrors}[${i}]`);
        gen.if(codegen._ `${err}.dataPath === undefined`, () => gen.assign(codegen._ `${err}.dataPath`, codegen.strConcat(names_1.default.dataPath, it.errorPath)));
        gen.assign(codegen._ `${err}.schemaPath`, codegen.str `${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
            gen.assign(codegen._ `${err}.schema`, schemaValue);
            gen.assign(codegen._ `${err}.data`, data);
        }
    });
}
exports.extendErrors = extendErrors;
function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if(codegen._ `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, codegen._ `[${err}]`), codegen._ `${names_1.default.vErrors}.push(${err})`);
    gen.code(codegen._ `${names_1.default.errors}++`);
}
function returnErrors(it, errs) {
    const { gen, validateName, schemaEnv } = it;
    if (schemaEnv.$async) {
        gen.throw(codegen._ `new ${it.ValidationError}(${errs})`);
    }
    else {
        gen.assign(codegen._ `${validateName}.errors`, errs);
        gen.return(false);
    }
}
const E = {
    keyword: new codegen.Name("keyword"),
    schemaPath: new codegen.Name("schemaPath"),
    params: new codegen.Name("params"),
    propertyName: new codegen.Name("propertyName"),
    message: new codegen.Name("message"),
    schema: new codegen.Name("schema"),
    parentSchema: new codegen.Name("parentSchema"),
    // JTD error properties
    instancePath: new codegen.Name("instancePath"),
};
function errorObjectCode(cxt, error) {
    const { createErrors, opts } = cxt.it;
    if (createErrors === false)
        return codegen._ `{}`;
    return (opts.jtd && !opts.ajvErrors ? jtdErrorObject : ajvErrorObject)(cxt, error);
}
function jtdErrorObject(cxt, { message }) {
    const { gen, keyword, it } = cxt;
    const { errorPath, errSchemaPath, opts } = it;
    const keyValues = [
        [E.instancePath, codegen.strConcat(names_1.default.dataPath, errorPath)],
        [E.schemaPath, codegen.str `${errSchemaPath}/${keyword}`],
    ];
    if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
    }
    return gen.object(...keyValues);
}
function ajvErrorObject(cxt, error) {
    const { gen, keyword, data, schemaValue, it } = cxt;
    const { topSchemaRef, schemaPath, errorPath, errSchemaPath, propertyName, opts } = it;
    const { params, message } = error;
    const keyValues = [
        [E.keyword, keyword],
        [names_1.default.dataPath, codegen.strConcat(names_1.default.dataPath, errorPath)],
        [E.schemaPath, codegen.str `${errSchemaPath}/${keyword}`],
        [E.params, typeof params == "function" ? params(cxt) : params || codegen._ `{}`],
    ];
    if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, codegen._ `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
    }
    return gen.object(...keyValues);
}

});

var boolSchema = createCommonjsModule(function (module, exports) {
exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;



const boolError = {
    message: "boolean schema is false",
};
function topBoolOrEmptySchema(it) {
    const { gen, schema, validateName } = it;
    if (schema === false) {
        falseSchemaError(it, false);
    }
    else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
    }
    else {
        gen.assign(codegen._ `${validateName}.errors`, null);
        gen.return(true);
    }
}
exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
function boolOrEmptySchema(it, valid) {
    const { gen, schema } = it;
    if (schema === false) {
        gen.var(valid, false); // TODO var
        falseSchemaError(it);
    }
    else {
        gen.var(valid, true); // TODO var
    }
}
exports.boolOrEmptySchema = boolOrEmptySchema;
function falseSchemaError(it, overrideAllErrors) {
    const { gen, data } = it;
    // TODO maybe some other interface should be used for non-keyword validation errors...
    const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it,
    };
    errors.reportError(cxt, boolError, overrideAllErrors);
}

});

var defaults = createCommonjsModule(function (module, exports) {
exports.assignDefaults = void 0;


function assignDefaults(it, ty) {
    const { properties, items } = it.schema;
    if (ty === "object" && properties) {
        for (const key in properties) {
            assignDefault(it, key, properties[key].default);
        }
    }
    else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
    }
}
exports.assignDefaults = assignDefaults;
function assignDefault(it, prop, defaultValue) {
    const { gen, compositeRule, data, opts } = it;
    if (defaultValue === undefined)
        return;
    const childData = codegen._ `${data}${codegen.getProperty(prop)}`;
    if (compositeRule) {
        validate.checkStrictMode(it, `default is ignored for: ${childData}`);
        return;
    }
    let condition = codegen._ `${childData} === undefined`;
    if (opts.useDefaults === "empty") {
        condition = codegen._ `${condition} || ${childData} === null || ${childData} === ""`;
    }
    // `${childData} === undefined` +
    // (opts.useDefaults === "empty" ? ` || ${childData} === null || ${childData} === ""` : "")
    gen.if(condition, codegen._ `${childData} = ${codegen.stringify(defaultValue)}`);
}

});

var subschema = createCommonjsModule(function (module, exports) {
exports.applySubschema = exports.Type = void 0;



var Type;
(function (Type) {
    Type[Type["Num"] = 0] = "Num";
    Type[Type["Str"] = 1] = "Str";
})(Type = exports.Type || (exports.Type = {}));
function applySubschema(it, appl, valid) {
    const subschema = getSubschema(it, appl);
    extendSubschemaData(subschema, it, appl);
    extendSubschemaMode(subschema, appl);
    const nextContext = { ...it, ...subschema, items: undefined, props: undefined };
    validate.subschemaCode(nextContext, valid);
    return nextContext;
}
exports.applySubschema = applySubschema;
function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
    if (keyword !== undefined && schema !== undefined) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
    }
    if (keyword !== undefined) {
        const sch = it.schema[keyword];
        return schemaProp === undefined
            ? {
                schema: sch,
                schemaPath: codegen._ `${it.schemaPath}${codegen.getProperty(keyword)}`,
                errSchemaPath: `${it.errSchemaPath}/${keyword}`,
            }
            : {
                schema: sch[schemaProp],
                schemaPath: codegen._ `${it.schemaPath}${codegen.getProperty(keyword)}${codegen.getProperty(schemaProp)}`,
                errSchemaPath: `${it.errSchemaPath}/${keyword}/${util.escapeFragment(schemaProp)}`,
            };
    }
    if (schema !== undefined) {
        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
            throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
            schema,
            schemaPath,
            topSchemaRef,
            errSchemaPath,
        };
    }
    throw new Error('either "keyword" or "schema" must be passed');
}
function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
    if (data !== undefined && dataProp !== undefined) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
    }
    const { gen } = it;
    if (dataProp !== undefined) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", codegen._ `${it.data}${codegen.getProperty(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = codegen.str `${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = codegen._ `${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
    }
    if (data !== undefined) {
        const nextData = data instanceof codegen.Name ? data : gen.let("data", data, true); // replaceable if used once?
        dataContextProps(nextData);
        if (propertyName !== undefined)
            subschema.propertyName = propertyName;
        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr
    }
    if (dataTypes)
        subschema.dataTypes = dataTypes;
    function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
    }
}
function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
    if (compositeRule !== undefined)
        subschema.compositeRule = compositeRule;
    if (createErrors !== undefined)
        subschema.createErrors = createErrors;
    if (allErrors !== undefined)
        subschema.allErrors = allErrors;
    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited
    subschema.jtdMetadata = jtdMetadata; // not inherited
}
function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
    // let path
    if (dataProp instanceof codegen.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax
            ? isNumber
                ? codegen._ `"[" + ${dataProp} + "]"`
                : codegen._ `"['" + ${dataProp} + "']"`
            : isNumber
                ? codegen._ `"/" + ${dataProp}`
                : codegen._ `"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`; // TODO maybe use global escapePointer
    }
    return jsPropertySyntax ? codegen.getProperty(dataProp).toString() : "/" + util.escapeJsonPointer(dataProp);
}

});

var code = createCommonjsModule(function (module, exports) {
exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;




function checkReportMissingProp(cxt, prop) {
    const { gen, data, it } = cxt;
    gen.if(noPropertyInData(data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: codegen._ `${prop}` }, true);
        cxt.error();
    });
}
exports.checkReportMissingProp = checkReportMissingProp;
function checkMissingProp({ data, it: { opts } }, properties, missing) {
    return codegen.or(...properties.map((prop) => codegen._ `${noPropertyInData(data, prop, opts.ownProperties)} && (${missing} = ${prop})`));
}
exports.checkMissingProp = checkMissingProp;
function reportMissingProp(cxt, missing) {
    cxt.setParams({ missingProperty: missing }, true);
    cxt.error();
}
exports.reportMissingProp = reportMissingProp;
function isOwnProperty(data, property) {
    return codegen._ `Object.prototype.hasOwnProperty.call(${data}, ${property})`;
}
function propertyInData(data, property, ownProperties) {
    const cond = codegen._ `${data}${codegen.getProperty(property)} !== undefined`;
    return ownProperties ? codegen._ `${cond} && ${isOwnProperty(data, property)}` : cond;
}
exports.propertyInData = propertyInData;
function noPropertyInData(data, property, ownProperties) {
    const cond = codegen._ `${data}${codegen.getProperty(property)} === undefined`;
    return ownProperties ? codegen._ `${cond} || !${isOwnProperty(data, property)}` : cond;
}
exports.noPropertyInData = noPropertyInData;
function allSchemaProperties(schemaMap) {
    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
}
exports.allSchemaProperties = allSchemaProperties;
function schemaProperties(it, schemaMap) {
    return allSchemaProperties(schemaMap).filter((p) => !util.alwaysValidSchema(it, schemaMap[p]));
}
exports.schemaProperties = schemaProperties;
function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
    const dataAndSchema = passSchema ? codegen._ `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
    const valCxt = [
        [names_1.default.dataPath, codegen.strConcat(names_1.default.dataPath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData],
    ];
    if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
    const args = codegen._ `${dataAndSchema}, ${gen.object(...valCxt)}`;
    return context !== codegen.nil ? codegen._ `${func}.call(${context}, ${args})` : codegen._ `${func}(${args})`;
}
exports.callValidateCode = callValidateCode;
function usePattern(gen, pattern) {
    return gen.scopeValue("pattern", {
        key: pattern,
        ref: new RegExp(pattern, "u"),
        code: codegen._ `new RegExp(${pattern}, "u")`,
    });
}
exports.usePattern = usePattern;
function validateArray(cxt) {
    const { gen, data, keyword, it } = cxt;
    const valid = gen.name("valid");
    if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
    }
    gen.var(valid, true);
    validateItems(() => gen.break());
    return valid;
    function validateItems(notValid) {
        const len = gen.const("len", codegen._ `${data}.length`);
        gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
                keyword,
                dataProp: i,
                dataPropType: subschema.Type.Num,
            }, valid);
            gen.if(codegen.not(valid), notValid);
        });
    }
}
exports.validateArray = validateArray;
function validateUnion(cxt) {
    const { gen, schema, keyword, it } = cxt;
    /* istanbul ignore if */
    if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
    const alwaysValid = schema.some((sch) => util.alwaysValidSchema(it, sch));
    if (alwaysValid && !it.opts.unevaluated)
        return;
    const valid = gen.let("valid", false);
    const schValid = gen.name("_valid");
    gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
            keyword,
            schemaProp: i,
            compositeRule: true,
        }, schValid);
        gen.assign(valid, codegen._ `${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)
        // or if all properties and items were evaluated (it.props === true && it.items === true)
        if (!merged)
            gen.if(codegen.not(valid));
    }));
    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
}
exports.validateUnion = validateUnion;

});

var keyword = createCommonjsModule(function (module, exports) {
exports.keywordCode = void 0;





function keywordCode(it, keyword, def, ruleType) {
    const cxt = new context.default(it, def, keyword);
    if ("code" in def) {
        def.code(cxt, ruleType);
    }
    else if (cxt.$data && def.validate) {
        funcKeywordCode(cxt, def);
    }
    else if ("macro" in def) {
        macroKeywordCode(cxt, def);
    }
    else if (def.compile || def.validate) {
        funcKeywordCode(cxt, def);
    }
}
exports.keywordCode = keywordCode;
function macroKeywordCode(cxt, def) {
    const { gen, keyword, schema, parentSchema, it } = cxt;
    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
    const schemaRef = useKeyword(gen, keyword, macroSchema);
    if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
    const valid = gen.name("valid");
    cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true,
    }, valid);
    cxt.pass(valid, () => cxt.error(true));
}
function funcKeywordCode(cxt, def) {
    var _a;
    const { gen, keyword, schema, parentSchema, $data, it } = cxt;
    checkAsync(it, def);
    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
    const validateRef = useKeyword(gen, keyword, validate);
    const valid = gen.let("valid");
    cxt.block$data(valid, validateKeyword);
    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
    function validateKeyword() {
        if (def.errors === false) {
            assignValid();
            if (def.modifying)
                modifyData(cxt);
            reportErrs(() => cxt.error());
        }
        else {
            const ruleErrs = def.async ? validateAsync() : validateSync();
            if (def.modifying)
                modifyData(cxt);
            reportErrs(() => addErrs(cxt, ruleErrs));
        }
    }
    function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid(codegen._ `await `), (e) => gen.assign(valid, false).if(codegen._ `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, codegen._ `${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
    }
    function validateSync() {
        const validateErrs = codegen._ `${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen.nil);
        return validateErrs;
    }
    function assignValid(_await = def.async ? codegen._ `await ` : codegen.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !(("compile" in def && !$data) || def.schema === false);
        gen.assign(valid, codegen._ `${_await}${code.callValidateCode(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
    }
    function reportErrs(errors) {
        var _a;
        gen.if(codegen.not((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);
    }
}
function modifyData(cxt) {
    const { gen, data, it } = cxt;
    gen.if(it.parentData, () => gen.assign(data, codegen._ `${it.parentData}[${it.parentDataProperty}]`));
}
function addErrs(cxt, errs) {
    const { gen } = cxt;
    gen.if(codegen._ `Array.isArray(${errs})`, () => {
        gen
            .assign(names_1.default.vErrors, codegen._ `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)
            .assign(names_1.default.errors, codegen._ `${names_1.default.vErrors}.length`);
        errors.extendErrors(cxt);
    }, () => cxt.error());
}
function checkAsync({ schemaEnv }, def) {
    if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
}
function useKeyword(gen, keyword, result) {
    if (result === undefined)
        throw new Error(`keyword "${keyword}" failed to compile`);
    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: codegen.stringify(result) });
}

});

var iterate = createCommonjsModule(function (module, exports) {
exports.schemaKeywords = void 0;








function schemaKeywords(it, types, typeErrors, errsCount) {
    const { gen, schema, data, allErrors, opts, self } = it;
    const { RULES } = self;
    if (schema.$ref && (opts.ignoreKeywordsWithRef || !util.schemaHasRulesButRef(schema, RULES))) {
        gen.block(() => keyword.keywordCode(it, "$ref", RULES.all.$ref.definition)); // TODO typecast
        return;
    }
    if (!opts.jtd)
        checkStrictTypes(it, types);
    gen.block(() => {
        for (const group of RULES.rules)
            groupKeywords(group);
        groupKeywords(RULES.post);
    });
    function groupKeywords(group) {
        if (!applicability.shouldUseGroup(schema, group))
            return;
        if (group.type) {
            gen.if(dataType.checkDataType(group.type, data, opts.strict));
            iterateKeywords(it, group);
            if (types.length === 1 && types[0] === group.type && typeErrors) {
                gen.else();
                dataType.reportTypeError(it);
            }
            gen.endIf();
        }
        else {
            iterateKeywords(it, group);
        }
        // TODO make it "ok" call?
        if (!allErrors)
            gen.if(codegen._ `${names_1.default.errors} === ${errsCount || 0}`);
    }
}
exports.schemaKeywords = schemaKeywords;
function iterateKeywords(it, group) {
    const { gen, schema, opts: { useDefaults }, } = it;
    if (useDefaults)
        defaults.assignDefaults(it, group.type);
    gen.block(() => {
        for (const rule of group.rules) {
            if (applicability.shouldUseRule(schema, rule)) {
                keyword.keywordCode(it, rule.keyword, rule.definition, group.type);
            }
        }
    });
}
function checkStrictTypes(it, types) {
    if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
    checkContextTypes(it, types);
    if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
    checkKeywordTypes(it, it.dataTypes);
}
function checkContextTypes(it, types) {
    if (!types.length)
        return;
    if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
    }
    types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
            strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
    });
    it.dataTypes = it.dataTypes.filter((t) => includesType(types, t));
}
function checkMultipleTypes(it, ts) {
    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
    }
}
function checkKeywordTypes(it, ts) {
    const rules = it.self.RULES.all;
    for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && applicability.shouldUseRule(it.schema, rule)) {
            const { type } = rule.definition;
            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
                strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
            }
        }
    }
}
function hasApplicableType(schTs, kwdT) {
    return schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"));
}
function includesType(ts, t) {
    return ts.includes(t) || (t === "integer" && ts.includes("number"));
}
function strictTypesError(it, msg) {
    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
    msg += ` at "${schemaPath}" (strictTypes)`;
    validate.checkStrictMode(it, msg, it.opts.strictTypes);
}

});

// do not edit .js files directly - edit src/index.jst



var fastDeepEqual = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};

var jsonSchemaTraverse = createCommonjsModule(function (module) {

var traverse = module.exports = function (schema, opts, cb) {
  // Legacy support for v0.3.1 and earlier.
  if (typeof opts == 'function') {
    cb = opts;
    opts = {};
  }

  cb = opts.cb || cb;
  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
  var post = cb.post || function() {};

  _traverse(opts, pre, post, schema, '', schema);
};


traverse.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};

traverse.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};

traverse.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};

traverse.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};


function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse.arrayKeywords) {
          for (var i=0; i<sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse.propsKeywords) {
        if (sch && typeof sch == 'object') {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}


function escapeJsonPtr(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}
});

/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */

var uri_all = createCommonjsModule(function (module, exports) {
(function (global, factory) {
	factory(exports) ;
}(commonjsGlobal, (function (exports) {
function merge() {
    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
    }

    if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join('');
    } else {
        return sets[0];
    }
}
function subexp(str) {
    return "(?:" + str + ")";
}
function typeOf(o) {
    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
}
function toUpperCase(str) {
    return str.toUpperCase();
}
function toArray(obj) {
    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
}
function assign(target, source) {
    var obj = target;
    if (source) {
        for (var key in source) {
            obj[key] = source[key];
        }
    }
    return obj;
}

function buildExps(isIRI) {
    var ALPHA$$ = "[A-Za-z]",
        DIGIT$$ = "[0-9]",
        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
        PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
        //expanded
    GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
        SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
        UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
        //subset, excludes bidi control characters
    IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
        //subset
    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
        subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
        subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*");
        var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
        //relaxed parsing rules
    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
        H16$ = subexp(HEXDIG$$ + "{1,4}"),
        LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
        //                           6( h16 ":" ) ls32
    IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
        //                      "::" 5( h16 ":" ) ls32
    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
        //[               h16 ] "::" 4( h16 ":" ) ls32
    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
        //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
        //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
        //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
        //[ *4( h16 ":" ) h16 ] "::"              ls32
    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
        //[ *5( h16 ":" ) h16 ] "::"              h16
    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
        //[ *6( h16 ":" ) h16 ] "::"
    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+");
        //RFC 6874, with relaxed parsing rules
    subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+");
        //RFC 6874
    subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*");
        var PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]"));
        subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+");
        subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*");
    return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
    };
}
var URI_PROTOCOL = buildExps(false);

var IRI_PROTOCOL = buildExps(true);

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/** Highest positive signed 32-bit float value */

var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'

/** Regular expressions */
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
var errors = {
	'overflow': 'Overflow: input needs wider integers to process',
	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
	'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error$1(type) {
	throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
	var result = [];
	var length = array.length;
	while (length--) {
		result[length] = fn(array[length]);
	}
	return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
	var parts = string.split('@');
	var result = '';
	if (parts.length > 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to `@`) intact.
		result = parts[0] + '@';
		string = parts[1];
	}
	// Avoid `split(regex)` for IE8 compatibility. See #17.
	string = string.replace(regexSeparators, '\x2E');
	var labels = string.split('.');
	var encoded = map(labels, fn).join('.');
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	while (counter < length) {
		var value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// It's a high surrogate, and there is a next character.
			var extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) {
				// Low surrogate.
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// It's an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
var ucs2encode = function ucs2encode(array) {
	return String.fromCodePoint.apply(String, toConsumableArray(array));
};

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
var basicToDigit = function basicToDigit(codePoint) {
	if (codePoint - 0x30 < 0x0A) {
		return codePoint - 0x16;
	}
	if (codePoint - 0x41 < 0x1A) {
		return codePoint - 0x41;
	}
	if (codePoint - 0x61 < 0x1A) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
var digitToBasic = function digitToBasic(digit, flag) {
	//  0..25 map to ASCII a..z or A..Z
	// 26..35 map to ASCII 0..9
	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
var adapt = function adapt(delta, numPoints, firstTime) {
	var k = 0;
	delta = firstTime ? floor(delta / damp) : delta >> 1;
	delta += floor(delta / numPoints);
	for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
var decode = function decode(input) {
	// Don't use UCS-2.
	var output = [];
	var inputLength = input.length;
	var i = 0;
	var n = initialN;
	var bias = initialBias;

	// Handle the basic code points: let `basic` be the number of input code
	// points before the last delimiter, or `0` if there is none, then copy
	// the first basic code points to the output.

	var basic = input.lastIndexOf(delimiter);
	if (basic < 0) {
		basic = 0;
	}

	for (var j = 0; j < basic; ++j) {
		// if it's not a basic code point
		if (input.charCodeAt(j) >= 0x80) {
			error$1('not-basic');
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

		// `index` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into `delta`,
		// which gets added to `i`. The overflow checking is easier
		// if we increase `i` as we go, then subtract off its starting
		// value at the end to obtain `delta`.
		var oldi = i;
		for (var w = 1, k = base;; /* no condition */k += base) {

			if (index >= inputLength) {
				error$1('invalid-input');
			}

			var digit = basicToDigit(input.charCodeAt(index++));

			if (digit >= base || digit > floor((maxInt - i) / w)) {
				error$1('overflow');
			}

			i += digit * w;
			var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

			if (digit < t) {
				break;
			}

			var baseMinusT = base - t;
			if (w > floor(maxInt / baseMinusT)) {
				error$1('overflow');
			}

			w *= baseMinusT;
		}

		var out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// `i` was supposed to wrap around from `out` to `0`,
		// incrementing `n` each time, so we'll fix that now:
		if (floor(i / out) > maxInt - n) {
			error$1('overflow');
		}

		n += floor(i / out);
		i %= out;

		// Insert `n` at position `i` of the output.
		output.splice(i++, 0, n);
	}

	return String.fromCodePoint.apply(String, output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
var encode = function encode(input) {
	var output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	var inputLength = input.length;

	// Initialize the state.
	var n = initialN;
	var delta = 0;
	var bias = initialBias;

	// Handle the basic code points.
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var _currentValue2 = _step.value;

			if (_currentValue2 < 0x80) {
				output.push(stringFromCharCode(_currentValue2));
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	var basicLength = output.length;
	var handledCPCount = basicLength;

	// `handledCPCount` is the number of code points that have been handled;
	// `basicLength` is the number of basic code points.

	// Finish the basic string with a delimiter unless it's empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount < inputLength) {

		// All non-basic code points < n have been handled already. Find the next
		// larger one:
		var m = maxInt;
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var currentValue = _step2.value;

				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow.
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		var handledCPCountPlusOne = handledCPCount + 1;
		if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
			error$1('overflow');
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;

		try {
			for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var _currentValue = _step3.value;

				if (_currentValue < n && ++delta > maxInt) {
					error$1('overflow');
				}
				if (_currentValue == n) {
					// Represent delta as a generalized variable-length integer.
					var q = delta;
					for (var k = base;; /* no condition */k += base) {
						var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						var qMinusT = q - t;
						var baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 && _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}

		++delta;
		++n;
	}
	return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
var toUnicode = function toUnicode(input) {
	return mapDomain(input, function (string) {
		return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
	});
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
var toASCII = function toASCII(input) {
	return mapDomain(input, function (string) {
		return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
	});
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
var punycode = {
	/**
  * A string representing the current Punycode.js version number.
  * @memberOf punycode
  * @type String
  */
	'version': '2.1.0',
	/**
  * An object of methods to convert from JavaScript's internal character
  * representation (UCS-2) to Unicode code points, and back.
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode
  * @type Object
  */
	'ucs2': {
		'decode': ucs2decode,
		'encode': ucs2encode
	},
	'decode': decode,
	'encode': encode,
	'toASCII': toASCII,
	'toUnicode': toUnicode
};

/**
 * URI.js
 *
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/uri-js
 */
/**
 * Copyright 2011 Gary Court. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court.
 */
var SCHEMES = {};
function pctEncChar(chr) {
    var c = chr.charCodeAt(0);
    var e = void 0;
    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
    return e;
}
function pctDecChars(str) {
    var newStr = "";
    var i = 0;
    var il = str.length;
    while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
        } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
                var c2 = parseInt(str.substr(i + 4, 2), 16);
                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
                newStr += str.substr(i, 6);
            }
            i += 6;
        } else if (c >= 224) {
            if (il - i >= 9) {
                var _c = parseInt(str.substr(i + 4, 2), 16);
                var c3 = parseInt(str.substr(i + 7, 2), 16);
                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
                newStr += str.substr(i, 9);
            }
            i += 9;
        } else {
            newStr += str.substr(i, 3);
            i += 3;
        }
    }
    return newStr;
}
function _normalizeComponentEncoding(components, protocol) {
    function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
    }
    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    return components;
}

function _stripLeadingZeros(str) {
    return str.replace(/^0*(.*)/, "$1") || "0";
}
function _normalizeIPv4(host, protocol) {
    var matches = host.match(protocol.IPV4ADDRESS) || [];

    var _matches = slicedToArray(matches, 2),
        address = _matches[1];

    if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
    } else {
        return host;
    }
}
function _normalizeIPv6(host, protocol) {
    var matches = host.match(protocol.IPV6ADDRESS) || [];

    var _matches2 = slicedToArray(matches, 3),
        address = _matches2[1],
        zone = _matches2[2];

    if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
            last = _address$toLowerCase$2[0],
            first = _address$toLowerCase$2[1];

        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
        }
        if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function (acc, field, index) {
            if (!field || field === "0") {
                var lastLongest = acc[acc.length - 1];
                if (lastLongest && lastLongest.index + lastLongest.length === index) {
                    lastLongest.length++;
                } else {
                    acc.push({ index: index, length: 1 });
                }
            }
            return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function (a, b) {
            return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
            newHost = fields.join(":");
        }
        if (zone) {
            newHost += "%" + zone;
        }
        return newHost;
    } else {
        return host;
    }
}
var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
function parse(uriString) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var components = {};
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
    var matches = uriString.match(URI_PARSE);
    if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
            //store each component
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            //fix port number
            if (isNaN(components.port)) {
                components.port = matches[5];
            }
        } else {
            //IE FIX for improper RegExp matching
            //store each component
            components.scheme = matches[1] || undefined;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
            //fix port number
            if (isNaN(components.port)) {
                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
            }
        }
        if (components.host) {
            //normalize IP hosts
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        //determine reference type
        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
            components.reference = "same-document";
        } else if (components.scheme === undefined) {
            components.reference = "relative";
        } else if (components.fragment === undefined) {
            components.reference = "absolute";
        } else {
            components.reference = "uri";
        }
        //check for reference errors
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        //find scheme handler
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        //check if scheme can't handle IRIs
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            //if host component is a domain name
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                }
            }
            //convert IRI -> URI
            _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
            //normalize encodings
            _normalizeComponentEncoding(components, protocol);
        }
        //perform scheme specific parsing
        if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
        }
    } else {
        components.error = components.error || "URI can not be parsed.";
    }
    return components;
}

function _recomposeAuthority(components, options) {
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    if (components.userinfo !== undefined) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
    }
    if (components.host !== undefined) {
        //normalize IP hosts, add brackets and escape zone separator for IPv6
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
    }
    if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
    }
    return uriTokens.length ? uriTokens.join("") : undefined;
}

var RDS1 = /^\.\.?\//;
var RDS2 = /^\/\.(\/|$)/;
var RDS3 = /^\/\.\.(\/|$)/;
var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
function removeDotSegments(input) {
    var output = [];
    while (input.length) {
        if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
        } else if (input === "." || input === "..") {
            input = "";
        } else {
            var im = input.match(RDS5);
            if (im) {
                var s = im[0];
                input = input.slice(s.length);
                output.push(s);
            } else {
                throw new Error("Unexpected dot segment condition");
            }
        }
    }
    return output.join("");
}

function serialize(components) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    //find scheme handler
    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
    //perform scheme specific serialization
    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
    if (components.host) {
        //if host component is an IPv6 address
        if (protocol.IPV6ADDRESS.test(components.host)) ;
        //TODO: normalize IPv6 address as per RFC 5952

        //if host component is a domain name
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
                //convert IDN via punycode
                try {
                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
            }
    }
    //normalize encoding
    _normalizeComponentEncoding(components, protocol);
    if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
    }
    var authority = _recomposeAuthority(components, options);
    if (authority !== undefined) {
        if (options.reference !== "suffix") {
            uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
        }
    }
    if (components.path !== undefined) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
        }
        if (authority === undefined) {
            s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
        }
        uriTokens.push(s);
    }
    if (components.query !== undefined) {
        uriTokens.push("?");
        uriTokens.push(components.query);
    }
    if (components.fragment !== undefined) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
    }
    return uriTokens.join(""); //merge tokens into a string
}

function resolveComponents(base, relative) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var skipNormalization = arguments[3];

    var target = {};
    if (!skipNormalization) {
        base = parse(serialize(base, options), options); //normalize base components
        relative = parse(serialize(relative, options), options); //normalize relative components
    }
    options = options || {};
    if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        //target.authority = relative.authority;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
    } else {
        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
        } else {
            if (!relative.path) {
                target.path = base.path;
                if (relative.query !== undefined) {
                    target.query = relative.query;
                } else {
                    target.query = base.query;
                }
            } else {
                if (relative.path.charAt(0) === "/") {
                    target.path = removeDotSegments(relative.path);
                } else {
                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
                        target.path = "/" + relative.path;
                    } else if (!base.path) {
                        target.path = relative.path;
                    } else {
                        target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                    }
                    target.path = removeDotSegments(target.path);
                }
                target.query = relative.query;
            }
            //target.authority = base.authority;
            target.userinfo = base.userinfo;
            target.host = base.host;
            target.port = base.port;
        }
        target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
}

function resolve(baseURI, relativeURI, options) {
    var schemelessOptions = assign({ scheme: 'null' }, options);
    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
}

function normalize(uri, options) {
    if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
    } else if (typeOf(uri) === "object") {
        uri = parse(serialize(uri, options), options);
    }
    return uri;
}

function equal(uriA, uriB, options) {
    if (typeof uriA === "string") {
        uriA = serialize(parse(uriA, options), options);
    } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
    }
    if (typeof uriB === "string") {
        uriB = serialize(parse(uriB, options), options);
    } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
    }
    return uriA === uriB;
}

function escapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
}

function unescapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
}

var handler = {
    scheme: "http",
    domainHost: true,
    parse: function parse(components, options) {
        //report missing host
        if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
    },
    serialize: function serialize(components, options) {
        var secure = String(components.scheme).toLowerCase() === "https";
        //normalize the default port
        if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = undefined;
        }
        //normalize the empty path
        if (!components.path) {
            components.path = "/";
        }
        //NOTE: We do not parse query strings for HTTP URIs
        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
        //and not the HTTP spec.
        return components;
    }
};

var handler$1 = {
    scheme: "https",
    domainHost: handler.domainHost,
    parse: handler.parse,
    serialize: handler.serialize
};

function isSecure(wsComponents) {
    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
}
//RFC 6455
var handler$2 = {
    scheme: "ws",
    domainHost: true,
    parse: function parse(components, options) {
        var wsComponents = components;
        //indicate if the secure flag is set
        wsComponents.secure = isSecure(wsComponents);
        //construct resouce name
        wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');
        wsComponents.path = undefined;
        wsComponents.query = undefined;
        return wsComponents;
    },
    serialize: function serialize(wsComponents, options) {
        //normalize the default port
        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = undefined;
        }
        //ensure scheme matches secure flag
        if (typeof wsComponents.secure === 'boolean') {
            wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';
            wsComponents.secure = undefined;
        }
        //reconstruct path from resource name
        if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split('?'),
                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),
                path = _wsComponents$resourc2[0],
                query = _wsComponents$resourc2[1];

            wsComponents.path = path && path !== '/' ? path : undefined;
            wsComponents.query = query;
            wsComponents.resourceName = undefined;
        }
        //forbid fragment component
        wsComponents.fragment = undefined;
        return wsComponents;
    }
};

var handler$3 = {
    scheme: "wss",
    domainHost: handler$2.domainHost,
    parse: handler$2.parse,
    serialize: handler$2.serialize
};

var O = {};
//RFC 3986
var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + ("\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" ) + "]";
var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
//const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
//const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
//const VCHAR$$ = "[\\x21-\\x7E]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
//const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
//const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
//const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
var UNRESERVED = new RegExp(UNRESERVED$$, "g");
var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
var NOT_HFVALUE = NOT_HFNAME;
function decodeUnreserved(str) {
    var decStr = pctDecChars(str);
    return !decStr.match(UNRESERVED) ? str : decStr;
}
var handler$4 = {
    scheme: "mailto",
    parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = undefined;
        if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
                var hfield = hfields[x].split("=");
                switch (hfield[0]) {
                    case "to":
                        var toAddrs = hfield[1].split(",");
                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                            to.push(toAddrs[_x]);
                        }
                        break;
                    case "subject":
                        mailtoComponents.subject = unescapeComponent(hfield[1], options);
                        break;
                    case "body":
                        mailtoComponents.body = unescapeComponent(hfield[1], options);
                        break;
                    default:
                        unknownHeaders = true;
                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                        break;
                }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
        }
        mailtoComponents.query = undefined;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                } catch (e) {
                    mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                }
            } else {
                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
        }
        return mailtoComponents;
    },
    serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
                var toAddr = String(to[x]);
                var atIdx = toAddr.lastIndexOf("@");
                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                var domain = toAddr.slice(atIdx + 1);
                //convert IDN via punycode
                try {
                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                } catch (e) {
                    components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
                to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
            if (headers[name] !== O[name]) {
                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
        }
        if (fields.length) {
            components.query = fields.join("&");
        }
        return components;
    }
};

var URN_PARSE = /^([^\:]+)\:(.*)/;
//RFC 2141
var handler$5 = {
    scheme: "urn",
    parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = undefined;
            if (schemeHandler) {
                urnComponents = schemeHandler.parse(urnComponents, options);
            }
        } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
    },
    serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
    }
};

var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
//RFC 4122
var handler$6 = {
    scheme: "urn:uuid",
    parse: function parse(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = undefined;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
    },
    serialize: function serialize(uuidComponents, options) {
        var urnComponents = uuidComponents;
        //normalize UUID
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
    }
};

SCHEMES[handler.scheme] = handler;
SCHEMES[handler$1.scheme] = handler$1;
SCHEMES[handler$2.scheme] = handler$2;
SCHEMES[handler$3.scheme] = handler$3;
SCHEMES[handler$4.scheme] = handler$4;
SCHEMES[handler$5.scheme] = handler$5;
SCHEMES[handler$6.scheme] = handler$6;

exports.SCHEMES = SCHEMES;
exports.pctEncChar = pctEncChar;
exports.pctDecChars = pctDecChars;
exports.parse = parse;
exports.removeDotSegments = removeDotSegments;
exports.serialize = serialize;
exports.resolveComponents = resolveComponents;
exports.resolve = resolve;
exports.normalize = normalize;
exports.equal = equal;
exports.escapeComponent = escapeComponent;
exports.unescapeComponent = unescapeComponent;

Object.defineProperty(exports, '__esModule', { value: true });

})));

});

var resolve = createCommonjsModule(function (module, exports) {
exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;




// TODO refactor to use keyword definitions
const SIMPLE_INLINED = new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const",
]);
function inlineRef(schema, limit = true) {
    if (typeof schema == "boolean")
        return true;
    if (limit === true)
        return !hasRef(schema);
    if (!limit)
        return false;
    return countKeys(schema) <= limit;
}
exports.inlineRef = inlineRef;
const REF_KEYWORDS = new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor",
]);
function hasRef(schema) {
    for (const key in schema) {
        if (REF_KEYWORDS.has(key))
            return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
            return true;
        if (typeof sch == "object" && hasRef(sch))
            return true;
    }
    return false;
}
function countKeys(schema) {
    let count = 0;
    for (const key in schema) {
        if (key === "$ref")
            return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
            continue;
        if (typeof schema[key] == "object") {
            util.eachItem(schema[key], (sch) => (count += countKeys(sch)));
        }
        if (count === Infinity)
            return Infinity;
    }
    return count;
}
function getFullPath(id = "", normalize) {
    if (normalize !== false)
        id = normalizeId(id);
    const p = uri_all.parse(id);
    return _getFullPath(p);
}
exports.getFullPath = getFullPath;
function _getFullPath(p) {
    return uri_all.serialize(p).split("#")[0] + "#";
}
exports._getFullPath = _getFullPath;
const TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
}
exports.normalizeId = normalizeId;
function resolveUrl(baseId, id) {
    id = normalizeId(id);
    return uri_all.resolve(baseId, id);
}
exports.resolveUrl = resolveUrl;
const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs(schema) {
    if (typeof schema == "boolean")
        return {};
    const schemaId = normalizeId(schema.$id);
    const baseIds = { "": schemaId };
    const pathPrefix = getFullPath(schemaId, false);
    const localRefs = {};
    const schemaRefs = new Set();
    jsonSchemaTraverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === undefined)
            return;
        const fullPath = pathPrefix + jsonPtr;
        let baseId = baseIds[parentJsonPtr];
        if (typeof sch.$id == "string")
            baseId = addRef.call(this, sch.$id);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = baseId;
        function addRef(ref) {
            ref = normalizeId(baseId ? uri_all.resolve(baseId, ref) : ref);
            if (schemaRefs.has(ref))
                throw ambiguos(ref);
            schemaRefs.add(ref);
            let schOrRef = this.refs[ref];
            if (typeof schOrRef == "string")
                schOrRef = this.refs[schOrRef];
            if (typeof schOrRef == "object") {
                checkAmbiguosRef(sch, schOrRef.schema, ref);
            }
            else if (ref !== normalizeId(fullPath)) {
                if (ref[0] === "#") {
                    checkAmbiguosRef(sch, localRefs[ref], ref);
                    localRefs[ref] = sch;
                }
                else {
                    this.refs[ref] = fullPath;
                }
            }
            return ref;
        }
        function addAnchor(anchor) {
            if (typeof anchor == "string") {
                if (!ANCHOR.test(anchor))
                    throw new Error(`invalid anchor "${anchor}"`);
                addRef.call(this, `#${anchor}`);
            }
        }
    });
    return localRefs;
    function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== undefined && !fastDeepEqual(sch1, sch2))
            throw ambiguos(ref);
    }
    function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
    }
}
exports.getSchemaRefs = getSchemaRefs;

});

var validate = createCommonjsModule(function (module, exports) {
exports.checkStrictMode = exports.schemaCxtHasRules = exports.subschemaCode = exports.validateFunctionCode = void 0;







// schema compilation - generates validation function, subschemaCode (below) is used for subschemas
function validateFunctionCode(it) {
    if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
            topSchemaObjCode(it);
            return;
        }
    }
    validateFunction(it, () => boolSchema.topBoolOrEmptySchema(it));
}
exports.validateFunctionCode = validateFunctionCode;
function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
    if (opts.code.es5) {
        gen.func(validateName, codegen._ `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
            gen.code(codegen._ `"use strict"; ${funcSourceUrl(schema, opts)}`);
            destructureValCxtES5(gen, opts);
            gen.code(body);
        });
    }
    else {
        gen.func(validateName, codegen._ `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
    }
}
function destructureValCxt(opts) {
    return codegen._ `{${names_1.default.dataPath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? codegen._ `, ${names_1.default.dynamicAnchors}={}` : codegen.nil}}={}`;
}
function destructureValCxtES5(gen, opts) {
    gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.dataPath, codegen._ `${names_1.default.valCxt}.${names_1.default.dataPath}`);
        gen.var(names_1.default.parentData, codegen._ `${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, codegen._ `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, codegen._ `${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
            gen.var(names_1.default.dynamicAnchors, codegen._ `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
    }, () => {
        gen.var(names_1.default.dataPath, codegen._ `""`);
        gen.var(names_1.default.parentData, codegen._ `undefined`);
        gen.var(names_1.default.parentDataProperty, codegen._ `undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
            gen.var(names_1.default.dynamicAnchors, codegen._ `{}`);
    });
}
function topSchemaObjCode(it) {
    const { schema, opts, gen } = it;
    validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
            commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
            resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
    });
    return;
}
function resetEvaluated(it) {
    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
    const { gen, validateName } = it;
    it.evaluated = gen.const("evaluated", codegen._ `${validateName}.evaluated`);
    gen.if(codegen._ `${it.evaluated}.dynamicProps`, () => gen.assign(codegen._ `${it.evaluated}.props`, codegen._ `undefined`));
    gen.if(codegen._ `${it.evaluated}.dynamicItems`, () => gen.assign(codegen._ `${it.evaluated}.items`, codegen._ `undefined`));
}
function funcSourceUrl(schema, opts) {
    return typeof schema == "object" && schema.$id && (opts.code.source || opts.code.process)
        ? codegen._ `/*# sourceURL=${schema.$id} */`
        : codegen.nil;
}
// schema compilation - this function is used recursively to generate code for sub-schemas
function subschemaCode(it, valid) {
    if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
            subSchemaObjCode(it, valid);
            return;
        }
    }
    boolSchema.boolOrEmptySchema(it, valid);
}
exports.subschemaCode = subschemaCode;
function schemaCxtHasRules({ schema, self }) {
    if (typeof schema == "boolean")
        return !schema;
    for (const key in schema)
        if (self.RULES.all[key])
            return true;
    return false;
}
exports.schemaCxtHasRules = schemaCxtHasRules;
function isSchemaObj(it) {
    return typeof it.schema != "boolean";
}
function subSchemaObjCode(it, valid) {
    const { schema, gen, opts } = it;
    if (opts.$comment && schema.$comment)
        commentKeyword(it);
    updateContext(it);
    checkAsync(it);
    const errsCount = gen.const("_errs", names_1.default.errors);
    typeAndKeywords(it, errsCount);
    // TODO var
    gen.var(valid, codegen._ `${errsCount} === ${names_1.default.errors}`);
}
function checkKeywords(it) {
    util.checkUnknownRules(it);
    checkRefsAndKeywords(it);
}
function typeAndKeywords(it, errsCount) {
    if (it.opts.jtd)
        return iterate.schemaKeywords(it, [], false, errsCount);
    const types = dataType.getSchemaTypes(it.schema);
    const checkedTypes = dataType.coerceAndCheckDataType(it, types);
    iterate.schemaKeywords(it, types, !checkedTypes, errsCount);
}
function checkRefsAndKeywords(it) {
    const { schema, errSchemaPath, opts, self } = it;
    if (schema.$ref && opts.ignoreKeywordsWithRef && util.schemaHasRulesButRef(schema, self.RULES)) {
        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
    }
}
function checkNoDefault(it) {
    const { schema, opts } = it;
    if (schema.default !== undefined && opts.useDefaults && opts.strict) {
        checkStrictMode(it, "default is ignored in the schema root");
    }
}
function updateContext(it) {
    if (it.schema.$id)
        it.baseId = resolve.resolveUrl(it.baseId, it.schema.$id);
}
function checkAsync(it) {
    if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
}
function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
    const msg = schema.$comment;
    if (opts.$comment === true) {
        gen.code(codegen._ `${names_1.default.self}.logger.log(${msg})`);
    }
    else if (typeof opts.$comment == "function") {
        const schemaPath = codegen.str `${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code(codegen._ `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
    }
}
function returnResults(it) {
    const { gen, schemaEnv, validateName, ValidationError, opts } = it;
    if (schemaEnv.$async) {
        // TODO assign unevaluated
        gen.if(codegen._ `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw(codegen._ `new ${ValidationError}(${names_1.default.vErrors})`));
    }
    else {
        gen.assign(codegen._ `${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
            assignEvaluated(it);
        gen.return(codegen._ `${names_1.default.errors} === 0`);
    }
}
function assignEvaluated({ gen, evaluated, props, items }) {
    if (props instanceof codegen.Name)
        gen.assign(codegen._ `${evaluated}.props`, props);
    if (items instanceof codegen.Name)
        gen.assign(codegen._ `${evaluated}.items`, items);
}
function checkStrictMode(it, msg, mode = it.opts.strict) {
    if (!mode)
        return;
    msg = `strict mode: ${msg}`;
    if (mode === true)
        throw new Error(msg);
    it.self.logger.warn(msg);
}
exports.checkStrictMode = checkStrictMode;

});

var util = createCommonjsModule(function (module, exports) {
exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;


// TODO refactor to use Set
function toHash(arr) {
    const hash = {};
    for (const item of arr)
        hash[item] = true;
    return hash;
}
exports.toHash = toHash;
function alwaysValidSchema(it, schema) {
    if (typeof schema == "boolean")
        return schema;
    if (Object.keys(schema).length === 0)
        return true;
    checkUnknownRules(it, schema);
    return !schemaHasRules(schema, it.self.RULES.all);
}
exports.alwaysValidSchema = alwaysValidSchema;
function checkUnknownRules(it, schema = it.schema) {
    const { opts, self } = it;
    if (!opts.strict)
        return;
    if (typeof schema === "boolean")
        return;
    const rules = self.RULES.keywords;
    for (const key in schema) {
        if (!rules[key])
            validate.checkStrictMode(it, `unknown keyword: "${key}"`);
    }
}
exports.checkUnknownRules = checkUnknownRules;
function schemaHasRules(schema, rules) {
    if (typeof schema == "boolean")
        return !schema;
    for (const key in schema)
        if (rules[key])
            return true;
    return false;
}
exports.schemaHasRules = schemaHasRules;
function schemaHasRulesButRef(schema, RULES) {
    if (typeof schema == "boolean")
        return !schema;
    for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
            return true;
    return false;
}
exports.schemaHasRulesButRef = schemaHasRulesButRef;
function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
    if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
            return schema;
        if (typeof schema == "string")
            return codegen._ `${schema}`;
    }
    return codegen._ `${topSchemaRef}${schemaPath}${codegen.getProperty(keyword)}`;
}
exports.schemaRefOrVal = schemaRefOrVal;
function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
}
exports.unescapeFragment = unescapeFragment;
function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
}
exports.escapeFragment = escapeFragment;
function escapeJsonPointer(str) {
    if (typeof str == "number")
        return `${str}`;
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
exports.escapeJsonPointer = escapeJsonPointer;
function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
}
exports.unescapeJsonPointer = unescapeJsonPointer;
function eachItem(xs, f) {
    if (Array.isArray(xs)) {
        for (const x of xs)
            f(x);
    }
    else {
        f(xs);
    }
}
exports.eachItem = eachItem;
function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {
    return (gen, from, to, toName) => {
        const res = to === undefined
            ? from
            : to instanceof codegen.Name
                ? (from instanceof codegen.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)
                : from instanceof codegen.Name
                    ? (mergeToName(gen, to, from), from)
                    : mergeValues(from, to);
        return toName === codegen.Name && !(res instanceof codegen.Name) ? resultToName(gen, res) : res;
    };
}
exports.mergeEvaluated = {
    props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if(codegen._ `${to} !== true && ${from} !== undefined`, () => {
            gen.if(codegen._ `${from} === true`, () => gen.assign(to, true), () => gen.code(codegen._ `Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if(codegen._ `${to} !== true`, () => {
            if (from === true) {
                gen.assign(to, true);
            }
            else {
                gen.assign(to, codegen._ `${to} || {}`);
                setEvaluated(gen, to, from);
            }
        }),
        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),
        resultToName: evaluatedPropsToName,
    }),
    items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if(codegen._ `${to} !== true && ${from} !== undefined`, () => gen.assign(to, codegen._ `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if(codegen._ `${to} !== true`, () => gen.assign(to, from === true ? true : codegen._ `${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),
        resultToName: (gen, items) => gen.var("items", items),
    }),
};
function evaluatedPropsToName(gen, ps) {
    if (ps === true)
        return gen.var("props", true);
    const props = gen.var("props", codegen._ `{}`);
    if (ps !== undefined)
        setEvaluated(gen, props, ps);
    return props;
}
exports.evaluatedPropsToName = evaluatedPropsToName;
function setEvaluated(gen, props, ps) {
    Object.keys(ps).forEach((p) => gen.assign(codegen._ `${props}${codegen.getProperty(p)}`, true));
}
exports.setEvaluated = setEvaluated;

});

var dataType = createCommonjsModule(function (module, exports) {
exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;





var DataType;
(function (DataType) {
    DataType[DataType["Correct"] = 0] = "Correct";
    DataType[DataType["Wrong"] = 1] = "Wrong";
})(DataType = exports.DataType || (exports.DataType = {}));
function getSchemaTypes(schema) {
    const types = getJSONTypes(schema.type);
    const hasNull = types.includes("null");
    if (hasNull) {
        if (schema.nullable === false)
            throw new Error("type: null contradicts nullable: false");
    }
    else {
        if (!types.length && schema.nullable !== undefined) {
            throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
            types.push("null");
    }
    return types;
}
exports.getSchemaTypes = getSchemaTypes;
function getJSONTypes(ts) {
    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
    if (types.every(rules.isJSONType))
        return types;
    throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
}
exports.getJSONTypes = getJSONTypes;
function coerceAndCheckDataType(it, types) {
    const { gen, data, opts } = it;
    const coerceTo = coerceToTypes(types, opts.coerceTypes);
    const checkTypes = types.length > 0 &&
        !(coerceTo.length === 0 && types.length === 1 && applicability.schemaHasRulesForType(it, types[0]));
    if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strict, DataType.Wrong);
        gen.if(wrongType, () => {
            if (coerceTo.length)
                coerceData(it, types, coerceTo);
            else
                reportTypeError(it);
        });
    }
    return checkTypes;
}
exports.coerceAndCheckDataType = coerceAndCheckDataType;
const COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
function coerceToTypes(types, coerceTypes) {
    return coerceTypes
        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === "array" && t === "array"))
        : [];
}
function coerceData(it, types, coerceTo) {
    const { gen, data, opts } = it;
    const dataType = gen.let("dataType", codegen._ `typeof ${data}`);
    const coerced = gen.let("coerced", codegen._ `undefined`);
    if (opts.coerceTypes === "array") {
        gen.if(codegen._ `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen
            .assign(data, codegen._ `${data}[0]`)
            .assign(dataType, codegen._ `typeof ${data}`)
            .if(checkDataTypes(types, data, opts.strict), () => gen.assign(coerced, data)));
    }
    gen.if(codegen._ `${coerced} !== undefined`);
    for (const t of coerceTo) {
        if (COERCIBLE.has(t) || (t === "array" && opts.coerceTypes === "array")) {
            coerceSpecificType(t);
        }
    }
    gen.else();
    reportTypeError(it);
    gen.endIf();
    gen.if(codegen._ `${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
    });
    function coerceSpecificType(t) {
        switch (t) {
            case "string":
                gen
                    .elseIf(codegen._ `${dataType} == "number" || ${dataType} == "boolean"`)
                    .assign(coerced, codegen._ `"" + ${data}`)
                    .elseIf(codegen._ `${data} === null`)
                    .assign(coerced, codegen._ `""`);
                return;
            case "number":
                gen
                    .elseIf(codegen._ `${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`)
                    .assign(coerced, codegen._ `+${data}`);
                return;
            case "integer":
                gen
                    .elseIf(codegen._ `${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`)
                    .assign(coerced, codegen._ `+${data}`);
                return;
            case "boolean":
                gen
                    .elseIf(codegen._ `${data} === "false" || ${data} === 0 || ${data} === null`)
                    .assign(coerced, false)
                    .elseIf(codegen._ `${data} === "true" || ${data} === 1`)
                    .assign(coerced, true);
                return;
            case "null":
                gen.elseIf(codegen._ `${data} === "" || ${data} === 0 || ${data} === false`);
                gen.assign(coerced, null);
                return;
            case "array":
                gen
                    .elseIf(codegen._ `${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`)
                    .assign(coerced, codegen._ `[${data}]`);
        }
    }
}
function assignParentData({ gen, parentData, parentDataProperty }, expr) {
    // TODO use gen.property
    gen.if(codegen._ `${parentData} !== undefined`, () => gen.assign(codegen._ `${parentData}[${parentDataProperty}]`, expr));
}
function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen.operators.EQ : codegen.operators.NEQ;
    let cond;
    switch (dataType) {
        case "null":
            return codegen._ `${data} ${EQ} null`;
        case "array":
            cond = codegen._ `Array.isArray(${data})`;
            break;
        case "object":
            cond = codegen._ `${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
            break;
        case "integer":
            cond = numCond(codegen._ `!(${data} % 1) && !isNaN(${data})`);
            break;
        case "number":
            cond = numCond();
            break;
        default:
            return codegen._ `typeof ${data} ${EQ} ${dataType}`;
    }
    return correct === DataType.Correct ? cond : codegen.not(cond);
    function numCond(_cond = codegen.nil) {
        return codegen.and(codegen._ `typeof ${data} == "number"`, _cond, strictNums ? codegen._ `isFinite(${data})` : codegen.nil);
    }
}
exports.checkDataType = checkDataType;
function checkDataTypes(dataTypes, data, strictNums, correct) {
    if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
    }
    let cond;
    const types = util.toHash(dataTypes);
    if (types.array && types.object) {
        const notObj = codegen._ `typeof ${data} != "object"`;
        cond = types.null ? notObj : codegen._ `!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
    }
    else {
        cond = codegen.nil;
    }
    if (types.number)
        delete types.integer;
    for (const t in types)
        cond = codegen.and(cond, checkDataType(t, data, strictNums, correct));
    return cond;
}
exports.checkDataTypes = checkDataTypes;
const typeError = {
    message: ({ schema }) => codegen.str `should be ${schema}`,
    params: ({ schema, schemaValue }) => typeof schema == "string" ? codegen._ `{type: ${schema}}` : codegen._ `{type: ${schemaValue}}`,
};
function reportTypeError(it) {
    const cxt = getTypeErrorContext(it);
    errors.reportError(cxt, typeError);
}
exports.reportTypeError = reportTypeError;
function getTypeErrorContext(it) {
    const { gen, data, schema } = it;
    const schemaCode = util.schemaRefOrVal(it, schema, "type");
    return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it,
    };
}

});

var context = createCommonjsModule(function (module, exports) {
exports.getData = void 0;






class KeywordCxt {
    constructor(it, def, keyword) {
        validateKeywordUsage(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = util.schemaRefOrVal(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
            this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        }
        else {
            this.schemaCode = this.schemaValue;
            if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {
                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
            }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
            this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
    }
    result(condition, successAction, failAction) {
        this.gen.if(codegen.not(condition));
        if (failAction)
            failAction();
        else
            this.error();
        if (successAction) {
            this.gen.else();
            successAction();
            if (this.allErrors)
                this.gen.endIf();
        }
        else {
            if (this.allErrors)
                this.gen.endIf();
            else
                this.gen.else();
        }
    }
    pass(condition, failAction) {
        this.result(condition, undefined, failAction);
    }
    fail(condition) {
        if (condition === undefined) {
            this.error();
            if (!this.allErrors)
                this.gen.if(false); // this branch will be removed by gen.optimize
            return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
            this.gen.endIf();
        else
            this.gen.else();
    }
    fail$data(condition) {
        if (!this.$data)
            return this.fail(condition);
        const { schemaCode } = this;
        this.fail(codegen._ `${schemaCode} !== undefined && (${codegen.or(this.invalid$data(), condition)})`);
    }
    error(append) {
        (append ? errors.reportExtraError : errors.reportError)(this, this.def.error);
    }
    $dataError() {
        errors.reportError(this, this.def.$dataError || errors.keyword$DataError);
    }
    reset() {
        if (this.errsCount === undefined)
            throw new Error('add "trackErrors" to keyword definition');
        errors.resetErrorsCount(this.gen, this.errsCount);
    }
    ok(cond) {
        if (!this.allErrors)
            this.gen.if(cond);
    }
    setParams(obj, assign) {
        if (assign)
            Object.assign(this.params, obj);
        else
            this.params = obj;
    }
    block$data(valid, codeBlock, $dataValid = codegen.nil) {
        this.gen.block(() => {
            this.check$data(valid, $dataValid);
            codeBlock();
        });
    }
    check$data(valid = codegen.nil, $dataValid = codegen.nil) {
        if (!this.$data)
            return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if(codegen.or(codegen._ `${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen.nil)
            gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
            gen.elseIf(this.invalid$data());
            this.$dataError();
            if (valid !== codegen.nil)
                gen.assign(valid, false);
        }
        gen.else();
    }
    invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return codegen.or(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
            if (schemaType.length) {
                /* istanbul ignore if */
                if (!(schemaCode instanceof codegen.Name))
                    throw new Error("ajv implementation error");
                const st = Array.isArray(schemaType) ? schemaType : [schemaType];
                return codegen._ `${dataType.checkDataTypes(st, schemaCode, it.opts.strict, dataType.DataType.Wrong)}`;
            }
            return codegen.nil;
        }
        function invalid$DataSchema() {
            if (def.validateSchema) {
                const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema }); // TODO value.code for standalone
                return codegen._ `!${validateSchemaRef}(${schemaCode})`;
            }
            return codegen.nil;
        }
    }
    subschema(appl, valid) {
        return subschema.applySubschema(this.it, appl, valid);
    }
    mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
            return;
        if (it.props !== true && schemaCxt.props !== undefined) {
            it.props = util.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== undefined) {
            it.items = util.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
    }
    mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen.Name));
            return true;
        }
    }
}
exports.default = KeywordCxt;
function validSchemaType(schema, schemaType, allowUndefined = false) {
    // TODO add tests
    return (!schemaType.length ||
        schemaType.some((st) => st === "array"
            ? Array.isArray(schema)
            : st === "object"
                ? schema && typeof schema == "object" && !Array.isArray(schema)
                : typeof schema == st || (allowUndefined && typeof schema == "undefined")));
}
function validateKeywordUsage({ schema, opts, self }, def, keyword) {
    /* istanbul ignore if */
    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
    }
    const deps = def.dependencies;
    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
    }
    if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
            const msg = "keyword value is invalid: " + self.errorsText(def.validateSchema.errors);
            if (opts.validateSchema === "log")
                self.logger.error(msg);
            else
                throw new Error(msg);
        }
    }
}
const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, { dataLevel, dataNames, dataPathArr }) {
    let jsonPointer;
    let data;
    if ($data === "")
        return names_1.default.rootData;
    if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
            throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
    }
    else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
            throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
            if (up >= dataLevel)
                throw new Error(errorMsg("property/index", up));
            return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
            throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
            return data;
    }
    let expr = data;
    const segments = jsonPointer.split("/");
    for (const segment of segments) {
        if (segment) {
            data = codegen._ `${data}${codegen.getProperty(util.unescapeJsonPointer(segment))}`;
            expr = codegen._ `${expr} && ${data}`;
        }
    }
    return expr;
    function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
    }
}
exports.getData = getData;

});

var error_classes = createCommonjsModule(function (module, exports) {
exports.MissingRefError = exports.ValidationError = void 0;

class ValidationError extends Error {
    constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
    }
}
exports.ValidationError = ValidationError;
class MissingRefError extends Error {
    constructor(baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = resolve.resolveUrl(baseId, ref);
        this.missingSchema = resolve.normalizeId(resolve.getFullPath(this.missingRef));
    }
}
exports.MissingRefError = MissingRefError;
module.exports = {
    ValidationError,
    MissingRefError,
};

});

var compile = createCommonjsModule(function (module, exports) {
exports.resolveSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;







class SchemaEnv {
    constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
            schema = env.schema;
        this.schema = env.schema;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : resolve.normalizeId(schema === null || schema === void 0 ? void 0 : schema.$id);
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
    }
}
exports.SchemaEnv = SchemaEnv;
// let codeSize = 0
// let nodeCount = 0
// Compiles schema in SchemaEnv
function compileSchema(sch) {
    // TODO refactor - remove compilations
    const _sch = getCompilingSchema.call(this, sch);
    if (_sch)
        return _sch;
    const rootId = resolve.getFullPath(sch.root.baseId); // TODO if getFullPath removed 1 tests fails
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen.CodeGen(this.scope, { es5, lines, ownProperties });
    let _ValidationError;
    if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
            ref: error_classes.ValidationError,
            code: codegen._ `require("ajv/dist/compile/error_classes").ValidationError`,
        });
    }
    const validateName = gen.scopeName("validate");
    sch.validateName = validateName;
    const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen.nil],
        dataLevel: 0,
        dataTypes: [],
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true
            ? { ref: sch.schema, code: codegen.stringify(sch.schema) }
            : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen.nil,
        errSchemaPath: this.opts.jtd ? "" : "#",
        errorPath: codegen._ `""`,
        opts: this.opts,
        self: this,
    };
    let sourceCode;
    try {
        this._compilations.add(sch);
        validate.validateFunctionCode(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        // gen.optimize(1)
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))
        if (this.opts.code.process)
            sourceCode = this.opts.code.process(sourceCode, sch);
        // console.log("\n\n\n *** \n", sourceCode)
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate$1 = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate$1 });
        validate$1.errors = null;
        validate$1.schema = sch.schema;
        validate$1.schemaEnv = sch;
        if (sch.$async)
            validate$1.$async = true;
        if (this.opts.code.source === true) {
            validate$1.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
            const { props, items } = schemaCxt;
            validate$1.evaluated = {
                props: props instanceof codegen.Name ? undefined : props,
                items: items instanceof codegen.Name ? undefined : items,
                dynamicProps: props instanceof codegen.Name,
                dynamicItems: items instanceof codegen.Name,
            };
            if (validate$1.source)
                validate$1.source.evaluated = codegen.stringify(validate$1.evaluated);
        }
        sch.validate = validate$1;
        return sch;
    }
    catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
            this.logger.error("Error compiling schema, function code:", sourceCode);
        // console.log("\n\n\n *** \n", sourceCode, this.opts)
        throw e;
    }
    finally {
        this._compilations.delete(sch);
    }
}
exports.compileSchema = compileSchema;
function resolveRef(root, baseId, ref) {
    var _a;
    ref = resolve.resolveUrl(baseId, ref);
    const schOrFunc = root.refs[ref];
    if (schOrFunc)
        return schOrFunc;
    let _sch = resolve$1.call(this, root, ref);
    if (_sch === undefined) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv
        if (schema)
            _sch = new SchemaEnv({ schema, root, baseId });
    }
    if (_sch === undefined)
        return;
    return (root.refs[ref] = inlineOrCompile.call(this, _sch));
}
exports.resolveRef = resolveRef;
function inlineOrCompile(sch) {
    if (resolve.inlineRef(sch.schema, this.opts.inlineRefs))
        return sch.schema;
    return sch.validate ? sch : compileSchema.call(this, sch);
}
// Index of schema compilation in the currently compiled list
function getCompilingSchema(schEnv) {
    for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
            return sch;
    }
}
function sameSchemaEnv(s1, s2) {
    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
// resolve and compile the references ($ref)
// TODO returns AnySchemaObject (if the schema can be inlined) or validation function
function resolve$1(root, // information about the root schema for the current schema
ref // reference to resolve
) {
    let sch;
    while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
}
// Resolve schema, its root and baseId
function resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it
ref // reference to resolve
) {
    const p = uri_all.parse(ref);
    const refPath = resolve._getFullPath(p);
    let baseId = resolve.getFullPath(root.baseId);
    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests
    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
    }
    const id = resolve.normalizeId(refPath);
    const schOrRef = this.refs[id] || this.schemas[id];
    if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
            return;
        return getJsonPointer.call(this, p, sch);
    }
    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
    if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
    if (id === resolve.normalizeId(ref)) {
        const { schema } = schOrRef;
        if (schema.$id)
            baseId = resolve.resolveUrl(baseId, schema.$id);
        return new SchemaEnv({ schema, root, baseId });
    }
    return getJsonPointer.call(this, p, schOrRef);
}
exports.resolveSchema = resolveSchema;
const PREVENT_SCOPE_CHANGE = new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions",
]);
function getJsonPointer(parsedRef, { baseId, schema, root }) {
    var _a;
    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
    for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema == "boolean")
            return;
        schema = schema[util.unescapeFragment(part)];
        if (schema === undefined)
            return;
        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?
        if (!PREVENT_SCOPE_CHANGE.has(part) && typeof schema == "object" && schema.$id) {
            baseId = resolve.resolveUrl(baseId, schema.$id);
        }
    }
    let env;
    if (typeof schema != "boolean" && schema.$ref && !util.schemaHasRulesButRef(schema, this.RULES)) {
        const $ref = resolve.resolveUrl(baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
    }
    // even though resolution failed we need to return SchemaEnv to throw exception
    // so that compileAsync loads missing schema.
    env = env || new SchemaEnv({ schema, root, baseId });
    if (env.schema !== env.root.schema)
        return env;
    return undefined;
}

});

var $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
var description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
var type$1 = "object";
var required$1 = [
	"$data"
];
var properties$2 = {
	$data: {
		type: "string",
		anyOf: [
			{
				format: "relative-json-pointer"
			},
			{
				format: "json-pointer"
			}
		]
	}
};
var additionalProperties$1 = false;
var $dataRefSchema = {
	$id: $id$1,
	description: description,
	type: type$1,
	required: required$1,
	properties: properties$2,
	additionalProperties: additionalProperties$1
};

var core$1 = createCommonjsModule(function (module, exports) {
exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;

exports.KeywordCxt = context.default;

Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen._; } });
Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen.str; } });
Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen.stringify; } });
Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen.nil; } });
Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen.Name; } });
Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen.CodeGen; } });



const codegen_2 = codegen;




const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
const EXT_SCOPE_NAMES = new Set([
    "validate",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error",
]);
const removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    schemaId: "JSON Schema draft-04 is not supported in Ajv v7.",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    strictNumbers: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
};
const deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.',
};
function requiredOptions(o) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const strict = (_a = o.strict) !== null && _a !== void 0 ? _a : true;
    const strictLog = strict ? "log" : false;
    const _optz = (_b = o.code) === null || _b === void 0 ? void 0 : _b.optimize;
    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
    return {
        strict,
        strictTypes: (_c = o.strictTypes) !== null && _c !== void 0 ? _c : strictLog,
        strictTuples: (_d = o.strictTuples) !== null && _d !== void 0 ? _d : strictLog,
        code: o.code ? { ...o.code, optimize } : { optimize },
        loopRequired: (_e = o.loopRequired) !== null && _e !== void 0 ? _e : Infinity,
        loopEnum: (_f = o.loopEnum) !== null && _f !== void 0 ? _f : Infinity,
        meta: (_g = o.meta) !== null && _g !== void 0 ? _g : true,
        messages: (_h = o.messages) !== null && _h !== void 0 ? _h : true,
        inlineRefs: (_j = o.inlineRefs) !== null && _j !== void 0 ? _j : true,
        addUsedSchema: (_k = o.addUsedSchema) !== null && _k !== void 0 ? _k : true,
        validateSchema: (_l = o.validateSchema) !== null && _l !== void 0 ? _l : true,
        validateFormats: (_m = o.validateFormats) !== null && _m !== void 0 ? _m : true,
    };
}
class Ajv {
    constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = new Set();
        this._loading = {};
        this._cache = new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = rules.getRules();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
            addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
            addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
            this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
    }
    _addVocabularies() {
        this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
        const { $data, meta } = this.opts;
        if (meta && $data)
            this.addMetaSchema($dataRefSchema, $dataRefSchema.$id, false);
    }
    defaultMeta() {
        const { meta } = this.opts;
        return (this.opts.defaultMeta = typeof meta == "object" ? meta.$id || meta : undefined);
    }
    validate(schemaKeyRef, // key, ref or schema object
    data // to be validated
    ) {
        let v;
        if (typeof schemaKeyRef == "string") {
            v = this.getSchema(schemaKeyRef);
            if (!v)
                throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        }
        else {
            v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
            this.errors = v.errors;
        return valid;
    }
    compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return (sch.validate || this._compileSchemaEnv(sch));
    }
    compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
            throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
            await loadMetaSchema.call(this, _schema.$schema);
            const sch = this._addSchema(_schema, _meta);
            return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
            if ($ref && !this.getSchema($ref)) {
                await runCompileAsync.call(this, { $ref }, true);
            }
        }
        async function _compileAsync(sch) {
            try {
                return this._compileSchemaEnv(sch);
            }
            catch (e) {
                if (!(e instanceof error_classes.MissingRefError))
                    throw e;
                checkLoaded.call(this, e);
                await loadMissingSchema.call(this, e.missingSchema);
                return _compileAsync.call(this, sch);
            }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
            if (this.refs[ref]) {
                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
            }
        }
        async function loadMissingSchema(ref) {
            const _schema = await _loadSchema.call(this, ref);
            if (!this.refs[ref])
                await loadMetaSchema.call(this, _schema.$schema);
            if (!this.refs[ref])
                this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
            const p = this._loading[ref];
            if (p)
                return p;
            try {
                return await (this._loading[ref] = loadSchema(ref));
            }
            finally {
                delete this._loading[ref];
            }
        }
    }
    // Adds schema to the instance
    addSchema(schema, // If array is passed, `key` will be ignored
    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.
    ) {
        if (Array.isArray(schema)) {
            for (const sch of schema)
                this.addSchema(sch, undefined, _meta, _validateSchema);
            return this;
        }
        let id;
        if (typeof schema === "object") {
            id = schema.$id;
            if (id !== undefined && typeof id != "string")
                throw new Error("schema id must be string");
        }
        key = resolve.normalizeId(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, _validateSchema, true);
        return this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(schema, key, // schema key
    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema
    ) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
    }
    //  Validate schema against its meta-schema
    validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
            return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== undefined && typeof $schema != "string") {
            throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
            this.logger.warn("meta-schema not available");
            this.errors = null;
            return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
            const message = "schema is invalid: " + this.errorsText();
            if (this.opts.validateSchema === "log")
                this.logger.error(message);
            else
                throw new Error(message);
        }
        return valid;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
            keyRef = sch;
        if (sch === undefined) {
            const root = new compile.SchemaEnv({ schema: {} });
            sch = compile.resolveSchema.call(this, root, keyRef);
            if (!sch)
                return;
            this.refs[keyRef] = sch;
        }
        return (sch.validate || this._compileSchemaEnv(sch));
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
            this._removeAllSchemas(this.schemas, schemaKeyRef);
            this._removeAllSchemas(this.refs, schemaKeyRef);
            return this;
        }
        switch (typeof schemaKeyRef) {
            case "undefined":
                this._removeAllSchemas(this.schemas);
                this._removeAllSchemas(this.refs);
                this._cache.clear();
                return this;
            case "string": {
                const sch = getSchEnv.call(this, schemaKeyRef);
                if (typeof sch == "object")
                    this._cache.delete(sch.schema);
                delete this.schemas[schemaKeyRef];
                delete this.refs[schemaKeyRef];
                return this;
            }
            case "object": {
                const cacheKey = schemaKeyRef;
                this._cache.delete(cacheKey);
                let id = schemaKeyRef.$id;
                if (id) {
                    id = resolve.normalizeId(id);
                    delete this.schemas[id];
                    delete this.refs[id];
                }
                return this;
            }
            default:
                throw new Error("ajv.removeSchema: invalid parameter");
        }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(definitions) {
        for (const def of definitions)
            this.addKeyword(def);
        return this;
    }
    addKeyword(kwdOrDef, def // deprecated
    ) {
        let keyword;
        if (typeof kwdOrDef == "string") {
            keyword = kwdOrDef;
            if (typeof def == "object") {
                this.logger.warn("these parameters are deprecated, see docs for addKeyword");
                def.keyword = keyword;
            }
        }
        else if (typeof kwdOrDef == "object" && def === undefined) {
            def = kwdOrDef;
            keyword = def.keyword;
            if (Array.isArray(keyword) && !keyword.length) {
                throw new Error("addKeywords: keyword must be string or non-empty array");
            }
        }
        else {
            throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
            util.eachItem(keyword, (kwd) => addRule.call(this, kwd));
            return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
            ...def,
            type: dataType.getJSONTypes(def.type),
            schemaType: dataType.getJSONTypes(def.schemaType),
        };
        util.eachItem(keyword, definition.type.length === 0
            ? (k) => addRule.call(this, k, definition)
            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
    }
    getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
    }
    // Remove keyword
    removeKeyword(keyword) {
        // TODO return type should be Ajv
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
            const i = group.rules.findIndex((rule) => rule.keyword === keyword);
            if (i >= 0)
                group.rules.splice(i, 1);
        }
        return this;
    }
    // Add format
    addFormat(name, format) {
        if (typeof format == "string")
            format = new RegExp(format);
        this.formats[name] = format;
        return this;
    }
    errorsText(errors = this.errors, // optional array of validation errors
    { separator = ", ", dataVar = "data" } = {} // optional options with properties `separator` and `dataVar`
    ) {
        if (!errors || errors.length === 0)
            return "No errors";
        return errors
            .map((e) => `${dataVar}${e.dataPath} ${e.message}`)
            .reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
            const segments = jsonPointer.split("/").slice(1); // first segment is an empty string
            let keywords = metaSchema;
            for (const seg of segments)
                keywords = keywords[seg];
            for (const key in rules) {
                const rule = rules[key];
                if (typeof rule != "object")
                    continue;
                const { $data } = rule.definition;
                const schema = keywords[key];
                if ($data && schema)
                    keywords[key] = schemaOrData(schema);
            }
        }
        return metaSchema;
    }
    _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
            const sch = schemas[keyRef];
            if (!regex || regex.test(keyRef)) {
                if (typeof sch == "string") {
                    delete schemas[keyRef];
                }
                else if (sch && !sch.meta) {
                    this._cache.delete(sch.schema);
                    delete schemas[keyRef];
                }
            }
        }
    }
    _addSchema(schema, meta, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        if (typeof schema != "object") {
            if (this.opts.jtd)
                throw new Error("schema must be object");
            else if (typeof schema != "boolean")
                throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== undefined)
            return sch;
        const localRefs = resolve.getSchemaRefs.call(this, schema);
        sch = new compile.SchemaEnv({ schema, meta, localRefs });
        this._cache.set(sch.schema, sch);
        const id = sch.baseId;
        if (addSchema && !id.startsWith("#")) {
            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
            if (id)
                this._checkUnique(id);
            this.refs[id] = sch;
        }
        if (validateSchema)
            this.validateSchema(schema, true);
        return sch;
    }
    _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
            throw new Error(`schema with key or id "${id}" already exists`);
        }
    }
    _compileSchemaEnv(sch) {
        if (sch.meta)
            this._compileMetaSchema(sch);
        else
            compile.compileSchema.call(this, sch);
        /* istanbul ignore if */
        if (!sch.validate)
            throw new Error("ajv implementation error");
        return sch.validate;
    }
    _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
            compile.compileSchema.call(this, sch);
        }
        finally {
            this.opts = currentOpts;
        }
    }
}
exports.default = Ajv;
Ajv.ValidationError = error_classes.ValidationError;
Ajv.MissingRefError = error_classes.MissingRefError;
function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
}
function getSchEnv(keyRef) {
    keyRef = resolve.normalizeId(keyRef); // TODO tests fail without this line
    return this.schemas[keyRef] || this.refs[keyRef];
}
function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
        return;
    if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
    else
        for (const key in optsSchemas)
            this.addSchema(optsSchemas[key], key);
}
function addInitialFormats() {
    for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
            this.addFormat(name, format);
    }
}
function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
            def.keyword = keyword;
        this.addKeyword(def);
    }
}
function getMetaSchemaOptions() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
    return metaOpts;
}
const noLogs = { log() { }, warn() { }, error() { } };
function getLogger(logger) {
    if (logger === false)
        return noLogs;
    if (logger === undefined)
        return console;
    if (logger.log && logger.warn && logger.error)
        return logger;
    throw new Error("logger must implement log, warn and error methods");
}
const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
function checkKeyword(keyword, def) {
    const { RULES } = this;
    util.eachItem(keyword, (kwd) => {
        if (RULES.keywords[kwd])
            throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
            throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def)
        return;
    if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
    }
}
function addRule(keyword, definition, dataType$1) {
    var _a;
    const post = definition === null || definition === void 0 ? void 0 : definition.post;
    if (dataType$1 && post)
        throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType$1);
    if (!ruleGroup) {
        ruleGroup = { type: dataType$1, rules: [] };
        RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword] = true;
    if (!definition)
        return;
    const rule = {
        keyword,
        definition: {
            ...definition,
            type: dataType.getJSONTypes(definition.type),
            schemaType: dataType.getJSONTypes(definition.schemaType),
        },
    };
    if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
        ruleGroup.rules.push(rule);
    RULES.all[keyword] = rule;
    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
}
function addBeforeRule(ruleGroup, rule, before) {
    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
    }
    else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
    }
}
function keywordMetaschema(def) {
    let { metaSchema } = def;
    if (metaSchema === undefined)
        return;
    if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
    def.validateSchema = this.compile(metaSchema, true);
}
const $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
};
function schemaOrData(schema) {
    return { anyOf: [schema, $dataRef] };
}

});

const def$o = {
    keyword: "id",
    code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    },
};
var _default$u = def$o;


var id = {
	default: _default$u
};

var ref = createCommonjsModule(function (module, exports) {
exports.callRef = exports.getValidate = void 0;






const def = {
    keyword: "$ref",
    schemaType: "string",
    code(cxt) {
        const { gen, schema, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self } = it;
        // TODO See comment in dynamicRef.ts
        // This has to be improved to resolve #815.
        if (schema === "#" || schema === "#/")
            return callRootRef();
        const schOrEnv = compile.resolveRef.call(self, env.root, baseId, schema);
        if (schOrEnv === undefined)
            throw new error_classes.MissingRefError(baseId, schema);
        if (schOrEnv instanceof compile.SchemaEnv)
            return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
            if (env === env.root)
                return callRef(cxt, validateName, env, env.$async);
            const rootName = gen.scopeValue("root", { ref: env.root });
            return callRef(cxt, codegen._ `${rootName}.validate`, env.root, env.root.$async);
        }
        function callValidate(sch) {
            const v = getValidate(cxt, sch);
            callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
            const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: codegen.stringify(sch) } : { ref: sch });
            const valid = gen.name("valid");
            const schCxt = cxt.subschema({
                schema: sch,
                dataTypes: [],
                schemaPath: codegen.nil,
                topSchemaRef: schName,
                errSchemaPath: schema,
            }, valid);
            cxt.mergeEvaluated(schCxt);
            cxt.ok(valid);
        }
    },
};
function getValidate(cxt, sch) {
    const { gen } = cxt;
    return sch.validate
        ? gen.scopeValue("validate", { ref: sch.validate })
        : codegen._ `${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
exports.getValidate = getValidate;
function callRef(cxt, v, sch, $async) {
    const { gen, it } = cxt;
    const { allErrors, schemaEnv: env, opts } = it;
    const passCxt = opts.passContext ? names_1.default.this : codegen.nil;
    if ($async)
        callAsyncRef();
    else
        callSyncRef();
    function callAsyncRef() {
        if (!env.$async)
            throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
            gen.code(codegen._ `await ${code.callValidateCode(cxt, v, passCxt)}`);
            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result
            if (!allErrors)
                gen.assign(valid, true);
        }, (e) => {
            gen.if(codegen._ `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
            addErrorsFrom(e);
            if (!allErrors)
                gen.assign(valid, false);
        });
        cxt.ok(valid);
    }
    function callSyncRef() {
        cxt.result(code.callValidateCode(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
    }
    function addErrorsFrom(source) {
        const errs = codegen._ `${source}.errors`;
        gen.assign(names_1.default.vErrors, codegen._ `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged
        gen.assign(names_1.default.errors, codegen._ `${names_1.default.vErrors}.length`);
    }
    function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
            return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        // TODO refactor
        if (it.props !== true) {
            if (schEvaluated && !schEvaluated.dynamicProps) {
                if (schEvaluated.props !== undefined) {
                    it.props = util.mergeEvaluated.props(gen, schEvaluated.props, it.props);
                }
            }
            else {
                const props = gen.var("props", codegen._ `${source}.evaluated.props`);
                it.props = util.mergeEvaluated.props(gen, props, it.props, codegen.Name);
            }
        }
        if (it.items !== true) {
            if (schEvaluated && !schEvaluated.dynamicItems) {
                if (schEvaluated.items !== undefined) {
                    it.items = util.mergeEvaluated.items(gen, schEvaluated.items, it.items);
                }
            }
            else {
                const items = gen.var("items", codegen._ `${source}.evaluated.items`);
                it.items = util.mergeEvaluated.items(gen, items, it.items, codegen.Name);
            }
        }
    }
}
exports.callRef = callRef;
exports.default = def;

});

const core = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    id.default,
    ref.default,
];
var _default$t = core;


var core_1 = {
	default: _default$t
};

const ops = codegen.operators;
const KWDs = {
    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
};
const error$h = {
    message: ({ keyword, schemaCode }) => codegen.str `should be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode }) => codegen._ `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
};
const def$n = {
    keyword: Object.keys(KWDs),
    type: "number",
    schemaType: "number",
    $data: true,
    error: error$h,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data(codegen._ `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
    },
};
var _default$s = def$n;


var limitNumber = {
	default: _default$s
};

const error$g = {
    message: ({ schemaCode }) => codegen.str `should be multiple of ${schemaCode}`,
    params: ({ schemaCode }) => codegen._ `{multipleOf: ${schemaCode}}`,
};
const def$m = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: true,
    error: error$g,
    code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec
            ? codegen._ `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`
            : codegen._ `${res} !== parseInt(${res})`;
        cxt.fail$data(codegen._ `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
    },
};
var _default$r = def$m;


var multipleOf = {
	default: _default$r
};

// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
function ucs2length(str) {
    const len = str.length;
    let length = 0;
    let pos = 0;
    let value;
    while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 0xd800 && value <= 0xdbff && pos < len) {
            // high surrogate, and there is a next character
            value = str.charCodeAt(pos);
            if ((value & 0xfc00) === 0xdc00)
                pos++; // low surrogate
        }
    }
    return length;
}
var _default$q = ucs2length;


var ucs2length_1 = {
	default: _default$q
};

const error$f = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return codegen.str `should NOT have ${comp} than ${schemaCode} characters`;
    },
    params: ({ schemaCode }) => codegen._ `{limit: ${schemaCode}}`,
};
const def$l = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: true,
    error: error$f,
    code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen.operators.GT : codegen.operators.LT;
        let len;
        if (it.opts.unicode === false) {
            len = codegen._ `${data}.length`;
        }
        else {
            const u2l = cxt.gen.scopeValue("func", {
                ref: ucs2length_1.default,
                code: codegen._ `require("ajv/dist/compile/ucs2length").default`,
            });
            len = codegen._ `${u2l}(${data})`;
        }
        cxt.fail$data(codegen._ `${len} ${op} ${schemaCode}`);
    },
};
var _default$p = def$l;


var limitLength = {
	default: _default$p
};

const error$e = {
    message: ({ schemaCode }) => codegen.str `should match pattern "${schemaCode}"`,
    params: ({ schemaCode }) => codegen._ `{pattern: ${schemaCode}}`,
};
const def$k = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: true,
    error: error$e,
    code(cxt) {
        const { gen, data, $data, schema, schemaCode } = cxt;
        const regExp = $data ? codegen._ `(new RegExp(${schemaCode}, "u"))` : code.usePattern(gen, schema); // TODO regexp should be wrapped in try/catch
        cxt.fail$data(codegen._ `!${regExp}.test(${data})`);
    },
};
var _default$o = def$k;


var pattern = {
	default: _default$o
};

const error$d = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return codegen.str `should NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => codegen._ `{limit: ${schemaCode}}`,
};
const def$j = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: true,
    error: error$d,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen.operators.GT : codegen.operators.LT;
        cxt.fail$data(codegen._ `Object.keys(${data}).length ${op} ${schemaCode}`);
    },
};
var _default$n = def$j;


var limitProperties = {
	default: _default$n
};

const error$c = {
    message: ({ params: { missingProperty } }) => codegen.str `should have required property '${missingProperty}'`,
    params: ({ params: { missingProperty } }) => codegen._ `{missingProperty: ${missingProperty}}`,
};
const def$i = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: true,
    error: error$c,
    code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
            return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
            allErrorsMode();
        else
            exitOnErrorMode();
        function allErrorsMode() {
            if (useLoop || $data) {
                cxt.block$data(codegen.nil, loopAllRequired);
            }
            else {
                for (const prop of schema) {
                    code.checkReportMissingProp(cxt, prop);
                }
            }
        }
        function exitOnErrorMode() {
            const missing = gen.let("missing");
            if (useLoop || $data) {
                const valid = gen.let("valid", true);
                cxt.block$data(valid, () => loopUntilMissing(missing, valid));
                cxt.ok(valid);
            }
            else {
                gen.if(code.checkMissingProp(cxt, schema, missing));
                code.reportMissingProp(cxt, missing);
                gen.else();
            }
        }
        function loopAllRequired() {
            gen.forOf("prop", schemaCode, (prop) => {
                cxt.setParams({ missingProperty: prop });
                gen.if(code.noPropertyInData(data, prop, opts.ownProperties), () => cxt.error());
            });
        }
        function loopUntilMissing(missing, valid) {
            cxt.setParams({ missingProperty: missing });
            gen.forOf(missing, schemaCode, () => {
                gen.assign(valid, code.propertyInData(data, missing, opts.ownProperties));
                gen.if(codegen.not(valid), () => {
                    cxt.error();
                    gen.break();
                });
            }, codegen.nil);
        }
    },
};
var _default$m = def$i;


var required = {
	default: _default$m
};

const error$b = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return codegen.str `should NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => codegen._ `{limit: ${schemaCode}}`,
};
const def$h = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: true,
    error: error$b,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen.operators.GT : codegen.operators.LT;
        cxt.fail$data(codegen._ `${data}.length ${op} ${schemaCode}`);
    },
};
var _default$l = def$h;


var limitItems = {
	default: _default$l
};

const error$a = {
    message: ({ params: { i, j } }) => codegen.str `should NOT have duplicate items (items ## ${j} and ${i} are identical)`,
    params: ({ params: { i, j } }) => codegen._ `{i: ${i}, j: ${j}}`,
};
const def$g = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: true,
    error: error$a,
    code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
            return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? dataType.getSchemaTypes(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, codegen._ `${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
            const i = gen.let("i", codegen._ `${data}.length`);
            const j = gen.let("j");
            cxt.setParams({ i, j });
            gen.assign(valid, true);
            gen.if(codegen._ `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
            return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
            const item = gen.name("item");
            const wrongType = dataType.checkDataTypes(itemTypes, item, it.opts.strict, dataType.DataType.Wrong);
            const indices = gen.const("indices", codegen._ `{}`);
            gen.for(codegen._ `;${i}--;`, () => {
                gen.let(item, codegen._ `${data}[${i}]`);
                gen.if(wrongType, codegen._ `continue`);
                if (itemTypes.length > 1)
                    gen.if(codegen._ `typeof ${item} == "string"`, codegen._ `${item} += "_"`);
                gen
                    .if(codegen._ `typeof ${indices}[${item}] == "number"`, () => {
                    gen.assign(j, codegen._ `${indices}[${item}]`);
                    cxt.error();
                    gen.assign(valid, false).break();
                })
                    .code(codegen._ `${indices}[${item}] = ${i}`);
            });
        }
        function loopN2(i, j) {
            const eql = cxt.gen.scopeValue("func", {
                ref: fastDeepEqual,
                code: codegen._ `require("ajv/dist/compile/equal")`,
            });
            const outer = gen.name("outer");
            gen.label(outer).for(codegen._ `;${i}--;`, () => gen.for(codegen._ `${j} = ${i}; ${j}--;`, () => gen.if(codegen._ `${eql}(${data}[${i}], ${data}[${j}])`, () => {
                cxt.error();
                gen.assign(valid, false).break(outer);
            })));
        }
    },
};
var _default$k = def$g;


var uniqueItems = {
	default: _default$k
};

const error$9 = {
    message: "should be equal to constant",
    params: ({ schemaCode }) => codegen._ `{allowedValue: ${schemaCode}}`,
};
const def$f = {
    keyword: "const",
    $data: true,
    error: error$9,
    code(cxt) {
        const eql = cxt.gen.scopeValue("func", {
            ref: fastDeepEqual,
            code: codegen._ `require("ajv/dist/compile/equal")`,
        });
        // TODO optimize for scalar values in schema
        cxt.fail$data(codegen._ `!${eql}(${cxt.data}, ${cxt.schemaCode})`);
    },
};
var _default$j = def$f;


var _const = {
	default: _default$j
};

const error$8 = {
    message: "should be equal to one of the allowed values",
    params: ({ schemaCode }) => codegen._ `{allowedValues: ${schemaCode}}`,
};
const def$e = {
    keyword: "enum",
    schemaType: "array",
    $data: true,
    error: error$8,
    code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
            throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        const eql = cxt.gen.scopeValue("func", {
            ref: fastDeepEqual,
            code: codegen._ `require("ajv/dist/compile/equal")`,
        });
        let valid;
        if (useLoop || $data) {
            valid = gen.let("valid");
            cxt.block$data(valid, loopEnum);
        }
        else {
            /* istanbul ignore if */
            if (!Array.isArray(schema))
                throw new Error("ajv implementation error");
            const vSchema = gen.const("vSchema", schemaCode);
            valid = codegen.or(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
            gen.assign(valid, false);
            gen.forOf("v", schemaCode, (v) => gen.if(codegen._ `${eql}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
            const sch = schema[i];
            return sch && typeof sch === "object"
                ? codegen._ `${eql}(${data}, ${vSchema}[${i}])`
                : codegen._ `${data} === ${sch}`;
        }
    },
};
var _default$i = def$e;


var _enum = {
	default: _default$i
};

const validation = [
    // number
    limitNumber.default,
    multipleOf.default,
    // string
    limitLength.default,
    pattern.default,
    // object
    limitProperties.default,
    required.default,
    // array
    limitItems.default,
    uniqueItems.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    _const.default,
    _enum.default,
];
var _default$h = validation;


var validation_1 = {
	default: _default$h
};

const error$7 = {
    message: ({ params: { len } }) => codegen.str `should NOT have more than ${len} items`,
    params: ({ params: { len } }) => codegen._ `{limit: ${len}}`,
};
const def$d = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: error$7,
    code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
            validate.checkStrictMode(it, '"additionalItems" is ignored when "items" is not an array of schemas');
            return;
        }
        it.items = true;
        const len = gen.const("len", codegen._ `${data}.length`);
        if (schema === false) {
            cxt.setParams({ len: items.length });
            cxt.pass(codegen._ `${len} <= ${items.length}`);
        }
        else if (typeof schema == "object" && !util.alwaysValidSchema(it, schema)) {
            const valid = gen.var("valid", codegen._ `${len} <= ${items.length}`); // TODO var
            gen.if(codegen.not(valid), () => validateItems(valid));
            cxt.ok(valid);
        }
        function validateItems(valid) {
            gen.forRange("i", items.length, len, (i) => {
                cxt.subschema({ keyword: "additionalItems", dataProp: i, dataPropType: subschema.Type.Num }, valid);
                if (!it.allErrors)
                    gen.if(codegen.not(valid), () => gen.break());
            });
        }
    },
};
var _default$g = def$d;


var additionalItems = {
	default: _default$g
};

const def$c = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(cxt) {
        const { gen, schema, it } = cxt;
        if (Array.isArray(schema)) {
            if (it.opts.unevaluated && schema.length && it.items !== true) {
                it.items = util.mergeEvaluated.items(gen, schema.length, it.items);
            }
            validateTuple(schema);
        }
        else {
            it.items = true;
            if (util.alwaysValidSchema(it, schema))
                return;
            cxt.ok(code.validateArray(cxt));
        }
        function validateTuple(schArr) {
            const { parentSchema, data } = cxt;
            if (it.opts.strictTuples && !fullTupleSchema(schArr.length, parentSchema)) {
                const msg = `"items" is ${schArr.length}-tuple, but minItems or maxItems/additionalItems are not specified or different`;
                validate.checkStrictMode(it, msg, it.opts.strictTuples);
            }
            const valid = gen.name("valid");
            const len = gen.const("len", codegen._ `${data}.length`);
            schArr.forEach((sch, i) => {
                if (util.alwaysValidSchema(it, sch))
                    return;
                gen.if(codegen._ `${len} > ${i}`, () => cxt.subschema({
                    keyword: "items",
                    schemaProp: i,
                    dataProp: i,
                }, valid));
                cxt.ok(valid);
            });
        }
    },
};
function fullTupleSchema(len, sch) {
    return len === sch.minItems && (len === sch.maxItems || sch.additionalItems === false);
}
var _default$f = def$c;


var items = {
	default: _default$f
};

const error$6 = {
    message: ({ params: { min, max } }) => max === undefined
        ? codegen.str `should contain at least ${min} valid item(s)`
        : codegen.str `should contain at least ${min} and no more than ${max} valid item(s)`,
    params: ({ params: { min, max } }) => max === undefined ? codegen._ `{minContains: ${min}}` : codegen._ `{minContains: ${min}, maxContains: ${max}}`,
};
const def$b = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: true,
    error: error$6,
    code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
            min = minContains === undefined ? 1 : minContains;
            max = maxContains;
        }
        else {
            min = 1;
        }
        const len = gen.const("len", codegen._ `${data}.length`);
        cxt.setParams({ min, max });
        if (max === undefined && min === 0) {
            validate.checkStrictMode(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
            return;
        }
        if (max !== undefined && min > max) {
            validate.checkStrictMode(it, `"minContains" > "maxContains" is always invalid`);
            cxt.fail();
            return;
        }
        if (util.alwaysValidSchema(it, schema)) {
            let cond = codegen._ `${len} >= ${min}`;
            if (max !== undefined)
                cond = codegen._ `${cond} && ${len} <= ${max}`;
            cxt.pass(cond);
            return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === undefined && min === 1) {
            validateItems(valid, () => gen.if(valid, () => gen.break()));
        }
        else {
            gen.let(valid, false);
            const schValid = gen.name("_valid");
            const count = gen.let("count", 0);
            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        cxt.result(valid, () => cxt.reset());
        function validateItems(_valid, block) {
            gen.forRange("i", 0, len, (i) => {
                cxt.subschema({
                    keyword: "contains",
                    dataProp: i,
                    dataPropType: subschema.Type.Num,
                    compositeRule: true,
                }, _valid);
                block();
            });
        }
        function checkLimits(count) {
            gen.code(codegen._ `${count}++`);
            if (max === undefined) {
                gen.if(codegen._ `${count} >= ${min}`, () => gen.assign(valid, true).break());
            }
            else {
                gen.if(codegen._ `${count} > ${max}`, () => gen.assign(valid, false).break());
                if (min === 1)
                    gen.assign(valid, true);
                else
                    gen.if(codegen._ `${count} >= ${min}`, () => gen.assign(valid, true));
            }
        }
    },
};
var _default$e = def$b;


var contains = {
	default: _default$e
};

var dependencies = createCommonjsModule(function (module, exports) {
exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;



exports.error = {
    message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return codegen.str `should have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => codegen._ `{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`,
};
const def = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports.error,
    code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
    },
};
function splitDependencies({ schema }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema) {
        if (key === "__proto__")
            continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
    }
    return [propertyDeps, schemaDeps];
}
function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it } = cxt;
    if (Object.keys(propertyDeps).length === 0)
        return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
            continue;
        const hasProperty = code.propertyInData(data, prop, it.opts.ownProperties);
        cxt.setParams({
            property: prop,
            depsCount: deps.length,
            deps: deps.join(", "),
        });
        if (it.allErrors) {
            gen.if(hasProperty, () => {
                for (const depProp of deps) {
                    code.checkReportMissingProp(cxt, depProp);
                }
            });
        }
        else {
            gen.if(codegen._ `${hasProperty} && (${code.checkMissingProp(cxt, deps, missing)})`);
            code.reportMissingProp(cxt, missing);
            gen.else();
        }
    }
}
exports.validatePropertyDeps = validatePropertyDeps;
function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword, it } = cxt;
    const valid = gen.name("valid");
    for (const prop in schemaDeps) {
        if (util.alwaysValidSchema(it, schemaDeps[prop]))
            continue;
        gen.if(code.propertyInData(data, prop, it.opts.ownProperties), () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
        }, () => gen.var(valid, true) // TODO var
        );
        cxt.ok(valid);
    }
}
exports.validateSchemaDeps = validateSchemaDeps;
exports.default = def;

});

const error$5 = {
    message: ({ params }) => codegen.str `property name '${params.propertyName}' is invalid`,
    params: ({ params }) => codegen._ `{propertyName: ${params.propertyName}}`,
};
const def$a = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: error$5,
    code(cxt) {
        const { gen, schema, data, it } = cxt;
        if (util.alwaysValidSchema(it, schema))
            return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
            cxt.setParams({ propertyName: key });
            cxt.subschema({
                keyword: "propertyNames",
                data: key,
                dataTypes: ["string"],
                propertyName: key,
                compositeRule: true,
            }, valid);
            gen.if(codegen.not(valid), () => {
                cxt.error(true);
                if (!it.allErrors)
                    gen.break();
            });
        });
        cxt.ok(valid);
    },
};
var _default$d = def$a;


var propertyNames = {
	default: _default$d
};

const error$4 = {
    message: "should NOT have additional properties",
    params: ({ params }) => codegen._ `{additionalProperty: ${params.additionalProperty}}`,
};
const def$9 = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: true,
    trackErrors: true,
    error: error$4,
    code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        /* istanbul ignore if */
        if (!errsCount)
            throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && util.alwaysValidSchema(it, schema))
            return;
        const props = code.allSchemaProperties(parentSchema.properties);
        const patProps = code.allSchemaProperties(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok(codegen._ `${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
            gen.forIn("key", data, (key) => {
                if (!props.length && !patProps.length)
                    additionalPropertyCode(key);
                else
                    gen.if(isAdditional(key), () => additionalPropertyCode(key));
            });
        }
        function isAdditional(key) {
            let definedProp;
            if (props.length > 8) {
                // TODO maybe an option instead of hard-coded 8?
                const hasProp = gen.scopeValue("func", {
                    // eslint-disable-next-line @typescript-eslint/unbound-method
                    ref: Object.prototype.hasOwnProperty,
                    code: codegen._ `Object.prototype.hasOwnProperty`,
                });
                const propsSchema = util.schemaRefOrVal(it, parentSchema.properties, "properties");
                definedProp = codegen._ `${hasProp}.call(${propsSchema}, ${key})`;
            }
            else if (props.length) {
                definedProp = codegen.or(...props.map((p) => codegen._ `${key} === ${p}`));
            }
            else {
                definedProp = codegen.nil;
            }
            if (patProps.length) {
                definedProp = codegen.or(definedProp, ...patProps.map((p) => codegen._ `${code.usePattern(gen, p)}.test(${key})`));
            }
            return codegen.not(definedProp);
        }
        function deleteAdditional(key) {
            gen.code(codegen._ `delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
            if (opts.removeAdditional === "all" || (opts.removeAdditional && schema === false)) {
                deleteAdditional(key);
                return;
            }
            if (schema === false) {
                cxt.setParams({ additionalProperty: key });
                cxt.error();
                if (!allErrors)
                    gen.break();
                return;
            }
            if (typeof schema == "object" && !util.alwaysValidSchema(it, schema)) {
                const valid = gen.name("valid");
                if (opts.removeAdditional === "failing") {
                    applyAdditionalSchema(key, valid, false);
                    gen.if(codegen.not(valid), () => {
                        cxt.reset();
                        deleteAdditional(key);
                    });
                }
                else {
                    applyAdditionalSchema(key, valid);
                    if (!allErrors)
                        gen.if(codegen.not(valid), () => gen.break());
                }
            }
        }
        function applyAdditionalSchema(key, valid, errors) {
            const subschema$1 = {
                keyword: "additionalProperties",
                dataProp: key,
                dataPropType: subschema.Type.Str,
            };
            if (errors === false) {
                Object.assign(subschema$1, {
                    compositeRule: true,
                    createErrors: false,
                    allErrors: false,
                });
            }
            cxt.subschema(subschema$1, valid);
        }
    },
};
var _default$c = def$9;


var additionalProperties = {
	default: _default$c
};

const def$8 = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
            additionalProperties.default.code(new context.default(it, additionalProperties.default, "additionalProperties"));
        }
        const allProps = code.allSchemaProperties(schema);
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
            it.props = util.mergeEvaluated.props(gen, util.toHash(allProps), it.props);
        }
        const properties = allProps.filter((p) => !util.alwaysValidSchema(it, schema[p]));
        if (properties.length === 0)
            return;
        const valid = gen.name("valid");
        for (const prop of properties) {
            if (hasDefault(prop)) {
                applyPropertySchema(prop);
            }
            else {
                gen.if(code.propertyInData(data, prop, it.opts.ownProperties));
                applyPropertySchema(prop);
                if (!it.allErrors)
                    gen.else().var(valid, true);
                gen.endIf();
            }
            cxt.ok(valid);
        }
        function hasDefault(prop) {
            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;
        }
        function applyPropertySchema(prop) {
            cxt.subschema({
                keyword: "properties",
                schemaProp: prop,
                dataProp: prop,
            }, valid);
        }
    },
};
var _default$b = def$8;


var properties$1 = {
	default: _default$b
};

const def$7 = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = code.schemaProperties(it, schema);
        // TODO mark properties matching patterns with always valid schemas as evaluated
        if (patterns.length === 0)
            return;
        const checkProperties = opts.strict && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen.Name)) {
            it.props = util.evaluatedPropsToName(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
            for (const pat of patterns) {
                if (checkProperties)
                    checkMatchingProperties(pat);
                if (it.allErrors) {
                    validateProperties(pat);
                }
                else {
                    gen.var(valid, true); // TODO var
                    validateProperties(pat);
                    gen.if(valid);
                }
            }
        }
        function checkMatchingProperties(pat) {
            for (const prop in checkProperties) {
                if (new RegExp(pat).test(prop)) {
                    validate.checkStrictMode(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
                }
            }
        }
        function validateProperties(pat) {
            gen.forIn("key", data, (key) => {
                gen.if(codegen._ `${code.usePattern(gen, pat)}.test(${key})`, () => {
                    cxt.subschema({
                        keyword: "patternProperties",
                        schemaProp: pat,
                        dataProp: key,
                        dataPropType: subschema.Type.Str,
                    }, valid);
                    if (it.opts.unevaluated && props !== true) {
                        gen.assign(codegen._ `${props}[${key}]`, true);
                    }
                    else if (!it.allErrors) {
                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)
                        // or if all properties were evaluated (props === true)
                        gen.if(codegen.not(valid), () => gen.break());
                    }
                });
            });
        }
    },
};
var _default$a = def$7;


var patternProperties = {
	default: _default$a
};

const def$6 = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    code(cxt) {
        const { gen, schema, it } = cxt;
        if (util.alwaysValidSchema(it, schema)) {
            cxt.fail();
            return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
            keyword: "not",
            compositeRule: true,
            createErrors: false,
            allErrors: false,
        }, valid);
        cxt.result(valid, () => cxt.error(), () => cxt.reset());
    },
    error: {
        message: "should NOT be valid",
    },
};
var _default$9 = def$6;


var not = {
	default: _default$9
};

const def$5 = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: true,
    code: code.validateUnion,
    error: {
        message: "should match some schema in anyOf",
    },
};
var _default$8 = def$5;


var anyOf = {
	default: _default$8
};

const error$3 = {
    message: "should match exactly one schema in oneOf",
    params: ({ params }) => codegen._ `{passingSchemas: ${params.passing}}`,
};
const def$4 = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: true,
    error: error$3,
    code(cxt) {
        const { gen, schema, it } = cxt;
        /* istanbul ignore if */
        if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
            schArr.forEach((sch, i) => {
                let schCxt;
                if (util.alwaysValidSchema(it, sch)) {
                    gen.var(schValid, true);
                }
                else {
                    schCxt = cxt.subschema({
                        keyword: "oneOf",
                        schemaProp: i,
                        compositeRule: true,
                    }, schValid);
                }
                if (i > 0) {
                    gen
                        .if(codegen._ `${schValid} && ${valid}`)
                        .assign(valid, false)
                        .assign(passing, codegen._ `[${passing}, ${i}]`)
                        .else();
                }
                gen.if(schValid, () => {
                    gen.assign(valid, true);
                    gen.assign(passing, i);
                    if (schCxt)
                        cxt.mergeEvaluated(schCxt, codegen.Name);
                });
            });
        }
    },
};
var _default$7 = def$4;


var oneOf = {
	default: _default$7
};

const def$3 = {
    keyword: "allOf",
    schemaType: "array",
    code(cxt) {
        const { gen, schema, it } = cxt;
        /* istanbul ignore if */
        if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
            if (util.alwaysValidSchema(it, sch))
                return;
            const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
            cxt.ok(valid);
            cxt.mergeEvaluated(schCxt);
        });
    },
};
var _default$6 = def$3;


var allOf = {
	default: _default$6
};

const error$2 = {
    message: ({ params }) => codegen.str `should match "${params.ifClause}" schema`,
    params: ({ params }) => codegen._ `{failingKeyword: ${params.ifClause}}`,
};
const def$2 = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    error: error$2,
    code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === undefined && parentSchema.else === undefined) {
            validate.checkStrictMode(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
            return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
            const ifClause = gen.let("ifClause");
            cxt.setParams({ ifClause });
            gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        }
        else if (hasThen) {
            gen.if(schValid, validateClause("then"));
        }
        else {
            gen.if(codegen.not(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
            const schCxt = cxt.subschema({
                keyword: "if",
                compositeRule: true,
                createErrors: false,
                allErrors: false,
            }, schValid);
            cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
            return () => {
                const schCxt = cxt.subschema({ keyword }, schValid);
                gen.assign(valid, schValid);
                cxt.mergeValidEvaluated(schCxt, valid);
                if (ifClause)
                    gen.assign(ifClause, codegen._ `${keyword}`);
                else
                    cxt.setParams({ ifClause: keyword });
            };
        }
    },
};
function hasSchema(it, keyword) {
    const schema = it.schema[keyword];
    return schema !== undefined && !util.alwaysValidSchema(it, schema);
}
var _default$5 = def$2;


var _if = {
	default: _default$5
};

const def$1 = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword, parentSchema, it }) {
        if (parentSchema.if === undefined)
            validate.checkStrictMode(it, `"${keyword}" without "if" is ignored`);
    },
};
var _default$4 = def$1;


var thenElse = {
	default: _default$4
};

const applicator = [
    // any
    not.default,
    anyOf.default,
    oneOf.default,
    allOf.default,
    _if.default,
    thenElse.default,
    // array
    additionalItems.default,
    items.default,
    contains.default,
    // object
    propertyNames.default,
    additionalProperties.default,
    dependencies.default,
    properties$1.default,
    patternProperties.default,
];
var _default$3 = applicator;


var applicator_1 = {
	default: _default$3
};

const error$1 = {
    message: ({ schemaCode }) => codegen.str `should match format "${schemaCode}"`,
    params: ({ schemaCode }) => codegen._ `{format: ${schemaCode}}`,
};
const def = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: true,
    error: error$1,
    code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
            return;
        if ($data)
            validate$DataFormat();
        else
            validateFormat();
        function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
                ref: self.formats,
                code: opts.code.formats,
            });
            const fDef = gen.const("fDef", codegen._ `${fmts}[${schemaCode}]`);
            const fType = gen.let("fType");
            const format = gen.let("format");
            // TODO simplify
            gen.if(codegen._ `typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, codegen._ `${fDef}.type || "string"`).assign(format, codegen._ `${fDef}.validate`), () => gen.assign(fType, codegen._ `"string"`).assign(format, fDef));
            cxt.fail$data(codegen.or(unknownFmt(), invalidFmt()));
            function unknownFmt() {
                if (opts.strict === false)
                    return codegen.nil;
                return codegen._ `${schemaCode} && !${format}`;
            }
            function invalidFmt() {
                const callFormat = schemaEnv.$async
                    ? codegen._ `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`
                    : codegen._ `${format}(${data})`;
                const validData = codegen._ `(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
                return codegen._ `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
            }
        }
        function validateFormat() {
            const formatDef = self.formats[schema];
            if (!formatDef) {
                unknownFormat();
                return;
            }
            if (formatDef === true)
                return;
            const [fmtType, format, fmtRef] = getFormat(formatDef);
            if (fmtType === ruleType)
                cxt.pass(validCondition());
            function unknownFormat() {
                if (opts.strict === false) {
                    self.logger.warn(unknownMsg());
                    return;
                }
                throw new Error(unknownMsg());
                function unknownMsg() {
                    return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
                }
            }
            function getFormat(fmtDef) {
                const fmt = gen.scopeValue("formats", {
                    key: schema,
                    ref: fmtDef,
                    code: opts.code.formats ? codegen._ `${opts.code.formats}${codegen.getProperty(schema)}` : undefined,
                });
                if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
                    return [fmtDef.type || "string", fmtDef.validate, codegen._ `${fmt}.validate`];
                }
                return ["string", fmtDef, fmt];
            }
            function validCondition() {
                if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
                    if (!schemaEnv.$async)
                        throw new Error("async format in sync schema");
                    return codegen._ `await ${fmtRef}(${data})`;
                }
                return typeof format == "function" ? codegen._ `${fmtRef}(${data})` : codegen._ `${fmtRef}.test(${data})`;
            }
        }
    },
};
var _default$2 = def;


var format$1 = {
	default: _default$2
};

const format = [format$1.default];
var _default$1 = format;


var format_2 = {
	default: _default$1
};

var metadata = createCommonjsModule(function (module, exports) {
exports.contentVocabulary = exports.metadataVocabulary = void 0;
exports.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples",
];
exports.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema",
];

});

const draft7Vocabularies = [
    core_1.default,
    validation_1.default,
    applicator_1.default,
    format_2.default,
    metadata.metadataVocabulary,
    metadata.contentVocabulary,
];
var _default = draft7Vocabularies;


var draft7 = {
	default: _default
};

var $schema = "http://json-schema.org/draft-07/schema#";
var $id = "http://json-schema.org/draft-07/schema#";
var title = "Core schema meta-schema";
var definitions = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	nonNegativeInteger: {
		type: "integer",
		minimum: 0
	},
	nonNegativeIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/nonNegativeInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		uniqueItems: true,
		"default": [
		]
	}
};
var type = [
	"object",
	"boolean"
];
var properties = {
	$id: {
		type: "string",
		format: "uri-reference"
	},
	$schema: {
		type: "string",
		format: "uri"
	},
	$ref: {
		type: "string",
		format: "uri-reference"
	},
	$comment: {
		type: "string"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": true,
	readOnly: {
		type: "boolean",
		"default": false
	},
	examples: {
		type: "array",
		items: true
	},
	multipleOf: {
		type: "number",
		exclusiveMinimum: 0
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "number"
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "number"
	},
	maxLength: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minLength: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	additionalItems: {
		$ref: "#"
	},
	items: {
		anyOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": true
	},
	maxItems: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minItems: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	contains: {
		$ref: "#"
	},
	maxProperties: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minProperties: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		$ref: "#"
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		propertyNames: {
			format: "regex"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	propertyNames: {
		$ref: "#"
	},
	"const": true,
	"enum": {
		type: "array",
		items: true,
		minItems: 1,
		uniqueItems: true
	},
	type: {
		anyOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	format: {
		type: "string"
	},
	contentMediaType: {
		type: "string"
	},
	contentEncoding: {
		type: "string"
	},
	"if": {
		$ref: "#"
	},
	then: {
		$ref: "#"
	},
	"else": {
		$ref: "#"
	},
	allOf: {
		$ref: "#/definitions/schemaArray"
	},
	anyOf: {
		$ref: "#/definitions/schemaArray"
	},
	oneOf: {
		$ref: "#/definitions/schemaArray"
	},
	not: {
		$ref: "#"
	}
};
var draft7MetaSchema = {
	$schema: $schema,
	$id: $id,
	title: title,
	definitions: definitions,
	type: type,
	properties: properties,
	"default": true
};

var ajv = createCommonjsModule(function (module, exports) {
exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;

exports.KeywordCxt = context.default;

Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen._; } });
Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen.str; } });
Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen.stringify; } });
Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen.nil; } });
Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen.Name; } });
Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen.CodeGen; } });



const META_SUPPORT_DATA = ["/properties"];
const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
class Ajv extends core$1.default {
    _addVocabularies() {
        super._addVocabularies();
        draft7.default.forEach((v) => this.addVocabulary(v));
    }
    _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
            return;
        const metaSchema = this.opts.$data
            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)
            : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
        return (this.opts.defaultMeta =
            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
    }
}
exports.default = Ajv;

});

var jsonRpc$1 = createCommonjsModule(function (module, exports) {
exports.isntJsonRpcError = exports.isJsonRpcError = exports.isntJsonRpcSuccess = exports.isJsonRpcSuccess = exports.isntJsonRpcRequest = exports.isJsonRpcRequest = exports.isntJsonRpcNotification = exports.isJsonRpcNotification = void 0;

const JsonRpcIdSchema = {
    oneOf: [
        { type: 'string' },
        { type: 'number' }
    ]
};
const JsonRpcParamsSchema = {
    oneOf: [
        { type: 'array' },
        { type: 'object' }
    ]
};
const JsonRpcNotificationSchema = {
    type: 'object',
    properties: {
        jsonrpc: { type: 'string' },
        method: { type: 'string' },
        params: JsonRpcParamsSchema,
        id: false
    },
    required: ['jsonrpc', 'method']
};
const JsonRpcRequestSchema = {
    type: 'object',
    properties: {
        jsonrpc: { type: 'string' },
        id: JsonRpcIdSchema,
        method: { type: 'string' },
        params: JsonRpcParamsSchema
    },
    required: ['jsonrpc', 'id', 'method']
};
const JsonRpcSuccessSchema = {
    type: 'object',
    properties: {
        jsonrpc: { type: 'string' },
        id: JsonRpcIdSchema,
        result: {}
    },
    required: ['jsonrpc', 'id', 'result']
};
const JsonRpcErrorObjectSchema = {
    type: 'object',
    properties: {
        code: { type: 'number' },
        message: { type: 'string' },
        data: {}
    },
    required: ['code', 'message']
};
const JsonRpcErrorSchema = {
    type: 'object',
    properties: {
        jsonrpc: { type: 'string' },
        id: JsonRpcIdSchema,
        error: JsonRpcErrorObjectSchema
    },
    required: ['jsonrpc', 'id', 'error']
};
let ajv$1;
function isJsonRpcNotification(val) {
    if (!ajv$1)
        ajv$1 = new ajv.default();
    return ajv$1.validate(JsonRpcNotificationSchema, val);
}
exports.isJsonRpcNotification = isJsonRpcNotification;
function isntJsonRpcNotification(val) {
    return !isJsonRpcNotification(val);
}
exports.isntJsonRpcNotification = isntJsonRpcNotification;
function isJsonRpcRequest(val) {
    if (!ajv$1)
        ajv$1 = new ajv.default();
    return ajv$1.validate(JsonRpcRequestSchema, val);
}
exports.isJsonRpcRequest = isJsonRpcRequest;
function isntJsonRpcRequest(val) {
    return !isJsonRpcRequest(val);
}
exports.isntJsonRpcRequest = isntJsonRpcRequest;
function isJsonRpcSuccess(val) {
    if (!ajv$1)
        ajv$1 = new ajv.default();
    return ajv$1.validate(JsonRpcSuccessSchema, val);
}
exports.isJsonRpcSuccess = isJsonRpcSuccess;
function isntJsonRpcSuccess(val) {
    return !isJsonRpcSuccess(val);
}
exports.isntJsonRpcSuccess = isntJsonRpcSuccess;
function isJsonRpcError(val) {
    if (!ajv$1)
        ajv$1 = new ajv.default();
    return ajv$1.validate(JsonRpcErrorSchema, val);
}
exports.isJsonRpcError = isJsonRpcError;
function isntJsonRpcError(val) {
    return !isJsonRpcError(val);
}
exports.isntJsonRpcError = isntJsonRpcError;

});

var json$1 = createCommonjsModule(function (module, exports) {
exports.isntJson = exports.isJson = void 0;
function isJson(val) {
    try {
        JSON.stringify(val);
        return true;
    }
    catch (_a) {
        return false;
    }
}
exports.isJson = isJson;
function isntJson(val) {
    return !isntJson();
}
exports.isntJson = isntJson;

});

var number = createCommonjsModule(function (module, exports) {
exports.isntNumber = exports.isNumber = void 0;
function isNumber(val) {
    return typeof val === 'number';
}
exports.isNumber = isNumber;
function isntNumber(val) {
    return !isNumber(val);
}
exports.isntNumber = isntNumber;

});

var object$1 = createCommonjsModule(function (module, exports) {
exports.isntObject = exports.isObject = void 0;
function isObject(val) {
    return val !== null && typeof val === 'object';
}
exports.isObject = isObject;
function isntObject(val) {
    return !isObject(val);
}
exports.isntObject = isntObject;

});

var url = createCommonjsModule(function (module, exports) {
exports.isAbsoluteURL = void 0;
function isAbsoluteURL(str) {
    try {
        new URL(str);
        return true;
    }
    catch (_a) {
        return false;
    }
}
exports.isAbsoluteURL = isAbsoluteURL;

});

var guards = createCommonjsModule(function (module, exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};__exportStar(asyncIterable, exports);
__exportStar(char$1, exports);
__exportStar(falsy$1, exports);
__exportStar(_function$1, exports);
__exportStar(iterable, exports);
__exportStar(jsonRpc$1, exports);
__exportStar(json$1, exports);
__exportStar(_null, exports);
__exportStar(number, exports);
__exportStar(object$1, exports);
__exportStar(string, exports);
__exportStar(_undefined, exports);
__exportStar(url, exports);

});

var array = /*#__PURE__*/Object.freeze({
    __proto__: null
});

var char = /*#__PURE__*/Object.freeze({
    __proto__: null
});

var dict = /*#__PURE__*/Object.freeze({
    __proto__: null
});

var falsy = /*#__PURE__*/Object.freeze({
    __proto__: null
});

var _function = /*#__PURE__*/Object.freeze({
    __proto__: null
});

var generic = /*#__PURE__*/Object.freeze({
    __proto__: null
});

var getter = /*#__PURE__*/Object.freeze({
    __proto__: null
});

var jsonRpc = /*#__PURE__*/Object.freeze({
    __proto__: null
});

var json = /*#__PURE__*/Object.freeze({
    __proto__: null
});

var object = /*#__PURE__*/Object.freeze({
    __proto__: null
});

var setter = /*#__PURE__*/Object.freeze({
    __proto__: null
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(array);

var require$$1 = /*@__PURE__*/getAugmentedNamespace(char);

var require$$2 = /*@__PURE__*/getAugmentedNamespace(dict);

var require$$3 = /*@__PURE__*/getAugmentedNamespace(falsy);

var require$$4 = /*@__PURE__*/getAugmentedNamespace(_function);

var require$$5 = /*@__PURE__*/getAugmentedNamespace(generic);

var require$$6 = /*@__PURE__*/getAugmentedNamespace(getter);

var require$$7 = /*@__PURE__*/getAugmentedNamespace(jsonRpc);

var require$$8 = /*@__PURE__*/getAugmentedNamespace(json);

var require$$9 = /*@__PURE__*/getAugmentedNamespace(object);

var require$$10 = /*@__PURE__*/getAugmentedNamespace(setter);

var interfaces = createCommonjsModule(function (module, exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};__exportStar(require$$0, exports);
__exportStar(require$$1, exports);
__exportStar(require$$2, exports);
__exportStar(require$$3, exports);
__exportStar(require$$4, exports);
__exportStar(require$$5, exports);
__exportStar(require$$6, exports);
__exportStar(require$$7, exports);
__exportStar(require$$8, exports);
__exportStar(require$$9, exports);
__exportStar(require$$10, exports);

});

var es2018$4 = createCommonjsModule(function (module, exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};__exportStar(guards, exports);
__exportStar(interfaces, exports);

});

var _locked, _count, _awaiting;
class Semaphore {
    constructor(count) {
        _locked.set(this, 0);
        _count.set(this, void 0);
        _awaiting.set(this, new SignalGroup());
        __classPrivateFieldSet(this, _count, count);
    }
    acquire(handler) {
        if (es2018$4.isFunction(handler)) {
            (() => __awaiter(this, void 0, void 0, function* () {
                yield this.lock();
                yield handler();
                this.unlock();
            }))();
        }
        else {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                yield this.lock();
                resolve(oneShot(() => this.unlock()));
            }));
        }
    }
    lock() {
        return __awaiter(this, void 0, void 0, function* () {
            while (this.isLocked()) {
                const unlockSignal = new Signal();
                __classPrivateFieldGet(this, _awaiting).add(unlockSignal);
                yield unlockSignal;
                __classPrivateFieldGet(this, _awaiting).remove(unlockSignal);
            }
            __classPrivateFieldSet(this, _locked, +__classPrivateFieldGet(this, _locked) + 1);
        });
    }
    unlock() {
        __classPrivateFieldSet(this, _locked, +__classPrivateFieldGet(this, _locked) - 1);
        __classPrivateFieldGet(this, _awaiting).emitAll();
    }
    isLocked() {
        return __classPrivateFieldGet(this, _count) - __classPrivateFieldGet(this, _locked) === 0;
    }
}
_locked = new WeakMap(), _count = new WeakMap(), _awaiting = new WeakMap();
function oneShot(fn) {
    let used = false;
    return () => {
        if (!used) {
            used = true;
            fn();
        }
    };
}

class Mutex extends Semaphore {
    constructor() {
        super(1);
    }
}

var _registry;
class DebounceMicrotask {
    constructor() {
        _registry.set(this, new WeakSet());
    }
    queue(fn) {
        if (__classPrivateFieldGet(this, _registry).has(fn))
            return;
        __classPrivateFieldGet(this, _registry).add(fn);
        queueMicrotask(() => {
            if (__classPrivateFieldGet(this, _registry).has(fn)) {
                try {
                    fn();
                }
                finally {
                    __classPrivateFieldGet(this, _registry).delete(fn);
                }
            }
        });
    }
    cancel(fn) {
        __classPrivateFieldGet(this, _registry).delete(fn);
    }
}
_registry = new WeakMap();

var getErrorResult_1 = createCommonjsModule(function (module, exports) {
exports.getErrorResult = void 0;
function getErrorResult(fn) {
    try {
        const result = fn();
        return [void 0, result];
    }
    catch (e) {
        return [e, void 0];
    }
}
exports.getErrorResult = getErrorResult;

});

var getErrorResultAsync_1 = createCommonjsModule(function (module, exports) {
exports.getErrorResultAsync = void 0;
async function getErrorResultAsync(fn) {
    try {
        const result = await fn();
        return [void 0, result];
    }
    catch (e) {
        return [e, void 0];
    }
}
exports.getErrorResultAsync = getErrorResultAsync;

});

var getErrorResultPromise_1 = createCommonjsModule(function (module, exports) {
exports.getErrorResultPromise = void 0;
async function getErrorResultPromise(promise) {
    try {
        const result = await promise;
        return [void 0, result];
    }
    catch (e) {
        return [e, void 0];
    }
}
exports.getErrorResultPromise = getErrorResultPromise;

});

var getResultError_1 = createCommonjsModule(function (module, exports) {
exports.getResultError = void 0;
function getResultError(fn) {
    try {
        const result = fn();
        return [result, void 0];
    }
    catch (e) {
        return [void 0, e];
    }
}
exports.getResultError = getResultError;

});

var getResultErrorAsync_1 = createCommonjsModule(function (module, exports) {
exports.getResultErrorAsync = void 0;
async function getResultErrorAsync(fn) {
    try {
        const result = await fn();
        return [result, void 0];
    }
    catch (e) {
        return [void 0, e];
    }
}
exports.getResultErrorAsync = getResultErrorAsync;

});

var getResultErrorPromise_1 = createCommonjsModule(function (module, exports) {
exports.getResultErrorPromise = void 0;
async function getResultErrorPromise(promise) {
    try {
        const result = await promise;
        return [result, void 0];
    }
    catch (e) {
        return [void 0, e];
    }
}
exports.getResultErrorPromise = getResultErrorPromise;

});

var getSuccess_1 = createCommonjsModule(function (module, exports) {
exports.getSuccess = void 0;
function getSuccess(fn) {
    try {
        const result = fn();
        return [true, result];
    }
    catch (_a) {
        return [false, void 0];
    }
}
exports.getSuccess = getSuccess;

});

var getSuccessAsync_1 = createCommonjsModule(function (module, exports) {
exports.getSuccessAsync = void 0;
async function getSuccessAsync(fn) {
    try {
        const result = await fn();
        return [true, result];
    }
    catch (_a) {
        return [false, void 0];
    }
}
exports.getSuccessAsync = getSuccessAsync;

});

var getSuccessPromise_1 = createCommonjsModule(function (module, exports) {
exports.getSuccessPromise = void 0;
async function getSuccessPromise(promise) {
    try {
        const result = await promise;
        return [true, result];
    }
    catch (_a) {
        return [false, void 0];
    }
}
exports.getSuccessPromise = getSuccessPromise;

});

var getFailure_1 = createCommonjsModule(function (module, exports) {
exports.getFailure = void 0;
function getFailure(fn) {
    try {
        fn();
        return [false, void 0];
    }
    catch (e) {
        return [true, e];
    }
}
exports.getFailure = getFailure;

});

var getFailureAsync_1 = createCommonjsModule(function (module, exports) {
exports.getFailureAsync = void 0;
async function getFailureAsync(fn) {
    try {
        await fn();
        return [false, void 0];
    }
    catch (e) {
        return [true, e];
    }
}
exports.getFailureAsync = getFailureAsync;

});

var getFailurePromise_1 = createCommonjsModule(function (module, exports) {
exports.getFailurePromise = void 0;
async function getFailurePromise(promise) {
    try {
        await promise;
        return [false, void 0];
    }
    catch (e) {
        return [true, e];
    }
}
exports.getFailurePromise = getFailurePromise;

});

var isSuccess_1 = createCommonjsModule(function (module, exports) {
exports.isSuccess = void 0;
function isSuccess(fn) {
    try {
        fn();
        return true;
    }
    catch (_a) {
        return false;
    }
}
exports.isSuccess = isSuccess;

});

var isSuccessAsync_1 = createCommonjsModule(function (module, exports) {
exports.isSuccessAsync = void 0;
async function isSuccessAsync(fn) {
    try {
        await fn();
        return true;
    }
    catch (_a) {
        return false;
    }
}
exports.isSuccessAsync = isSuccessAsync;

});

var isSuccessPromise_1 = createCommonjsModule(function (module, exports) {
exports.isSuccessPromise = void 0;
async function isSuccessPromise(promise) {
    try {
        await promise;
        return true;
    }
    catch (_a) {
        return false;
    }
}
exports.isSuccessPromise = isSuccessPromise;

});

var isFailure_1 = createCommonjsModule(function (module, exports) {
exports.isFailure = void 0;
function isFailure(fn) {
    try {
        fn();
        return false;
    }
    catch (_a) {
        return true;
    }
}
exports.isFailure = isFailure;

});

var isFailureAsync_1 = createCommonjsModule(function (module, exports) {
exports.isFailureAsync = void 0;
async function isFailureAsync(fn) {
    try {
        await fn();
        return false;
    }
    catch (_a) {
        return true;
    }
}
exports.isFailureAsync = isFailureAsync;

});

var isFailurePromise_1 = createCommonjsModule(function (module, exports) {
exports.isFailurePromise = void 0;
async function isFailurePromise(promise) {
    try {
        await promise;
        return false;
    }
    catch (_a) {
        return true;
    }
}
exports.isFailurePromise = isFailurePromise;

});

var getResult_1 = createCommonjsModule(function (module, exports) {
exports.getResult = void 0;
function getResult(fn) {
    try {
        return fn();
    }
    catch (_a) {
        return;
    }
}
exports.getResult = getResult;

});

var getResultAsync_1 = createCommonjsModule(function (module, exports) {
exports.getResultAsync = void 0;
async function getResultAsync(fn) {
    try {
        return await fn();
    }
    catch (_a) {
        return undefined;
    }
}
exports.getResultAsync = getResultAsync;

});

var getResultPromise_1 = createCommonjsModule(function (module, exports) {
exports.getResultPromise = void 0;
async function getResultPromise(promise) {
    try {
        return await promise;
    }
    catch (_a) {
        return;
    }
}
exports.getResultPromise = getResultPromise;

});

var getError_1 = createCommonjsModule(function (module, exports) {
exports.getError = void 0;
function getError(fn) {
    try {
        fn();
    }
    catch (syncError) {
        return syncError;
    }
    return;
}
exports.getError = getError;

});

var getErrorAsync_1 = createCommonjsModule(function (module, exports) {
exports.getErrorAsync = void 0;
async function getErrorAsync(fn) {
    try {
        await fn();
    }
    catch (err) {
        return err;
    }
    return;
}
exports.getErrorAsync = getErrorAsync;

});

var getErrorPromise_1 = createCommonjsModule(function (module, exports) {
exports.getErrorPromise = void 0;
async function getErrorPromise(promise) {
    try {
        await promise;
    }
    catch (err) {
        return err;
    }
    return;
}
exports.getErrorPromise = getErrorPromise;

});

var getErrorAsyncIterable_1 = createCommonjsModule(function (module, exports) {
exports.getErrorAsyncIterable = void 0;
async function getErrorAsyncIterable(iterable) {
    try {
        for await (const _ of iterable) { }
    }
    catch (promiseError) {
        return promiseError;
    }
    return;
}
exports.getErrorAsyncIterable = getErrorAsyncIterable;

});

var result = createCommonjsModule(function (module, exports) {
var __classPrivateFieldSet = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _value, _value_1;exports.Result = void 0;
class Result {
    static Ok(value) {
        return Ok.of(value);
    }
    static Err(error) {
        return Err.of(error);
    }
}
exports.Result = Result;
class Ok extends Result {
    constructor(value) {
        super();
        _value.set(this, void 0);
        __classPrivateFieldSet(this, _value, value);
    }
    static of(value) {
        return new Ok(value);
    }
    isOk() {
        return true;
    }
    isErr() {
        return false;
    }
    onOk(callback) {
        callback(__classPrivateFieldGet(this, _value));
        return Ok.of(__classPrivateFieldGet(this, _value));
    }
    onErr() {
        return Ok.of(__classPrivateFieldGet(this, _value));
    }
    orElse() {
        return Ok.of(__classPrivateFieldGet(this, _value));
    }
    map(fn) {
        return Ok.of(fn(__classPrivateFieldGet(this, _value)));
    }
    get() {
        return __classPrivateFieldGet(this, _value);
    }
}
_value = new WeakMap();
class Err extends Result {
    constructor(err) {
        super();
        _value_1.set(this, void 0);
        __classPrivateFieldSet(this, _value_1, err);
    }
    static of(error) {
        return new Err(error);
    }
    isOk() {
        return false;
    }
    isErr() {
        return true;
    }
    onOk() {
        return Err.of(__classPrivateFieldGet(this, _value_1));
    }
    onErr(callback) {
        callback(__classPrivateFieldGet(this, _value_1));
        return Err.of(__classPrivateFieldGet(this, _value_1));
    }
    orElse(defaultValue) {
        return Ok.of(defaultValue);
    }
    map() {
        return Err.of(__classPrivateFieldGet(this, _value_1));
    }
    get() {
        throw __classPrivateFieldGet(this, _value_1);
    }
}
_value_1 = new WeakMap();

});

var toResult_1 = createCommonjsModule(function (module, exports) {
exports.toResult = void 0;

function toResult(fn) {
    try {
        const result$1 = fn();
        return result.Result.Ok(result$1);
    }
    catch (e) {
        return result.Result.Err(e);
    }
}
exports.toResult = toResult;

});

var asyncResult = createCommonjsModule(function (module, exports) {
var __classPrivateFieldSet = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _promise;exports.AsyncResult = void 0;





class AsyncResult {
    constructor(promise) {
        _promise.set(this, void 0);
        __classPrivateFieldSet(this, _promise, Promise.resolve(promise));
    }
    static Ok(value) {
        return AsyncOk.of(value);
    }
    static Err(error) {
        return AsyncErr.of(error);
    }
    get then() {
        const promise = __classPrivateFieldGet(this, _promise).then(x => result.Result.Ok(x), x => result.Result.Err(x));
        return promise.then.bind(promise);
    }
    onOk(callback) {
        (async () => {
            const [succ, ret] = await getSuccessPromise_1.getSuccessPromise(__classPrivateFieldGet(this, _promise));
            if (succ)
                callback(ret);
        })();
        return new AsyncResult(__classPrivateFieldGet(this, _promise));
    }
    onErr(callback) {
        (async () => {
            const [fail, err] = await getFailurePromise_1.getFailurePromise(__classPrivateFieldGet(this, _promise));
            if (fail)
                callback(err);
        })();
        return new AsyncResult(__classPrivateFieldGet(this, _promise));
    }
    async isOk() {
        return await isSuccessPromise_1.isSuccessPromise(__classPrivateFieldGet(this, _promise));
    }
    async isErr() {
        return await isFailurePromise_1.isFailurePromise(__classPrivateFieldGet(this, _promise));
    }
    orElse(defaultValue) {
        return new AsyncResult((async () => {
            try {
                return await __classPrivateFieldGet(this, _promise);
            }
            catch (_a) {
                return defaultValue;
            }
        })());
    }
    map(mapper) {
        return new AsyncResult((async () => {
            const result = await __classPrivateFieldGet(this, _promise);
            return mapper(result);
        })());
    }
    async get() {
        return await __classPrivateFieldGet(this, _promise);
    }
}
exports.AsyncResult = AsyncResult;
_promise = new WeakMap();
class AsyncOk extends AsyncResult {
    static of(value) {
        return new AsyncOk(value);
    }
    constructor(value) {
        super(Promise.resolve(value));
    }
}
class AsyncErr extends AsyncResult {
    static of(value) {
        return new AsyncErr(value);
    }
    constructor(err) {
        super(Promise.reject(err));
    }
}

});

var toResultAsync_1 = createCommonjsModule(function (module, exports) {
exports.toResultAsync = void 0;

function toResultAsync(fn) {
    try {
        const result = fn();
        return new asyncResult.AsyncResult(result);
    }
    catch (e) {
        return asyncResult.AsyncResult.Err(e);
    }
}
exports.toResultAsync = toResultAsync;

});

var toResultPromise_1 = createCommonjsModule(function (module, exports) {
exports.toResultPromise = void 0;

function toResultPromise(promise) {
    return new asyncResult.AsyncResult(promise);
}
exports.toResultPromise = toResultPromise;

});

var optional = createCommonjsModule(function (module, exports) {
var __classPrivateFieldSet = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _value;exports.Optional = void 0;
class Optional {
    static Some(value) {
        return Some.of(value);
    }
    static None() {
        return None.of();
    }
}
exports.Optional = Optional;
class Some extends Optional {
    constructor(value) {
        super();
        _value.set(this, void 0);
        __classPrivateFieldSet(this, _value, value);
    }
    static of(value) {
        return new Some(value);
    }
    isSome() {
        return true;
    }
    isNone() {
        return false;
    }
    onSome(callback) {
        callback(__classPrivateFieldGet(this, _value));
        return Some.of(__classPrivateFieldGet(this, _value));
    }
    onNone() {
        return Some.of(__classPrivateFieldGet(this, _value));
    }
    orElse() {
        return Some.of(__classPrivateFieldGet(this, _value));
    }
    map(mapper) {
        return Some.of(mapper(__classPrivateFieldGet(this, _value)));
    }
    filter(predicate) {
        if (predicate(__classPrivateFieldGet(this, _value))) {
            return Some.of(__classPrivateFieldGet(this, _value));
        }
        else {
            return None.of();
        }
    }
    get() {
        return __classPrivateFieldGet(this, _value);
    }
}
_value = new WeakMap();
class None extends Optional {
    static of() {
        return new None();
    }
    constructor() {
        super();
    }
    isSome() {
        return false;
    }
    isNone() {
        return true;
    }
    onSome() {
        return None.of();
    }
    onNone(callback) {
        callback();
        return None.of();
    }
    orElse(defaultValue) {
        return Some.of(defaultValue);
    }
    map() {
        return None.of();
    }
    filter() {
        return None.of();
    }
    get() {
        throw new Error('Cannot get value from None');
    }
}

});

var toOptional_1 = createCommonjsModule(function (module, exports) {
exports.toOptional = exports.toOptionalPartial = void 0;

function toOptionalPartial(isNone) {
    return (fn) => toOptional(fn, isNone);
}
exports.toOptionalPartial = toOptionalPartial;
function toOptional(fn, isNone) {
    const result = fn();
    if (isNone(result)) {
        return optional.Optional.None();
    }
    else {
        return optional.Optional.Some(result);
    }
}
exports.toOptional = toOptional;

});

var asyncOptional = createCommonjsModule(function (module, exports) {
var __classPrivateFieldSet = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _promise;exports.AsyncOptional = exports.Nil = void 0;

exports.Nil = Symbol();
class AsyncOptional {
    constructor(promise) {
        _promise.set(this, void 0);
        __classPrivateFieldSet(this, _promise, Promise.resolve(promise));
    }
    static Some(value) {
        return AsyncSome.of(value);
    }
    static None() {
        return AsyncNone.of();
    }
    get then() {
        const promise = __classPrivateFieldGet(this, _promise).then(x => x === exports.Nil
            ? optional.Optional.None()
            : optional.Optional.Some(x));
        return promise.then.bind(promise);
    }
    onSome(callback) {
        (async () => {
            const result = await __classPrivateFieldGet(this, _promise);
            if (result !== exports.Nil)
                callback(result);
        })();
        return new AsyncOptional(__classPrivateFieldGet(this, _promise));
    }
    onNone(callback) {
        (async () => {
            const result = await __classPrivateFieldGet(this, _promise);
            if (result === exports.Nil)
                callback();
        })();
        return new AsyncOptional(__classPrivateFieldGet(this, _promise));
    }
    async isSome() {
        const result = await __classPrivateFieldGet(this, _promise);
        return result !== exports.Nil;
    }
    async isNone() {
        const result = await __classPrivateFieldGet(this, _promise);
        return result === exports.Nil;
    }
    orElse(defaultValue) {
        return new AsyncOptional((async () => {
            const result = await __classPrivateFieldGet(this, _promise);
            if (result === exports.Nil)
                return defaultValue;
            return result;
        })());
    }
    map(mapper) {
        return new AsyncOptional((async () => {
            const result = await __classPrivateFieldGet(this, _promise);
            if (result === exports.Nil)
                return exports.Nil;
            return mapper(result);
        })());
    }
    filter(predicate) {
        return new AsyncOptional((async () => {
            const result = await __classPrivateFieldGet(this, _promise);
            if (result === exports.Nil)
                return exports.Nil;
            if (predicate(result))
                return result;
            return exports.Nil;
        })());
    }
    async get() {
        const result = await __classPrivateFieldGet(this, _promise);
        if (result === exports.Nil)
            throw new Error('Cannot get value from None');
        return result;
    }
}
exports.AsyncOptional = AsyncOptional;
_promise = new WeakMap();
class AsyncNone extends AsyncOptional {
    static of() {
        return new AsyncNone();
    }
    constructor() {
        super(Promise.resolve(exports.Nil));
    }
}
class AsyncSome extends AsyncOptional {
    static of(value) {
        return new AsyncSome(value);
    }
    constructor(value) {
        super(Promise.resolve(value));
    }
}

});

var toOptionalAsync_1 = createCommonjsModule(function (module, exports) {
exports.toOptionalAsync = exports.toOptionalAsyncPartial = void 0;

function toOptionalAsyncPartial(isNone) {
    return (fn) => toOptionalAsync(fn, isNone);
}
exports.toOptionalAsyncPartial = toOptionalAsyncPartial;
function toOptionalAsync(fn, isNone) {
    return new asyncOptional.AsyncOptional((async () => {
        const result = await fn();
        if (isNone(result))
            return asyncOptional.Nil;
        return result;
    })());
}
exports.toOptionalAsync = toOptionalAsync;

});

var toOptionalPromise_1 = createCommonjsModule(function (module, exports) {
exports.toOptionalPromise = exports.toOptionalPromisePartial = void 0;

function toOptionalPromisePartial(isNone) {
    return (promise) => toOptionalPromise(promise, isNone);
}
exports.toOptionalPromisePartial = toOptionalPromisePartial;
function toOptionalPromise(promise, isNone) {
    return new asyncOptional.AsyncOptional((async () => {
        const result = await promise;
        if (isNone(result))
            return asyncOptional.Nil;
        return result;
    })());
}
exports.toOptionalPromise = toOptionalPromise;

});

var es2018$3 = createCommonjsModule(function (module, exports) {
exports.toOptionalPromisePartial = exports.toOptionalPromise = exports.toOptionalAsyncPartial = exports.toOptionalAsync = exports.toOptionalPartial = exports.toOptional = exports.toResultPromise = exports.toResultAsync = exports.toResult = exports.getErrorAsyncIterable = exports.getErrorPromise = exports.getErrorAsync = exports.getError = exports.getResultPromise = exports.getResultAsync = exports.getResult = exports.isFailurePromise = exports.isFailureAsync = exports.isFailure = exports.isSuccessPromise = exports.isSuccessAsync = exports.isSuccess = exports.getFailurePromise = exports.getFailureAsync = exports.getFailure = exports.getSuccessPromise = exports.getSuccessAsync = exports.getSuccess = exports.getResultErrorPromise = exports.getResultErrorAsync = exports.getResultError = exports.getErrorResultPromise = exports.getErrorResultAsync = exports.getErrorResult = void 0;

Object.defineProperty(exports, "getErrorResult", { enumerable: true, get: function () { return getErrorResult_1.getErrorResult; } });

Object.defineProperty(exports, "getErrorResultAsync", { enumerable: true, get: function () { return getErrorResultAsync_1.getErrorResultAsync; } });

Object.defineProperty(exports, "getErrorResultPromise", { enumerable: true, get: function () { return getErrorResultPromise_1.getErrorResultPromise; } });

Object.defineProperty(exports, "getResultError", { enumerable: true, get: function () { return getResultError_1.getResultError; } });

Object.defineProperty(exports, "getResultErrorAsync", { enumerable: true, get: function () { return getResultErrorAsync_1.getResultErrorAsync; } });

Object.defineProperty(exports, "getResultErrorPromise", { enumerable: true, get: function () { return getResultErrorPromise_1.getResultErrorPromise; } });

Object.defineProperty(exports, "getSuccess", { enumerable: true, get: function () { return getSuccess_1.getSuccess; } });

Object.defineProperty(exports, "getSuccessAsync", { enumerable: true, get: function () { return getSuccessAsync_1.getSuccessAsync; } });

Object.defineProperty(exports, "getSuccessPromise", { enumerable: true, get: function () { return getSuccessPromise_1.getSuccessPromise; } });

Object.defineProperty(exports, "getFailure", { enumerable: true, get: function () { return getFailure_1.getFailure; } });

Object.defineProperty(exports, "getFailureAsync", { enumerable: true, get: function () { return getFailureAsync_1.getFailureAsync; } });

Object.defineProperty(exports, "getFailurePromise", { enumerable: true, get: function () { return getFailurePromise_1.getFailurePromise; } });

Object.defineProperty(exports, "isSuccess", { enumerable: true, get: function () { return isSuccess_1.isSuccess; } });

Object.defineProperty(exports, "isSuccessAsync", { enumerable: true, get: function () { return isSuccessAsync_1.isSuccessAsync; } });

Object.defineProperty(exports, "isSuccessPromise", { enumerable: true, get: function () { return isSuccessPromise_1.isSuccessPromise; } });

Object.defineProperty(exports, "isFailure", { enumerable: true, get: function () { return isFailure_1.isFailure; } });

Object.defineProperty(exports, "isFailureAsync", { enumerable: true, get: function () { return isFailureAsync_1.isFailureAsync; } });

Object.defineProperty(exports, "isFailurePromise", { enumerable: true, get: function () { return isFailurePromise_1.isFailurePromise; } });

Object.defineProperty(exports, "getResult", { enumerable: true, get: function () { return getResult_1.getResult; } });

Object.defineProperty(exports, "getResultAsync", { enumerable: true, get: function () { return getResultAsync_1.getResultAsync; } });

Object.defineProperty(exports, "getResultPromise", { enumerable: true, get: function () { return getResultPromise_1.getResultPromise; } });

Object.defineProperty(exports, "getError", { enumerable: true, get: function () { return getError_1.getError; } });

Object.defineProperty(exports, "getErrorAsync", { enumerable: true, get: function () { return getErrorAsync_1.getErrorAsync; } });

Object.defineProperty(exports, "getErrorPromise", { enumerable: true, get: function () { return getErrorPromise_1.getErrorPromise; } });

Object.defineProperty(exports, "getErrorAsyncIterable", { enumerable: true, get: function () { return getErrorAsyncIterable_1.getErrorAsyncIterable; } });

Object.defineProperty(exports, "toResult", { enumerable: true, get: function () { return toResult_1.toResult; } });

Object.defineProperty(exports, "toResultAsync", { enumerable: true, get: function () { return toResultAsync_1.toResultAsync; } });

Object.defineProperty(exports, "toResultPromise", { enumerable: true, get: function () { return toResultPromise_1.toResultPromise; } });

Object.defineProperty(exports, "toOptional", { enumerable: true, get: function () { return toOptional_1.toOptional; } });
Object.defineProperty(exports, "toOptionalPartial", { enumerable: true, get: function () { return toOptional_1.toOptionalPartial; } });

Object.defineProperty(exports, "toOptionalAsync", { enumerable: true, get: function () { return toOptionalAsync_1.toOptionalAsync; } });
Object.defineProperty(exports, "toOptionalAsyncPartial", { enumerable: true, get: function () { return toOptionalAsync_1.toOptionalAsyncPartial; } });

Object.defineProperty(exports, "toOptionalPromise", { enumerable: true, get: function () { return toOptionalPromise_1.toOptionalPromise; } });
Object.defineProperty(exports, "toOptionalPromisePartial", { enumerable: true, get: function () { return toOptionalPromise_1.toOptionalPromisePartial; } });

});

class InvalidArgumentError extends es2018$5.CustomError {
    constructor(name, expected) {
        if (expected) {
            super(`${name} argument must be ${expected}`);
        }
        else {
            super(`Invalid ${name} value`);
        }
    }
}
class InvalidArgumentsLengthError extends es2018$5.CustomError {
    constructor(name, minimum, got) {
        super(`${name} requires at least ${pluralize('argument', minimum)}, but only ${pluralize('was', got)} passed`);
    }
}
function pluralize(word, count) {
    if (count !== 1) {
        switch (word) {
            case 'was':
                word = 'were';
                break;
            default: word = word + 's';
        }
    }
    return `${count} ${word}`;
}
class ChannelClosedError extends es2018$5.CustomError {
}

// Technically, it is the `BufferedChannel(0)`
class Channel {
    constructor() {
        this.isClosed = false;
        this.writeLock = new Mutex();
        this.writeSignalGroup = new SignalGroup();
        this.readSignalGroup = new SignalGroup();
        this.box = [];
    }
    // signal的关键在于, 能够阻止以下两件事发生:
    // 1. 撤销已经入列, 但还未出列的项目(需要有一个可以精准撤销项目的有序队列)
    // 2. 撤销还未入列的项目(简单, 可在获取锁时通过事件决定取消)
    send(value) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isClosed)
                throw new ChannelClosedError();
            const release = yield this.writeLock.acquire();
            const readSignal = new Signal();
            this.readSignalGroup.add(readSignal);
            try {
                // 双重检查
                if (this.isClosed)
                    throw new ChannelClosedError();
                this.box.push(value);
                this.writeSignalGroup.emitAll();
                // 等待receive发出读取信号
                if (yield es2018$3.isFailurePromise(readSignal)) {
                    // 删除值
                    this.box.pop();
                    throw new ChannelClosedError();
                }
            }
            finally {
                this.readSignalGroup.remove(readSignal);
                release();
            }
        });
    }
    receive() {
        return {
            [Symbol.asyncIterator]: () => {
                return {
                    next: () => __awaiter(this, void 0, void 0, function* () {
                        while (this.box.length === 0) {
                            // 如果通道关闭, 则停止接收
                            if (this.isClosed)
                                return { done: true, value: undefined };
                            const writeSignal = new Signal();
                            this.writeSignalGroup.add(writeSignal);
                            try {
                                // 等待send发出写入信号, 如果通道关闭, 则停止接收
                                if (yield es2018$3.isFailurePromise(writeSignal))
                                    return { done: true, value: undefined };
                            }
                            finally {
                                this.writeSignalGroup.remove(writeSignal);
                            }
                        }
                        const value = this.box.pop();
                        this.readSignalGroup.emitAll();
                        return { done: false, value };
                    })
                };
            }
        };
    }
    close() {
        if (!this.isClosed) {
            this.isClosed = true;
            this.writeSignalGroup.discardAll();
            this.readSignalGroup.discardAll();
        }
    }
}

var cons = createCommonjsModule(function (module, exports) {
exports.convertConsToArray = void 0;
function convertConsToArray([value, next]) {
    if (next === null)
        return [value];
    return [value, ...convertConsToArray(next)];
}
exports.convertConsToArray = convertConsToArray;

});

var emitter = createCommonjsModule(function (module, exports) {
var __classPrivateFieldGet = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _map;exports.Emitter = void 0;
class Emitter {
    constructor() {
        _map.set(this, new Map());
    }
    on(event, handler) {
        if (!__classPrivateFieldGet(this, _map).has(event))
            __classPrivateFieldGet(this, _map).set(event, new Set());
        const set = __classPrivateFieldGet(this, _map).get(event);
        set.add(handler);
    }
    off(event, handler) {
        if (__classPrivateFieldGet(this, _map).has(event)) {
            const set = __classPrivateFieldGet(this, _map).get(event);
            set.delete(handler);
            if (set.size === 0)
                __classPrivateFieldGet(this, _map).delete(event);
        }
    }
    emit(event, value) {
        if (__classPrivateFieldGet(this, _map).has(event)) {
            const set = __classPrivateFieldGet(this, _map).get(event);
            set.forEach(cb => cb(value));
        }
    }
}
exports.Emitter = Emitter;
_map = new WeakMap();

});

var hashSet = createCommonjsModule(function (module, exports) {
var __classPrivateFieldGet = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _map;exports.HashSet = void 0;
class HashSet {
    constructor(hash) {
        this.hash = hash;
        _map.set(this, new Map());
    }
    add(value) {
        __classPrivateFieldGet(this, _map).set(this.hash(value), value);
        return this;
    }
    delete(value) {
        return __classPrivateFieldGet(this, _map).delete(this.hash(value));
    }
    has(value) {
        return __classPrivateFieldGet(this, _map).has(this.hash(value));
    }
    clear() {
        __classPrivateFieldGet(this, _map).clear();
    }
    values() {
        return __classPrivateFieldGet(this, _map).values();
    }
    get size() {
        return __classPrivateFieldGet(this, _map).size;
    }
    get [(_map = new WeakMap(), Symbol.toStringTag)]() {
        return this.constructor.name;
    }
    [Symbol.iterator]() {
        return __classPrivateFieldGet(this, _map).values();
    }
}
exports.HashSet = HashSet;

});

var queue = createCommonjsModule(function (module, exports) {
var __classPrivateFieldGet = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _items;exports.EmptyQueueError = exports.Queue = void 0;

class Queue {
    constructor() {
        _items.set(this, []);
    }
    empty() {
        __classPrivateFieldGet(this, _items).length = 0;
    }
    enqueue(...items) {
        __classPrivateFieldGet(this, _items).push(...items);
    }
    dequeue() {
        if (this.size === 0)
            throw new EmptyQueueError();
        return __classPrivateFieldGet(this, _items).shift();
    }
    get size() {
        return __classPrivateFieldGet(this, _items).length;
    }
}
exports.Queue = Queue;
_items = new WeakMap();
class EmptyQueueError extends es2018$5.CustomError {
    constructor() {
        super('Queue is empty.');
    }
}
exports.EmptyQueueError = EmptyQueueError;

});

var es2018$2 = createCommonjsModule(function (module, exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};__exportStar(cons, exports);
__exportStar(emitter, exports);
__exportStar(hashSet, exports);
__exportStar(queue, exports);

});

class BufferedChannel {
    constructor(bufferSize) {
        this.bufferSize = bufferSize;
        this.isClosed = false;
        this.enqueueSingalGroup = new SignalGroup();
        this.dequeueSignalGroup = new SignalGroup();
        this.buffer = new es2018$2.Queue();
    }
    send(value) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isClosed)
                throw new ChannelClosedError();
            // 缓冲区队列已满, 则等待出列信号
            while (this.buffer.size === this.bufferSize) {
                const dequeueSignal = new Signal();
                this.dequeueSignalGroup.add(dequeueSignal);
                try {
                    // 等待出列信号, 如果通道关闭, 则抛出错误
                    if (yield es2018$3.isFailurePromise(dequeueSignal))
                        throw new ChannelClosedError();
                }
                finally {
                    this.dequeueSignalGroup.remove(dequeueSignal);
                }
                // 对通道关闭的双重检查
                if (this.isClosed)
                    throw new ChannelClosedError();
            }
            this.buffer.enqueue(value);
            this.enqueueSingalGroup.emitAll();
        });
    }
    receive() {
        return {
            [Symbol.asyncIterator]: () => {
                return {
                    next: () => __awaiter(this, void 0, void 0, function* () {
                        // 缓冲区队列为空, 则等待入列信号
                        while (this.buffer.size === 0) {
                            if (this.isClosed)
                                return { done: true, value: undefined };
                            const enqueueSignal = new Signal();
                            this.enqueueSingalGroup.add(enqueueSignal);
                            try {
                                // 等待入列信号, 如果通道关闭, 则停止接收
                                if (yield es2018$3.isFailurePromise(enqueueSignal))
                                    return { done: true, value: undefined };
                            }
                            finally {
                                this.enqueueSingalGroup.remove(enqueueSignal);
                            }
                        }
                        const value = this.buffer.dequeue();
                        this.dequeueSignalGroup.emitAll();
                        return { done: false, value };
                    })
                };
            }
        };
    }
    close() {
        if (!this.isClosed) {
            this.isClosed = true;
            this.enqueueSingalGroup.discardAll();
            this.dequeueSignalGroup.discardAll();
        }
    }
}

class UnlimitedChannel {
    constructor() {
        this.isClosed = false;
        this.enqueueSignalGroup = new SignalGroup();
        this.buffer = new es2018$2.Queue();
    }
    send(value) {
        if (this.isClosed)
            throw new ChannelClosedError();
        this.buffer.enqueue(value);
        this.enqueueSignalGroup.emitAll();
    }
    receive() {
        return {
            [Symbol.asyncIterator]: () => {
                return {
                    next: () => __awaiter(this, void 0, void 0, function* () {
                        // 缓冲区队列为空, 则等待入列信号
                        while (this.buffer.size === 0) {
                            if (this.isClosed)
                                return { done: true, value: undefined };
                            const enqueueSignal = new Signal();
                            this.enqueueSignalGroup.add(enqueueSignal);
                            try {
                                // 等待入列信号, 如果通道关闭, 则停止接收
                                if (yield es2018$3.isFailurePromise(enqueueSignal))
                                    return { done: true, value: undefined };
                            }
                            finally {
                                this.enqueueSignalGroup.remove(enqueueSignal);
                            }
                        }
                        const value = this.buffer.dequeue();
                        return { done: false, value };
                    })
                };
            }
        };
    }
    close() {
        if (!this.isClosed) {
            this.isClosed = true;
            this.enqueueSignalGroup.discardAll();
        }
    }
}

function checkConcurrency(name, value) {
    if (value < 1)
        throw new InvalidArgumentError(name, '>= 1');
    if (Number.isFinite(value) && !Number.isInteger(value)) {
        throw new InvalidArgumentError(name, 'an integer');
    }
}

var eventemitter3 = createCommonjsModule(function (module) {

var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
{
  module.exports = EventEmitter;
}
});

var _internalEvents, _queue, _pending, _concurrency, _running, _debounceMicrotask;
class TaskRunner extends eventemitter3.EventEmitter {
    constructor(concurrency = Infinity) {
        super();
        _internalEvents.set(this, new eventemitter3.EventEmitter());
        _queue.set(this, new es2018$2.Queue());
        _pending.set(this, 0);
        _concurrency.set(this, void 0);
        _running.set(this, true);
        _debounceMicrotask.set(this, new DebounceMicrotask());
        this.setConcurrency(concurrency);
        const consume = () => {
            if (!__classPrivateFieldGet(this, _running))
                return;
            while (__classPrivateFieldGet(this, _pending) < __classPrivateFieldGet(this, _concurrency) && __classPrivateFieldGet(this, _queue).size > 0) {
                const task = __classPrivateFieldGet(this, _queue).dequeue();
                this.run(task);
            }
        };
        __classPrivateFieldGet(this, _internalEvents).on('update', () => {
            if (__classPrivateFieldGet(this, _running))
                __classPrivateFieldGet(this, _debounceMicrotask).queue(consume);
        });
        __classPrivateFieldGet(this, _internalEvents).on('start', (task) => {
            this.emit('started', task);
        });
        __classPrivateFieldGet(this, _internalEvents).on('resolve', (task, result) => {
            this.emit('resolved', task, result);
            if (__classPrivateFieldGet(this, _running))
                __classPrivateFieldGet(this, _debounceMicrotask).queue(consume);
        });
        __classPrivateFieldGet(this, _internalEvents).on('reject', (task, reason) => {
            __classPrivateFieldGet(this, _internalEvents).emit('pause');
            this.emit('rejected', task, reason);
        });
        __classPrivateFieldGet(this, _internalEvents).on('pause', () => {
            __classPrivateFieldSet(this, _running, false);
            __classPrivateFieldGet(this, _debounceMicrotask).cancel(consume);
        });
        __classPrivateFieldGet(this, _internalEvents).on('resume', () => {
            if (!__classPrivateFieldGet(this, _running)) {
                __classPrivateFieldSet(this, _running, true);
                __classPrivateFieldGet(this, _debounceMicrotask).queue(consume);
            }
        });
    }
    setConcurrency(concurrency) {
        checkConcurrency('concurrency', concurrency);
        __classPrivateFieldSet(this, _concurrency, concurrency);
        __classPrivateFieldGet(this, _internalEvents).emit('update');
    }
    push(...tasks) {
        __classPrivateFieldGet(this, _queue).enqueue(...tasks);
        __classPrivateFieldGet(this, _internalEvents).emit('update');
    }
    pause() {
        __classPrivateFieldGet(this, _internalEvents).emit('pause');
    }
    resume() {
        __classPrivateFieldGet(this, _internalEvents).emit('resume');
    }
    clear() {
        __classPrivateFieldGet(this, _queue).empty();
    }
    run(task) {
        return __awaiter(this, void 0, void 0, function* () {
            __classPrivateFieldSet(this, _pending, +__classPrivateFieldGet(this, _pending) + 1);
            __classPrivateFieldGet(this, _internalEvents).emit('start', task);
            const result = yield es2018$3.toResultAsync(task);
            __classPrivateFieldSet(this, _pending, +__classPrivateFieldGet(this, _pending) - 1);
            if (result.isOk()) {
                __classPrivateFieldGet(this, _internalEvents).emit('resolve', task, result.get());
            }
            else {
                __classPrivateFieldGet(this, _internalEvents).emit('reject', task, es2018$3.getError(() => result.get()));
            }
        });
    }
}
_internalEvents = new WeakMap(), _queue = new WeakMap(), _pending = new WeakMap(), _concurrency = new WeakMap(), _running = new WeakMap(), _debounceMicrotask = new WeakMap();

function asyncify(fn) {
    return function (...args) {
        return __awaiter(this, void 0, void 0, function* () {
            return Reflect.apply(fn, this, yield Promise.all(args));
        });
    };
}

function callbackify(fn) {
    return function (...args) {
        if (args.length === 0)
            throw new InvalidArgumentsLengthError('a callbackfied function', 1, 0);
        const [realArgs, cb] = sep(args);
        if (es2018$4.isntFunction(cb))
            throw new InvalidArgumentError('callback', 'a function');
        fn(...realArgs).then(result => cb(null, result), err => cb(err || new FalsyError(err)));
    };
    function sep(args) {
        const realArgs = args.slice(0, -1);
        const cb = args[args.length - 1];
        return [realArgs, cb];
    }
}
class FalsyError extends es2018$5.CustomError {
    constructor(val) {
        super();
        this.reason = val;
    }
}

/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var Reflect$1;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof commonjsGlobal === "object" ? commonjsGlobal :
            typeof self === "object" ? self :
                typeof this === "object" ? this :
                    Function("return this;")();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        else {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
            return function (key, value) {
                if (typeof target[key] !== "function") {
                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                }
                if (previous)
                    previous(key, value);
            };
        }
    })(function (exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? function () { return MakeDictionary(Object.create(null)); }
                : supportsProto
                    ? function () { return MakeDictionary({ __proto__: null }); }
                    : function () { return MakeDictionary({}); },
            has: downLevel
                ? function (map, key) { return hasOwn.call(map, key); }
                : function (map, key) { return key in map; },
            get: downLevel
                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                : function (map, key) { return map[key]; },
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        // [[Metadata]] internal slot
        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
        var Metadata = new _WeakMap();
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                    throw new TypeError();
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            if (!metadataMap.delete(metadataKey))
                return false;
            if (metadataMap.size > 0)
                return true;
            var targetMetadata = Metadata.get(target);
            targetMetadata.delete(propertyKey);
            if (targetMetadata.size > 0)
                return true;
            Metadata.delete(target);
            return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create)
                    return undefined;
                targetMetadata = new _Map();
                Metadata.set(O, targetMetadata);
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create)
                    return undefined;
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            return ToBoolean(metadataMap.has(MetadataKey));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return undefined;
            return metadataMap.get(MetadataKey);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
            metadataMap.set(MetadataKey, MetadataValue);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                    keys.length = k;
                    return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                    keys[k] = nextValue;
                }
                catch (e) {
                    try {
                        IteratorClose(iterator);
                    }
                    finally {
                        throw e;
                    }
                }
                k++;
            }
        }
        // 6 ECMAScript Data Typ0es and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined": return 0 /* Undefined */;
                case "boolean": return 2 /* Boolean */;
                case "string": return 3 /* String */;
                case "symbol": return 4 /* Symbol */;
                case "number": return 5 /* Number */;
                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                default: return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */: return input;
                case 1 /* Null */: return input;
                case 2 /* Boolean */: return input;
                case 3 /* String */: return input;
                case 4 /* Symbol */: return input;
                case 5 /* Number */: return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */: return true;
                case 4 /* Symbol */: return true;
                default: return false;
            }
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
                return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = /** @class */ (function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () { return this; };
                MapIterator.prototype[iteratorSymbol] = function () { return this; };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }());
            return /** @class */ (function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () { return this._keys.length; },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (key === this._cacheKey) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                Map.prototype["@@iterator"] = function () { return this.entries(); };
                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                Map.prototype._find = function (key, insert) {
                    if (this._cacheKey !== key) {
                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }());
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            return /** @class */ (function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () { return this._map.size; },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) { return this._map.has(value); };
                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                Set.prototype.delete = function (value) { return this._map.delete(value); };
                Set.prototype.clear = function () { this._map.clear(); };
                Set.prototype.keys = function () { return this._map.keys(); };
                Set.prototype.values = function () { return this._map.values(); };
                Set.prototype.entries = function () { return this._map.entries(); };
                Set.prototype["@@iterator"] = function () { return this.keys(); };
                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                return Set;
            }());
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return /** @class */ (function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }());
            function CreateUniqueKey() {
                var key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i)
                    buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    if (typeof crypto !== "undefined")
                        return crypto.getRandomValues(new Uint8Array(size));
                    if (typeof msCrypto !== "undefined")
                        return msCrypto.getRandomValues(new Uint8Array(size));
                    return FillRandomBytes(new Uint8Array(size), size);
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122 § 4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect$1 || (Reflect$1 = {}));

const CASCADABLE = 'extra-promise:cascadable';
function cascadify(target) {
    let promise = Promise.resolve(target);
    const { proxy, revoke } = Proxy.revocable(target, {
        get(target, prop) {
            if (es2018$4.isFunction(getMember())) {
                return (...args) => {
                    const result = Reflect.apply(getMember(), target, args);
                    promise = promise.then(() => result);
                    if (isCascadable(target, prop)) {
                        return proxy;
                    }
                    else {
                        revoke();
                        return promise;
                    }
                };
            }
            else {
                revoke();
                return promise.then(() => getMember());
            }
            function getMember() {
                return Reflect.get(target, prop);
            }
        }
    });
    return proxy;
}
function Cascadable(target, key) {
    Reflect.defineMetadata(CASCADABLE, true, target, key);
}
function isCascadable(target, key) {
    return Reflect.getMetadata(CASCADABLE, target, key);
}

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function parallel(tasks, concurrency = Infinity) {
    checkConcurrency('concurrency', concurrency);
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        let total = 0;
        let done = 0;
        let running = 0;
        let isEnd = false;
        const iterator = tasks[Symbol.iterator]();
        let resolved = new Signal();
        while (true) {
            const { value: task, done: end } = iterator.next();
            if (end) {
                isEnd = true;
                break;
            }
            else {
                runTask(task);
                total++;
                running++;
                while (running === concurrency) {
                    try {
                        yield resolved;
                    }
                    catch (_a) {
                        return;
                    }
                    finally {
                        resolved = new Signal();
                    }
                }
                if (isEnd)
                    return;
            }
        }
        if (total === 0)
            resolve();
        function runTask(task) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    yield task();
                    done++;
                    running--;
                    if (isEnd) {
                        if (total === done)
                            resolve();
                    }
                    else {
                        resolved.emit();
                    }
                }
                catch (e) {
                    isEnd = true;
                    resolved.discard();
                    reject(e);
                }
            });
        }
    }));
}

var error = createCommonjsModule(function (module, exports) {
exports.InvalidArgumentError = exports.RuntimeError = void 0;
class NamedError extends Error {
    constructor() {
        super(...arguments);
        this.name = this.constructor.name;
    }
}
class NamedRangeError extends RangeError {
    constructor() {
        super(...arguments);
        this.name = this.constructor.name;
    }
}
class RuntimeError extends NamedError {
}
exports.RuntimeError = RuntimeError;
class InvalidArgumentError extends NamedRangeError {
    constructor(name, expected) {
        if (expected) {
            super(`${name} argument must be ${expected}`);
        }
        else {
            super(`Invalid ${name} value`);
        }
    }
}
exports.InvalidArgumentError = InvalidArgumentError;

});

var chunkAsync_1 = createCommonjsModule(function (module, exports) {
exports.chunkAsync = exports.InvalidArgumentError = void 0;

Object.defineProperty(exports, "InvalidArgumentError", { enumerable: true, get: function () { return error.InvalidArgumentError; } });
function chunkAsync(iterable, size) {
    if (size <= 0)
        throw new error.InvalidArgumentError('size', '> 0');
    return (async function* () {
        let buffer = [];
        for await (const element of iterable) {
            buffer.push(element);
            if (buffer.length >= size) {
                yield buffer;
                buffer = [];
            }
        }
        if (buffer.length)
            yield buffer;
    })();
}
exports.chunkAsync = chunkAsync;

});

var chunkByAsync_1 = createCommonjsModule(function (module, exports) {
exports.chunkByAsync = void 0;

function chunkByAsync(iterable, fn) {
    if (es2018$4.isAsyncIterable(iterable)) {
        return chunkByAsyncIterable(iterable);
    }
    else {
        return chunkByIterable(iterable);
    }
    async function* chunkByAsyncIterable(iterable) {
        let buffer = [], index = 0;
        for await (const element of iterable) {
            buffer.push(element);
            if (await fn(element, index)) {
                yield buffer;
                buffer = [];
            }
            index++;
        }
        if (buffer.length)
            yield buffer;
    }
    async function* chunkByIterable(iterable) {
        let buffer = [], index = 0;
        for (const element of iterable) {
            buffer.push(element);
            if (await fn(element, index)) {
                yield buffer;
                buffer = [];
            }
            index++;
        }
        if (buffer.length)
            yield buffer;
    }
}
exports.chunkByAsync = chunkByAsync;

});

var chunkBy_1 = createCommonjsModule(function (module, exports) {
exports.chunkBy = void 0;
function* chunkBy(iterable, fn) {
    let buffer = [], index = 0;
    for (const element of iterable) {
        buffer.push(element);
        if (fn(element, index)) {
            yield buffer;
            buffer = [];
        }
        index++;
    }
    if (buffer.length)
        yield buffer;
}
exports.chunkBy = chunkBy;

});

var chunk_1 = createCommonjsModule(function (module, exports) {
exports.chunk = exports.InvalidArgumentError = void 0;

Object.defineProperty(exports, "InvalidArgumentError", { enumerable: true, get: function () { return error.InvalidArgumentError; } });
function chunk(iterable, size) {
    if (size <= 0)
        throw new error.InvalidArgumentError('size', '> 0');
    return (function* () {
        let buffer = [];
        for (const element of iterable) {
            buffer.push(element);
            if (buffer.length >= size) {
                yield buffer;
                buffer = [];
            }
        }
        if (buffer.length)
            yield buffer;
    })();
}
exports.chunk = chunk;

});

var concatAsync_1 = createCommonjsModule(function (module, exports) {
exports.concatAsync = void 0;

function concatAsync(iterable, ...otherIterables) {
    return (async function* () {
        for (const iter of [iterable, ...otherIterables]) {
            if (es2018$4.isAsyncIterable(iter)) {
                for await (const element of iter) {
                    yield element;
                }
            }
            else {
                for (const element of iter) {
                    yield element;
                }
            }
        }
    })();
}
exports.concatAsync = concatAsync;

});

var concat_1 = createCommonjsModule(function (module, exports) {
exports.concat = void 0;
function concat(iterable, ...otherIterables) {
    return (function* () {
        for (const iter of [iterable, ...otherIterables]) {
            yield* iter;
        }
    })();
}
exports.concat = concat;

});

var utils = createCommonjsModule(function (module, exports) {
exports.copyIterable = exports.copyAsyncIterable = void 0;
async function* copyAsyncIterable(iterable) {
    for await (const element of iterable) {
        yield element;
    }
}
exports.copyAsyncIterable = copyAsyncIterable;
function* copyIterable(iterable) {
    for (const element of iterable) {
        yield element;
    }
}
exports.copyIterable = copyIterable;

});

var dropAsync_1 = createCommonjsModule(function (module, exports) {
exports.dropAsync = exports.InvalidArgumentError = void 0;


Object.defineProperty(exports, "InvalidArgumentError", { enumerable: true, get: function () { return error.InvalidArgumentError; } });
function dropAsync(iterable, count) {
    if (count < 0)
        throw new error.InvalidArgumentError('count', '>= 0');
    if (count === 0)
        return utils.copyAsyncIterable(iterable);
    return (async function* () {
        const iterator = iterable[Symbol.asyncIterator]();
        let result;
        while (result = await iterator.next(), !result.done) {
            if (count <= 0)
                break;
            count--;
        }
        while (!result.done) {
            yield result.value;
            result = await iterator.next();
        }
    })();
}
exports.dropAsync = dropAsync;

});

var dropRightAsync_1 = createCommonjsModule(function (module, exports) {
exports.dropRightAsync = exports.InvalidArgumentError = void 0;

Object.defineProperty(exports, "InvalidArgumentError", { enumerable: true, get: function () { return error.InvalidArgumentError; } });

function dropRightAsync(iterable, count) {
    if (count < 0)
        throw new error.InvalidArgumentError('count', '>= 0');
    if (count === 0)
        return utils.copyAsyncIterable(iterable);
    return (async function* () {
        const arr = await toArrayAsync(iterable);
        const result = arr.slice(0, -count);
        for (const value of result) {
            yield value;
        }
    })();
}
exports.dropRightAsync = dropRightAsync;
async function toArrayAsync(iterable) {
    const result = [];
    for await (const element of iterable) {
        result.push(element);
    }
    return result;
}

});

var dropRight_1 = createCommonjsModule(function (module, exports) {
exports.dropRight = exports.InvalidArgumentError = void 0;


Object.defineProperty(exports, "InvalidArgumentError", { enumerable: true, get: function () { return error.InvalidArgumentError; } });
function dropRight(iterable, count) {
    if (count < 0)
        throw new error.InvalidArgumentError('count', '>= 0');
    if (count === 0)
        return utils.copyIterable(iterable);
    return (function* () {
        const arr = Array.from(iterable);
        yield* arr.slice(0, -count);
    })();
}
exports.dropRight = dropRight;

});

var dropUntilAsync_1 = createCommonjsModule(function (module, exports) {
exports.dropUntilAsync = void 0;

function dropUntilAsync(iterable, fn) {
    if (es2018$4.isAsyncIterable(iterable)) {
        return dropUntilAsyncIterable(iterable);
    }
    else {
        return dropUntilIterable(iterable);
    }
    async function* dropUntilAsyncIterable(iterable) {
        const iterator = iterable[Symbol.asyncIterator]();
        let index = 0;
        let result;
        while (result = await iterator.next(), !result.done) {
            if (await fn(result.value, index++))
                break;
        }
        while (!result.done) {
            yield result.value;
            result = await iterator.next();
        }
    }
    async function* dropUntilIterable(iterable) {
        const iterator = iterable[Symbol.iterator]();
        let index = 0;
        let result;
        while (result = iterator.next(), !result.done) {
            if (await fn(result.value, index++))
                break;
        }
        while (!result.done) {
            yield result.value;
            result = iterator.next();
        }
    }
}
exports.dropUntilAsync = dropUntilAsync;

});

var dropUntil_1 = createCommonjsModule(function (module, exports) {
exports.dropUntil = void 0;
function* dropUntil(iterable, fn) {
    const iterator = iterable[Symbol.iterator]();
    let index = 0;
    let result;
    while (result = iterator.next(), !result.done) {
        if (fn(result.value, index++))
            break;
    }
    while (!result.done) {
        yield result.value;
        result = iterator.next();
    }
}
exports.dropUntil = dropUntil;

});

var drop_1 = createCommonjsModule(function (module, exports) {
exports.drop = exports.InvalidArgumentError = void 0;


Object.defineProperty(exports, "InvalidArgumentError", { enumerable: true, get: function () { return error.InvalidArgumentError; } });
function drop(iterable, count) {
    if (count < 0)
        throw new error.InvalidArgumentError('count', '>= 0');
    if (count === 0)
        return utils.copyIterable(iterable);
    return (function* () {
        const iterator = iterable[Symbol.iterator]();
        let result;
        while (result = iterator.next(), !result.done) {
            if (count <= 0)
                break;
            count--;
        }
        while (!result.done) {
            yield result.value;
            result = iterator.next();
        }
    })();
}
exports.drop = drop;

});

var filterAsync_1 = createCommonjsModule(function (module, exports) {
exports.filterAsync = void 0;

function filterAsync(iterable, fn) {
    if (es2018$4.isAsyncIterable(iterable)) {
        return filterAsyncIterable(iterable);
    }
    else {
        return filterIterable(iterable);
    }
    async function* filterAsyncIterable(iterable) {
        let index = 0;
        for await (const element of iterable) {
            if (await fn(element, index))
                yield element;
            index++;
        }
    }
    async function* filterIterable(iterable) {
        let index = 0;
        for (const element of iterable) {
            if (await fn(element, index))
                yield element;
            index++;
        }
    }
}
exports.filterAsync = filterAsync;

});

var filter_1 = createCommonjsModule(function (module, exports) {
exports.filter = void 0;
function* filter(iterable, fn) {
    let index = 0;
    for (const element of iterable) {
        if (fn(element, index))
            yield element;
        index++;
    }
}
exports.filter = filter;

});

var flattenByAsync_1 = createCommonjsModule(function (module, exports) {
exports.flattenByAsync = void 0;

function flattenByAsync(iterable, fn) {
    if (es2018$4.isAsyncIterable(iterable)) {
        return flattenByAsyncIterable(iterable);
    }
    else {
        return flattenByIterable(iterable);
    }
    async function* flattenByAsyncIterable(iterable) {
        const level = 1;
        for await (const element of iterable) {
            if (isFiniteIterable(element) && await fn(element, level)) {
                yield* flatten(element, level + 1);
            }
            else {
                yield element;
            }
        }
    }
    function flattenByIterable(iterable) {
        return flatten(iterable, 1);
    }
    async function* flatten(iterable, level) {
        for (const element of iterable) {
            if (isFiniteIterable(element) && await fn(element, level)) {
                yield* flatten(element, level + 1);
            }
            else {
                yield element;
            }
        }
    }
}
exports.flattenByAsync = flattenByAsync;
function isFiniteIterable(val) {
    return es2018$4.isIterable(val) && es2018$4.isntChar(val);
}

});

var flattenDeepAsync_1 = createCommonjsModule(function (module, exports) {
exports.flattenDeepAsync = exports.InvalidArgumentError = void 0;


Object.defineProperty(exports, "InvalidArgumentError", { enumerable: true, get: function () { return error.InvalidArgumentError; } });
function flattenDeepAsync(iterable, depth = Infinity) {
    if (depth < 0)
        throw new error.InvalidArgumentError('depth', '>= 0');
    return flattenByAsync_1.flattenByAsync(iterable, (_, level) => level <= depth);
}
exports.flattenDeepAsync = flattenDeepAsync;

});

var flattenAsync_1 = createCommonjsModule(function (module, exports) {
exports.flattenAsync = void 0;

function flattenAsync(iterable) {
    return flattenDeepAsync_1.flattenDeepAsync(iterable, 1);
}
exports.flattenAsync = flattenAsync;

});

var flattenBy_1 = createCommonjsModule(function (module, exports) {
exports.flattenBy = void 0;

function flattenBy(iterable, fn) {
    return flatten(iterable, 1);
    function* flatten(iterable, level) {
        for (const element of iterable) {
            if (isFiniteIterable(element) && fn(element, level)) {
                yield* flatten(element, level + 1);
            }
            else {
                yield element;
            }
        }
    }
}
exports.flattenBy = flattenBy;
function isFiniteIterable(val) {
    return es2018$4.isIterable(val) && es2018$4.isntChar(val);
}

});

var flattenDeep_1 = createCommonjsModule(function (module, exports) {
exports.flattenDeep = exports.InvalidArgumentError = void 0;


Object.defineProperty(exports, "InvalidArgumentError", { enumerable: true, get: function () { return error.InvalidArgumentError; } });
function flattenDeep(iterable, depth = Infinity) {
    if (depth < 0)
        throw new error.InvalidArgumentError('depth', '>= 0');
    return flattenBy_1.flattenBy(iterable, (_, level) => level <= depth);
}
exports.flattenDeep = flattenDeep;

});

var flatten_1 = createCommonjsModule(function (module, exports) {
exports.flatten = void 0;

function flatten(iterable) {
    return flattenDeep_1.flattenDeep(iterable, 1);
}
exports.flatten = flatten;

});

var mapAsync_1 = createCommonjsModule(function (module, exports) {
exports.mapAsync = void 0;

function mapAsync(iterable, fn) {
    if (es2018$4.isAsyncIterable(iterable)) {
        return mapAsyncIterable(iterable);
    }
    else {
        return mapIterable(iterable);
    }
    async function* mapAsyncIterable(iterable) {
        let index = 0;
        for await (const element of iterable) {
            yield await fn(element, index);
            index++;
        }
    }
    async function* mapIterable(iterable) {
        let index = 0;
        for (const element of iterable) {
            yield await fn(element, index);
            index++;
        }
    }
}
exports.mapAsync = mapAsync;

});

var map_1 = createCommonjsModule(function (module, exports) {
exports.map = void 0;
function* map(iterable, fn) {
    let index = 0;
    for (const element of iterable) {
        yield fn(element, index);
        index++;
    }
}
exports.map = map;

});

var repeatAsync_1 = createCommonjsModule(function (module, exports) {
exports.repeatAsync = exports.InvalidArgumentError = void 0;

Object.defineProperty(exports, "InvalidArgumentError", { enumerable: true, get: function () { return error.InvalidArgumentError; } });
function repeatAsync(iterable, times) {
    if (times < 0)
        throw new error.InvalidArgumentError('times', '>= 0');
    if (times === Infinity)
        warnInfiniteLoop();
    return (async function* () {
        const cache = [];
        if (times > 0) {
            for await (const element of iterable) {
                yield element;
                cache.push(element);
            }
            times--;
        }
        while (times > 0) {
            yield* cache;
            times--;
        }
    })();
}
exports.repeatAsync = repeatAsync;
function warnInfiniteLoop() {
    if (isProduction())
        return;
    console.warn('When iterable has no elements and times is Infinity, repeat() will be in dead loop');
}
function isProduction() {
    return process.env.NODE_ENV === 'production';
}

});

var repeat_1 = createCommonjsModule(function (module, exports) {
exports.repeat = exports.InvalidArgumentError = void 0;

Object.defineProperty(exports, "InvalidArgumentError", { enumerable: true, get: function () { return error.InvalidArgumentError; } });
function repeat(iterable, times) {
    if (times < 0)
        throw new error.InvalidArgumentError('times', '>= 0');
    if (times === Infinity)
        warnInfiniteLoop();
    return (function* () {
        const cache = [];
        if (times > 0) {
            for (const element of iterable) {
                yield element;
                cache.push(element);
            }
            times--;
        }
        while (times > 0) {
            yield* cache;
            times--;
        }
    })();
}
exports.repeat = repeat;
function warnInfiniteLoop() {
    if (isProduction())
        return;
    console.warn('When iterable has no elements and times is Infinity, repeat() will be in dead loop');
}
function isProduction() {
    return process.env.NODE_ENV === 'production';
}

});

var sliceAsync_1 = createCommonjsModule(function (module, exports) {
exports.sliceAsync = exports.InvalidArgumentError = void 0;

Object.defineProperty(exports, "InvalidArgumentError", { enumerable: true, get: function () { return error.InvalidArgumentError; } });
function sliceAsync(iterable, start, end = Infinity) {
    if (start < 0)
        throw new error.InvalidArgumentError('start', '>= 0');
    if (end < start)
        throw new error.InvalidArgumentError('end', '>= start');
    return (async function* () {
        let index = 0;
        for await (const element of iterable) {
            if (index >= end)
                break;
            if (index >= start)
                yield element;
            index++;
        }
    })();
}
exports.sliceAsync = sliceAsync;

});

var slice_1 = createCommonjsModule(function (module, exports) {
exports.slice = exports.InvalidArgumentError = void 0;

Object.defineProperty(exports, "InvalidArgumentError", { enumerable: true, get: function () { return error.InvalidArgumentError; } });
function slice(iterable, start, end = Infinity) {
    if (start < 0)
        throw new error.InvalidArgumentError('start', '>= 0');
    if (end < start)
        throw new error.InvalidArgumentError('end', '>= start');
    return (function* () {
        let index = 0;
        for (const element of iterable) {
            if (index >= end)
                break;
            if (index >= start)
                yield element;
            index++;
        }
    })();
}
exports.slice = slice;

});

var splitAsync_1 = createCommonjsModule(function (module, exports) {
exports.splitAsync = void 0;
async function* splitAsync(iterable, separator) {
    let buffer = [];
    for await (const element of iterable) {
        if (element === separator) {
            yield buffer;
            buffer = [];
        }
        else {
            buffer.push(element);
        }
    }
    yield buffer;
}
exports.splitAsync = splitAsync;

});

var splitByAsync_1 = createCommonjsModule(function (module, exports) {
exports.splitByAsync = void 0;

function splitByAsync(iterable, fn) {
    if (es2018$4.isAsyncIterable(iterable)) {
        return splitByAsyncIterable(iterable);
    }
    else {
        return splitByIterable(iterable);
    }
    async function* splitByIterable(iterable) {
        let buffer = [], index = 0;
        for (const element of iterable) {
            if (await fn(element, index)) {
                yield buffer;
                buffer = [];
            }
            else {
                buffer.push(element);
            }
            index++;
        }
        yield buffer;
    }
    async function* splitByAsyncIterable(iterable) {
        let buffer = [], index = 0;
        for await (const element of iterable) {
            if (await fn(element, index)) {
                yield buffer;
                buffer = [];
            }
            else {
                buffer.push(element);
            }
            index++;
        }
        yield buffer;
    }
}
exports.splitByAsync = splitByAsync;

});

var splitBy_1 = createCommonjsModule(function (module, exports) {
exports.splitBy = void 0;
function* splitBy(iterable, fn) {
    let buffer = [], index = 0;
    for (const element of iterable) {
        if (fn(element, index)) {
            yield buffer;
            buffer = [];
        }
        else {
            buffer.push(element);
        }
        index++;
    }
    yield buffer;
}
exports.splitBy = splitBy;

});

var split_1 = createCommonjsModule(function (module, exports) {
exports.split = void 0;
function* split(iterable, separator) {
    let buffer = [];
    for (const element of iterable) {
        if (element === separator) {
            yield buffer;
            buffer = [];
        }
        else {
            buffer.push(element);
        }
    }
    yield buffer;
}
exports.split = split;

});

var takeAsync_1 = createCommonjsModule(function (module, exports) {
exports.takeAsync = exports.InvalidArgumentError = void 0;

Object.defineProperty(exports, "InvalidArgumentError", { enumerable: true, get: function () { return error.InvalidArgumentError; } });
function takeAsync(iterable, count) {
    if (count < 0)
        throw new error.InvalidArgumentError('count', '>= 0');
    return (async function* () {
        if (count === 0)
            return;
        for await (const element of iterable) {
            yield element;
            count--;
            if (count === 0)
                break;
        }
    })();
}
exports.takeAsync = takeAsync;

});

var takeRightAsync_1 = createCommonjsModule(function (module, exports) {
exports.takeRightAsync = exports.InvalidArgumentError = void 0;

Object.defineProperty(exports, "InvalidArgumentError", { enumerable: true, get: function () { return error.InvalidArgumentError; } });
function takeRightAsync(iterable, count) {
    if (count < 0)
        throw new error.InvalidArgumentError('count', '>= 0');
    return (async function* () {
        const iterator = iterable[Symbol.asyncIterator]();
        const buffer = [];
        let result;
        while (result = await iterator.next(), !result.done) {
            buffer.push(result.value);
            if (buffer.length > count)
                buffer.shift();
        }
        yield* buffer;
    })();
}
exports.takeRightAsync = takeRightAsync;

});

var takeRight_1 = createCommonjsModule(function (module, exports) {
exports.takeRight = exports.InvalidArgumentError = void 0;

Object.defineProperty(exports, "InvalidArgumentError", { enumerable: true, get: function () { return error.InvalidArgumentError; } });
function takeRight(iterable, count) {
    if (count < 0)
        throw new error.InvalidArgumentError('count', '>= 0');
    return (function* () {
        const iterator = iterable[Symbol.iterator]();
        const buffer = [];
        let result;
        while (result = iterator.next(), !result.done) {
            buffer.push(result.value);
            if (buffer.length > count)
                buffer.shift();
        }
        yield* buffer;
    })();
}
exports.takeRight = takeRight;

});

var takeUntilAsync_1 = createCommonjsModule(function (module, exports) {
exports.takeUntilAsync = void 0;

function takeUntilAsync(iterable, fn) {
    if (es2018$4.isAsyncIterable(iterable)) {
        return takeUntilAsyncIterable(iterable);
    }
    else {
        return takeUntilIterable(iterable);
    }
    async function* takeUntilAsyncIterable(iterable) {
        let index = 0;
        for await (const element of iterable) {
            if (await fn(element, index))
                break;
            yield element;
            index++;
        }
    }
    async function* takeUntilIterable(iterable) {
        let index = 0;
        for (const element of iterable) {
            if (await fn(element, index))
                break;
            yield element;
            index++;
        }
    }
}
exports.takeUntilAsync = takeUntilAsync;

});

var takeUntil_1 = createCommonjsModule(function (module, exports) {
exports.takeUntil = void 0;
function* takeUntil(iterable, fn) {
    let index = 0;
    for (const element of iterable) {
        if (fn(element, index))
            break;
        yield element;
        index++;
    }
}
exports.takeUntil = takeUntil;

});

var take_1 = createCommonjsModule(function (module, exports) {
exports.take = exports.InvalidArgumentError = void 0;

Object.defineProperty(exports, "InvalidArgumentError", { enumerable: true, get: function () { return error.InvalidArgumentError; } });
function take(iterable, count) {
    if (count < 0)
        throw new error.InvalidArgumentError('count', '>= 0');
    return (function* () {
        if (count === 0)
            return;
        for (const element of iterable) {
            yield element;
            count--;
            if (count === 0)
                break;
        }
    })();
}
exports.take = take;

});

var tapAsync_1 = createCommonjsModule(function (module, exports) {
exports.tapAsync = void 0;

function tapAsync(iterable, fn) {
    if (es2018$4.isAsyncIterable(iterable)) {
        return tapAsyncIterable(iterable);
    }
    else {
        return tapIterable(iterable);
    }
    async function* tapIterable(iterable) {
        let index = 0;
        for (const element of iterable) {
            await fn(element, index);
            yield element;
            index++;
        }
    }
    async function* tapAsyncIterable(iterable) {
        let index = 0;
        for await (const element of iterable) {
            await fn(element, index);
            yield element;
            index++;
        }
    }
}
exports.tapAsync = tapAsync;

});

var tap_1 = createCommonjsModule(function (module, exports) {
exports.tap = void 0;
function* tap(iterable, fn) {
    let index = 0;
    for (const element of iterable) {
        fn(element, index);
        yield element;
        index++;
    }
}
exports.tap = tap;

});

var toAsyncIterable_1 = createCommonjsModule(function (module, exports) {
exports.toAsyncIterable = void 0;
async function* toAsyncIterable(iterable) {
    for (const value of iterable) {
        yield value;
    }
}
exports.toAsyncIterable = toAsyncIterable;

});

var transformAsync_1 = createCommonjsModule(function (module, exports) {
exports.transformAsync = void 0;
async function* transformAsync(iterable, transformer) {
    yield* transformer(iterable);
}
exports.transformAsync = transformAsync;

});

var transform_1 = createCommonjsModule(function (module, exports) {
exports.transform = void 0;
function* transform(iterable, transformer) {
    yield* transformer(iterable);
}
exports.transform = transform;

});

var uniqAsync_1 = createCommonjsModule(function (module, exports) {
exports.uniqAsync = void 0;
async function* uniqAsync(iterable) {
    const bucket = new Set();
    for await (const element of iterable) {
        if (!bucket.has(element)) {
            yield element;
            bucket.add(element);
        }
    }
}
exports.uniqAsync = uniqAsync;

});

var uniqByAsync_1 = createCommonjsModule(function (module, exports) {
exports.uniqByAsync = void 0;

function uniqByAsync(iterable, fn) {
    if (es2018$4.isAsyncIterable(iterable)) {
        return uniqByAsyncIterable(iterable);
    }
    else {
        return uniqByIterable(iterable);
    }
    async function* uniqByAsyncIterable(iterable) {
        const bucket = new Set();
        let index = 0;
        for await (const element of iterable) {
            const result = await fn(element, index);
            if (!bucket.has(result)) {
                yield element;
                bucket.add(result);
            }
            index++;
        }
    }
    async function* uniqByIterable(iterable) {
        const bucket = new Set();
        let index = 0;
        for (const element of iterable) {
            const result = await fn(element, index);
            if (!bucket.has(result)) {
                yield element;
                bucket.add(result);
            }
            index++;
        }
    }
}
exports.uniqByAsync = uniqByAsync;

});

var uniqBy_1 = createCommonjsModule(function (module, exports) {
exports.uniqBy = void 0;
function* uniqBy(iterable, fn) {
    const bucket = new Set();
    let index = 0;
    for (const element of iterable) {
        const result = fn(element, index);
        if (!bucket.has(result)) {
            yield element;
            bucket.add(result);
        }
        index++;
    }
}
exports.uniqBy = uniqBy;

});

var uniq_1 = createCommonjsModule(function (module, exports) {
exports.uniq = void 0;
function* uniq(iterable) {
    const bucket = new Set();
    for (const element of iterable) {
        if (!bucket.has(element)) {
            yield element;
            bucket.add(element);
        }
    }
}
exports.uniq = uniq;

});

var zipAsync_1 = createCommonjsModule(function (module, exports) {
exports.zipAsync = void 0;

function zipAsync(iterable, ...otherIterables) {
    return zipWithSize(iterable, ...otherIterables);
}
exports.zipAsync = zipAsync;
async function* zipWithSize(...iterables) {
    const length = iterables.length;
    const iterators = iterables.map(iterable => {
        if (es2018$4.isAsyncIterable(iterable)) {
            return [Symbol.asyncIterator, iterable[Symbol.asyncIterator]()];
        }
        else {
            return [Symbol.iterator, iterable[Symbol.iterator]()];
        }
    });
    while (true) {
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            const [type, iterator] = iterators[i];
            let temp;
            if (type === Symbol.asyncIterator) {
                temp = await iterator.next();
            }
            else {
                temp = iterator.next();
            }
            if (temp.done)
                return;
            result[i] = temp.value;
        }
        yield result;
    }
}

});

var zip_1 = createCommonjsModule(function (module, exports) {
exports.zip = void 0;
function zip(iterable, ...otherIterables) {
    return zipWithSize(iterable, ...otherIterables);
}
exports.zip = zip;
function* zipWithSize(...iterables) {
    const length = iterables.length;
    const iterators = iterables.map(iterable => iterable[Symbol.iterator]());
    while (true) {
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            const { value, done } = iterators[i].next();
            if (done)
                return;
            result[i] = value;
        }
        yield result;
    }
}

});

var middleware = createCommonjsModule(function (module, exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};__exportStar(chunkAsync_1, exports);
__exportStar(chunkByAsync_1, exports);
__exportStar(chunkBy_1, exports);
__exportStar(chunk_1, exports);
__exportStar(concatAsync_1, exports);
__exportStar(concat_1, exports);
__exportStar(dropAsync_1, exports);
__exportStar(dropRightAsync_1, exports);
__exportStar(dropRight_1, exports);
__exportStar(dropUntilAsync_1, exports);
__exportStar(dropUntil_1, exports);
__exportStar(drop_1, exports);
__exportStar(filterAsync_1, exports);
__exportStar(filter_1, exports);
__exportStar(flattenAsync_1, exports);
__exportStar(flattenByAsync_1, exports);
__exportStar(flattenBy_1, exports);
__exportStar(flattenDeepAsync_1, exports);
__exportStar(flattenDeep_1, exports);
__exportStar(flatten_1, exports);
__exportStar(mapAsync_1, exports);
__exportStar(map_1, exports);
__exportStar(repeatAsync_1, exports);
__exportStar(repeat_1, exports);
__exportStar(sliceAsync_1, exports);
__exportStar(slice_1, exports);
__exportStar(splitAsync_1, exports);
__exportStar(splitByAsync_1, exports);
__exportStar(splitBy_1, exports);
__exportStar(split_1, exports);
__exportStar(takeAsync_1, exports);
__exportStar(takeRightAsync_1, exports);
__exportStar(takeRight_1, exports);
__exportStar(takeUntilAsync_1, exports);
__exportStar(takeUntil_1, exports);
__exportStar(take_1, exports);
__exportStar(tapAsync_1, exports);
__exportStar(tap_1, exports);
__exportStar(toAsyncIterable_1, exports);
__exportStar(transformAsync_1, exports);
__exportStar(transform_1, exports);
__exportStar(uniqAsync_1, exports);
__exportStar(uniqByAsync_1, exports);
__exportStar(uniqBy_1, exports);
__exportStar(uniq_1, exports);
__exportStar(zipAsync_1, exports);
__exportStar(zip_1, exports);

});

var consume_1 = createCommonjsModule(function (module, exports) {
exports.consume = void 0;
function consume(iterable, consumer) {
    return consumer(iterable);
}
exports.consume = consume;

});

var eachAsync_1 = createCommonjsModule(function (module, exports) {
exports.eachAsync = void 0;

function eachAsync(iterable, fn) {
    if (es2018$4.isAsyncIterable(iterable)) {
        return eachAsyncIterable(iterable);
    }
    else {
        return eachIterable(iterable);
    }
    async function eachAsyncIterable(iterable) {
        let index = 0;
        for await (const element of iterable) {
            await fn(element, index);
            index++;
        }
    }
    async function eachIterable(iterable) {
        let index = 0;
        for (const element of iterable) {
            await fn(element, index);
            index++;
        }
    }
}
exports.eachAsync = eachAsync;

});

var each_1 = createCommonjsModule(function (module, exports) {
exports.each = void 0;
function each(iterable, fn) {
    let index = 0;
    for (const element of iterable) {
        fn(element, index);
        index++;
    }
}
exports.each = each;

});

var everyAsync_1 = createCommonjsModule(function (module, exports) {
exports.everyAsync = void 0;

function everyAsync(iterable, fn) {
    if (es2018$4.isAsyncIterable(iterable)) {
        return everyAsyncIterable(iterable);
    }
    else {
        return everyIterable(iterable);
    }
    async function everyIterable(iterable) {
        let index = 0;
        for (const element of iterable) {
            if (!await fn(element, index))
                return false;
            index++;
        }
        return true;
    }
    async function everyAsyncIterable(iterable) {
        let index = 0;
        for await (const element of iterable) {
            if (!await fn(element, index))
                return false;
            index++;
        }
        return true;
    }
}
exports.everyAsync = everyAsync;

});

var every_1 = createCommonjsModule(function (module, exports) {
exports.every = void 0;
function every(iterable, fn) {
    let index = 0;
    for (const element of iterable) {
        if (!fn(element, index))
            return false;
        index++;
    }
    return true;
}
exports.every = every;

});

var findAsync_1 = createCommonjsModule(function (module, exports) {
exports.findAsync = exports.RuntimeError = void 0;


Object.defineProperty(exports, "RuntimeError", { enumerable: true, get: function () { return error.RuntimeError; } });
function findAsync(iterable, fn) {
    if (es2018$4.isAsyncIterable(iterable)) {
        return findAsyncIterable(iterable);
    }
    else {
        return findIterable(iterable);
    }
    async function findIterable(iterable) {
        let index = 0;
        for (const element of iterable) {
            if (await fn(element, index))
                return element;
            index++;
        }
        throw new error.RuntimeError('Iterable has no matched elements');
    }
    async function findAsyncIterable(iterable) {
        let index = 0;
        for await (const element of iterable) {
            if (await fn(element, index))
                return element;
            index++;
        }
        throw new error.RuntimeError('Iterable has no matched elements');
    }
}
exports.findAsync = findAsync;

});

var find_1 = createCommonjsModule(function (module, exports) {
exports.find = exports.RuntimeError = void 0;

Object.defineProperty(exports, "RuntimeError", { enumerable: true, get: function () { return error.RuntimeError; } });
function find(iterable, fn) {
    let index = 0;
    for (const element of iterable) {
        if (fn(element, index))
            return element;
        index++;
    }
    throw new error.RuntimeError('Iterable has no matched elements');
}
exports.find = find;

});

var firstAsync_1 = createCommonjsModule(function (module, exports) {
exports.firstAsync = exports.RuntimeError = void 0;

Object.defineProperty(exports, "RuntimeError", { enumerable: true, get: function () { return error.RuntimeError; } });
async function firstAsync(iterable) {
    for await (const element of iterable) {
        return element;
    }
    throw new error.RuntimeError('Iterable is empty');
}
exports.firstAsync = firstAsync;

});

var first_1 = createCommonjsModule(function (module, exports) {
exports.first = exports.RuntimeError = void 0;

Object.defineProperty(exports, "RuntimeError", { enumerable: true, get: function () { return error.RuntimeError; } });
function first(iterable) {
    for (const element of iterable) {
        return element;
    }
    throw new error.RuntimeError('Iterable is empty');
}
exports.first = first;

});

var includesAsync_1 = createCommonjsModule(function (module, exports) {
exports.includesAsync = void 0;
async function includesAsync(iterable, value) {
    for await (const element of iterable) {
        if (element === value)
            return true;
    }
    return false;
}
exports.includesAsync = includesAsync;

});

var includes_1 = createCommonjsModule(function (module, exports) {
exports.includes = void 0;
function includes(iterable, value) {
    for (const element of iterable) {
        if (element === value)
            return true;
    }
    return false;
}
exports.includes = includes;

});

var matchAsync_1 = createCommonjsModule(function (module, exports) {
exports.matchAsync = void 0;
async function matchAsync(iterable, sequence) {
    const sequenceLength = sequence.length;
    let matchCount = 0;
    for await (const element of iterable) {
        if (element === sequence[matchCount])
            matchCount++;
        if (matchCount === sequenceLength)
            return true;
    }
    return false;
}
exports.matchAsync = matchAsync;

});

var match_1 = createCommonjsModule(function (module, exports) {
exports.match = void 0;
function match(iterable, sequence) {
    const sequenceLength = sequence.length;
    let matchCount = 0;
    for (const element of iterable) {
        if (element === sequence[matchCount])
            matchCount++;
        if (matchCount === sequenceLength)
            return true;
    }
    return false;
}
exports.match = match;

});

var reduceAsync_1 = createCommonjsModule(function (module, exports) {
exports.reduceAsync = exports.RuntimeError = void 0;


Object.defineProperty(exports, "RuntimeError", { enumerable: true, get: function () { return error.RuntimeError; } });
function reduceAsync(iterable, fn, initialValue) {
    if (es2018$4.isUndefined(initialValue)) {
        return reduceAsyncWithoutInitialValue(iterable, fn);
    }
    else {
        return reduceAsyncWithInitialValue(iterable, fn, initialValue);
    }
}
exports.reduceAsync = reduceAsync;
function reduceAsyncWithInitialValue(iterable, fn, initialValue) {
    if (es2018$4.isAsyncIterable(iterable)) {
        return reduceAsyncIterable(iterable);
    }
    else {
        return reduceIterable(iterable);
    }
    async function reduceIterable(iterable) {
        let result = initialValue, index = 0;
        for (const currentValue of iterable) {
            result = await fn(result, currentValue, index++);
        }
        return result;
    }
    async function reduceAsyncIterable(iterable) {
        let result = initialValue, index = 0;
        for await (const currentValue of iterable) {
            result = await fn(result, currentValue, index++);
        }
        return result;
    }
}
function reduceAsyncWithoutInitialValue(iterable, fn) {
    if (es2018$4.isAsyncIterable(iterable)) {
        return reduceAsyncIterable(iterable);
    }
    else {
        return reduceIterable(iterable);
    }
    async function reduceAsyncIterable(iterable) {
        const [initialValue, iterator] = await readFirst(iterable);
        let result = initialValue, index = 1;
        while (true) {
            const current = await iterator.next();
            if (current.done)
                break;
            const currentValue = current.value;
            result = await fn(result, currentValue, index++);
        }
        return result;
        async function readFirst(iterable) {
            const [[result], iterator] = await read(iterable, 1);
            return [result, iterator];
        }
        async function read(iterable, count) {
            const iterator = iterable[Symbol.asyncIterator]();
            const result = [];
            while (count > 0) {
                const current = await iterator.next();
                if (current.done)
                    throw new error.RuntimeError('Reduce of empty iterable with no initial value');
                result.push(current.value);
                count--;
            }
            return [result, iterator];
        }
    }
    async function reduceIterable(iterable) {
        const [initialValue, iterator] = readFirst(iterable);
        let result = initialValue, index = 1;
        while (true) {
            const current = iterator.next();
            if (current.done)
                break;
            const currentValue = current.value;
            result = await fn(result, currentValue, index++);
        }
        return result;
        function readFirst(iterable) {
            const [[result], iterator] = read(iterable, 1);
            return [result, iterator];
        }
        function read(iterable, count) {
            const iterator = iterable[Symbol.iterator]();
            const result = [];
            while (count > 0) {
                const current = iterator.next();
                if (current.done)
                    throw new error.RuntimeError('Reduce of empty iterable with no initial value');
                result.push(current.value);
                count--;
            }
            return [result, iterator];
        }
    }
}

});

var reduce_1 = createCommonjsModule(function (module, exports) {
exports.reduce = exports.RuntimeError = void 0;


Object.defineProperty(exports, "RuntimeError", { enumerable: true, get: function () { return error.RuntimeError; } });
function reduce(iterable, fn, initialValue) {
    if (es2018$4.isUndefined(initialValue)) {
        return reduceWithoutInitialValue(iterable, fn);
    }
    else {
        return reduceWithInitialValue(iterable, fn, initialValue);
    }
}
exports.reduce = reduce;
function reduceWithInitialValue(iterable, fn, initialValue) {
    let result = initialValue, index = 0;
    for (const currentValue of iterable) {
        result = fn(result, currentValue, index++);
    }
    return result;
}
function reduceWithoutInitialValue(iterable, fn) {
    const [initialValue, iterator] = readFirst(iterable);
    let result = initialValue, index = 1;
    while (true) {
        const current = iterator.next();
        if (current.done)
            break;
        const currentValue = current.value;
        result = fn(result, currentValue, index++);
    }
    return result;
    function readFirst(iterable) {
        const [[result], iterator] = read(iterable, 1);
        return [result, iterator];
    }
    function read(iterable, count) {
        const iterator = iterable[Symbol.iterator]();
        const result = [];
        while (count > 0) {
            const current = iterator.next();
            if (current.done)
                throw new error.RuntimeError('Reduce of empty iterable with no initial value');
            result.push(current.value);
            count--;
        }
        return [result, iterator];
    }
}

});

var someAsync_1 = createCommonjsModule(function (module, exports) {
exports.someAsync = void 0;

function someAsync(iterable, fn) {
    if (es2018$4.isAsyncIterable(iterable)) {
        return someAsyncIterable(iterable);
    }
    else {
        return someIterable(iterable);
    }
    async function someIterable(iterable) {
        let index = 0;
        for (const element of iterable) {
            if (await fn(element, index))
                return true;
            index++;
        }
        return false;
    }
    async function someAsyncIterable(iterable) {
        let index = 0;
        for await (const element of iterable) {
            if (await fn(element, index))
                return true;
            index++;
        }
        return false;
    }
}
exports.someAsync = someAsync;

});

var some_1 = createCommonjsModule(function (module, exports) {
exports.some = void 0;
function some(iterable, fn) {
    let index = 0;
    for (const element of iterable) {
        if (fn(element, index))
            return true;
        index++;
    }
    return false;
}
exports.some = some;

});

var lastAsync_1 = createCommonjsModule(function (module, exports) {
exports.lastAsync = exports.RuntimeError = void 0;

Object.defineProperty(exports, "RuntimeError", { enumerable: true, get: function () { return error.RuntimeError; } });
async function lastAsync(iterable) {
    const iterator = iterable[Symbol.asyncIterator]();
    let { value, done } = await iterator.next();
    if (done)
        throw new error.RuntimeError('Iterable is empty');
    let result = value;
    while ({ value, done } = await iterator.next(), !done) {
        result = value;
    }
    return result;
}
exports.lastAsync = lastAsync;

});

var last_1 = createCommonjsModule(function (module, exports) {
exports.last = exports.RuntimeError = void 0;

Object.defineProperty(exports, "RuntimeError", { enumerable: true, get: function () { return error.RuntimeError; } });
function last(iterable) {
    const iterator = iterable[Symbol.iterator]();
    let { value, done } = iterator.next();
    if (done)
        throw new error.RuntimeError('Iterable is empty');
    let result = value;
    while ({ value, done } = iterator.next(), !done) {
        result = value;
    }
    return result;
}
exports.last = last;

});

var toArrayAsync_1 = createCommonjsModule(function (module, exports) {
exports.toArrayAsync = void 0;

function toArrayAsync(iterable) {
    return consume_1.consume(iterable, async (iterable) => {
        const result = [];
        for await (const element of iterable) {
            result.push(element);
        }
        return result;
    });
}
exports.toArrayAsync = toArrayAsync;

});

var toArray_1 = createCommonjsModule(function (module, exports) {
exports.toArray = void 0;

function toArray(iterable) {
    return consume_1.consume(iterable, iterable => Array.from(iterable));
}
exports.toArray = toArray;

});

var toSetAsync_1 = createCommonjsModule(function (module, exports) {
exports.toSetAsync = void 0;

function toSetAsync(iterable) {
    return consume_1.consume(iterable, async (iterable) => {
        const result = new Set();
        for await (const element of iterable) {
            result.add(element);
        }
        return result;
    });
}
exports.toSetAsync = toSetAsync;

});

var toSet_1 = createCommonjsModule(function (module, exports) {
exports.toSet = void 0;

function toSet(iterable) {
    return consume_1.consume(iterable, iterable => new Set(iterable));
}
exports.toSet = toSet;

});

var output = createCommonjsModule(function (module, exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};__exportStar(consume_1, exports);
__exportStar(eachAsync_1, exports);
__exportStar(each_1, exports);
__exportStar(everyAsync_1, exports);
__exportStar(every_1, exports);
__exportStar(findAsync_1, exports);
__exportStar(find_1, exports);
__exportStar(firstAsync_1, exports);
__exportStar(first_1, exports);
__exportStar(includesAsync_1, exports);
__exportStar(includes_1, exports);
__exportStar(matchAsync_1, exports);
__exportStar(match_1, exports);
__exportStar(reduceAsync_1, exports);
__exportStar(reduce_1, exports);
__exportStar(someAsync_1, exports);
__exportStar(some_1, exports);
__exportStar(lastAsync_1, exports);
__exportStar(last_1, exports);
__exportStar(toArrayAsync_1, exports);
__exportStar(toArray_1, exports);
__exportStar(toSetAsync_1, exports);
__exportStar(toSet_1, exports);

});

var es2018$1 = createCommonjsModule(function (module, exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};__exportStar(middleware, exports);
__exportStar(output, exports);

});

function each(iterable, fn, concurrency = Infinity) {
    checkConcurrency('concurrency', concurrency);
    return (() => __awaiter(this, void 0, void 0, function* () {
        const tasks = es2018$1.map(iterable, (element, i) => () => fn(element, i));
        yield parallel(tasks, concurrency);
    }))();
}

function filter(iterable, fn, concurrency = Infinity) {
    checkConcurrency('concurrency', concurrency);
    return (() => __awaiter(this, void 0, void 0, function* () {
        const results = [];
        yield each(iterable, (x, i) => __awaiter(this, void 0, void 0, function* () {
            if (yield fn(x, i))
                results[i] = x;
        }), concurrency);
        // Object.values will drop empty elements: Object.values([1,,,2]) = [1, 2]
        return Object.values(results);
    }))();
}

function isPromise(val) {
    return val instanceof Promise;
}

function isPromiseLike(val) {
    return es2018$4.isObject(val) && typeof val.then === 'function';
}

function isntPromise(val) {
    return !isPromise(val);
}

function isntPromiseLike(val) {
    return !isPromiseLike(val);
}

function map(iterable, fn, concurrency = Infinity) {
    checkConcurrency('concurrency', concurrency);
    return (() => __awaiter(this, void 0, void 0, function* () {
        const results = [];
        yield each(iterable, (x, i) => __awaiter(this, void 0, void 0, function* () {
            results[i] = yield fn(x, i);
        }), concurrency);
        return results;
    }))();
}

function promisify(fn) {
    return function (...args) {
        return new Promise((resolve, reject) => {
            fn(...args, (err, result) => {
                if (err)
                    return reject(err);
                resolve(result);
            });
        });
    };
}

function retryUntil(fn, until) {
    return __awaiter(this, void 0, void 0, function* () {
        while (true) {
            try {
                return yield fn();
            }
            catch (error) {
                if (yield until(error))
                    throw error;
            }
        }
    });
}

function series(tasks) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const task of tasks) {
            yield task();
        }
    });
}

function timeout(ms) {
    return new Promise((_, reject) => {
        setTimeout(() => reject(new TimeoutError()), ms);
    });
}
class TimeoutError extends es2018$5.CustomError {
}

var fetch_browser = createCommonjsModule(function (module, exports) {
exports.fetch = void 0;
exports.fetch = globalThis.fetch.bind(globalThis);

});

var headers_browser = createCommonjsModule(function (module, exports) {
exports.Headers = void 0;
exports.Headers = globalThis.Headers;

});

var request_browser = createCommonjsModule(function (module, exports) {
exports.Request = void 0;
exports.Request = globalThis.Request;

});

var response_browser = createCommonjsModule(function (module, exports) {
exports.Response = void 0;
exports.Response = globalThis.Response;

});

var formData_browser = createCommonjsModule(function (module, exports) {
exports.FormData = void 0;
exports.FormData = globalThis.FormData;

});

var abortController_browser = createCommonjsModule(function (module, exports) {
exports.AbortController = void 0;
exports.AbortController = globalThis.AbortController;

});

var blob_browser = createCommonjsModule(function (module, exports) {
exports.Blob = void 0;
exports.Blob = globalThis.Blob;

});

var eventSource_browser = createCommonjsModule(function (module, exports) {
exports.EventSource = void 0;
exports.EventSource = globalThis.EventSource;

});

var es2018 = createCommonjsModule(function (module, exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};__exportStar(fetch_browser, exports);
__exportStar(headers_browser, exports);
__exportStar(request_browser, exports);
__exportStar(response_browser, exports);
__exportStar(formData_browser, exports);
__exportStar(abortController_browser, exports);
__exportStar(blob_browser, exports);
__exportStar(eventSource_browser, exports);

});

function timeoutSignal(ms) {
    const controller = new es2018.AbortController();
    setTimeout(() => controller.abort(), ms);
    return controller.signal;
}

function waterfall(tasks) {
    return __awaiter(this, void 0, void 0, function* () {
        let result;
        for (const task of tasks) {
            result = yield task(result);
        }
        return result;
    });
}

function pad(ms, fn) {
    return __awaiter(this, void 0, void 0, function* () {
        const start = Date.now();
        const [err, res] = yield es2018$3.getErrorResultAsync(() => __awaiter(this, void 0, void 0, function* () { return fn(); }));
        if (err)
            throw err;
        const elapsed = Date.now() - start;
        if (elapsed < ms)
            yield delay(ms);
        return res;
    });
}

export { BufferedChannel, Cascadable, Channel, ChannelClosedError, DebounceMicrotask, Deferred, FalsyError, InvalidArgumentError, InvalidArgumentsLengthError, LazyPromise, Mutex, Semaphore, Signal, SignalDiscarded, SignalGroup, TaskRunner, TimeoutError, UnlimitedChannel, asyncify, callbackify, cascadify, delay, each, filter, isPromise, isPromiseLike, isntPromise, isntPromiseLike, map, pad, parallel, promisify, retryUntil, series, timeout, timeoutSignal, waterfall };
//# sourceMappingURL=index.mjs.map
